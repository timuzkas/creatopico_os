-- File: .cbuffer/Files.app
 local app = "local disk,size='Øï2›¯:h‚.Eˆ£øíŸú³‰Å4v„&/K²×–vÁÌ_lıáïJ›DBÅ?§Êí\\\\B¡\\\\I¢¥(á*ØkÊö˜t;ŞØX[daÜáíz› ×Ù_ïw{–ò-˜3‘¸¹ôTOË+İêEW‹$–ïµV­~ò‹N…iFLe|ˆÖ‘{-\\n/?*^üQu›î3°r q×ÚÌµm¶®ã°X(èÁ¶Ú4Y¹pÕf…j\\rş	ëkdæå*HßPbDa™Ìn¥?œù|l?±ªRÒ4ãÿ‚mòJkÍS%N°Äa œ=Š*Ù(¾&G#Wr$©L—lK)e]ú,GS%KSø—fÜzš³¡à…Ëµü#ÿ!DˆaO´uïH›P“§’¯±8ñ>‰‹½>)ıBT ™®ìb!Û1pø£\\rCqQ§®ÍÇ‹©Bcø²W~œLCàçj®¿ä¢‚ñĞ5½\\000ŞT‚&z £h‡ŠĞªÁ¨q‚-;˜K%¬È¿yGDî³~ô~Uô­©QË±ŠÔíÒ»zñB¥d0‡BRÑ%çô¥/âCòIòÏ£¡ÿ%¼áĞ[aˆÊ¹`‹%°§rª¦4Èt1W©v#\\'(£\\'“:à„ê1¶:¾ÔÀæ‹Æı–AÒ—JôïNJÆ»Ò6\\nê»zqVÆÃóãÓŒ“‡:²YHMK7„Š9ç9)##—Áÿ*áE£–8\\'E×SÅ)CĞ[Ç¥O°ƒí÷ë‘U6ğ8ÃZ8dNm0Æ}ı!¬V\\r¨iT™S“#‚¤óÉ‚i¶\\r~ZV›¹ÀÜó–¬êxD÷F×á€¿ÌV\"6w_INÔËI4JÅÆ0… âjAø²Úuc\\\\ÒÄ.˜¸ªQz¤ïŒk¯ïY¼c4.JÇGÜ@5vÍ_\"DuµÙä {ÕÔuÍä¤AA—’»ê¸O”ÅX¥e2ÚG_*ãˆµ’—Üô.	2!„Ï¬ĞE×¨ã‡>‚»t.‡YQôµ—oYWé–¸¤W´·ÁÔÔ@N}˜7SïÓh…N\\0008è`~ßìÛò*³K2½´,¯“ä…iÓğ”j`E%Ô`y£1ô˜Õ\\r8º¢¿B¾Î‰N”ÄÿVJkEÆ\\nœ!Ÿûˆ~ÿ+ÎQ÷õäz§¨õìøCU÷v( ¬;a}İıŞ½rX¬š?hõ,áÑ@­?#6;«|qäUĞü}K¥¤üª_Å¸ã5Oné8ÛÈä5?>æƒ6#Ô¤æh’«§À ,d×ıeJú(TÒYVA~¤×k½içâÜ°5òô£‡ÁÚZóºi\\'¸nÄ™õ ´Qú\\000\"Ó TFŸŞ¦ˆ¸Õà˜±?t_X³ìtÇÊ\\r¡@f¥8(1ûbÏqãóf¿²Pè÷4×åkp™ó4üò\\000é4r,ı‰Î7Î|Ø^äµhBßí¥o~L?åaÚÓç/ïä526cÃ…Ss¸µ€³ŞT»-}Pœ ñB ìáå¿Å¤ï¾Â›9¾Ç[íü›}g4ñÊ@-Zg”Å-#6Brğ^_‰²ïÄÙWÄÙéš„û‡:ÂüÎ¡çhø(ş]G«òø¾ïk½=+â[ÿ†D{NÏÇÔ§C´*È- Ö·å1¯`“=5jp`™1¸÷+gÓıaO(áb´;ØU5‰,}7è–0æd˜eãñàaÔÀAp‘–|‡~6•­àP°å(Ş‡\\n,^œ6EÂB\\n”°íâ8˜:ö\\ròt^¹èøÂV!óO¤Oæm€Ó1rıIo$}Úşİö…î	ıÒÊ¨ñbº•ºÿ_H^€…ò/jIî®“ªıÒ:9•j.ãÇ³3š­x=ú}O|	xk¯-†Kï¢%T|TÊ|åDOûóSÔAY>§™sÍ¾Äéz˜ñP]êØ7äo¾cœ›f„QÓc–v­CËvÚU¼fµ¼ïğ¹Àª3!°Ëõ?ŒœØW¤yÑ˜±šHó0âXaCf`ÖgÓD¿Í}“2÷%çÌc‘Sˆ¹ÂYq÷-îı ¨´]q$J&‹â›l(ÅáF\\n)7ŒoË=\\na›½c%™}ıR¿ğ¹¨}µ”o‘ÚWÖq\"!ÑkÃ«½‰2‹”Nu–ı„‡ÒT·şäSÙ€ ¡E§µD…Qää@”JU-ıªø:·Åë¯e½Læ¥šZòû¬F2}\\r¸áÔ+>“kŞ‚K¾³ÁçèòÅéµ“zn±\\'|\"Üùè}†ö—Y”+\\'¿áø›vºGò7™ÄçhİÌÙ†è/©UáÇ)É3•€íŸ÷©@Ë–,PCæ–\\rm‚u.ØÙ[‹gl±‘²‚P*\\réÚªSñ²€«96™ñÀyZ© qMRèş¹¤[SNÿ¢j–\\000²LÒ*KÂ\\'2ƒãKCÁÏòp4~{—È© ë©ÏŸ÷İ†\\'Cò–wá6%t~•\\nUÙª½µÑˆŒ)¼@‡5L0¶h{ûâZÀƒ@×7ğ::‡7€wÌWw¶êîöİ4ŞÛoÔ£\"~šã#ä57««ã$Z’k0Y`ñvP,ú×e\\000…\\000é€C‰ùìÖ aëb¨Š\\'ÏÔhÀÍFe°‚	½@AJ§£pù+•Î¯û•:P‹>ÌÑŒtÉÿşEáA¾Œ\\nêx/Ï}Úyü(Ò¢üˆÀ\\n»¼ø‡¼I‰ IN…ÕƒÕ,fIKî€œâÜØUğV#_‚ğæ3ŠÒ*´µ¾ON»z{ĞeV¶ïeÜv~½\"jÌøho‡¢Ud)×zA-×5nh®a`2zà¢ŠT¯i+ÔÌ“½ı?×pÜOTûÛt;O¹Â	xµöt³Â~Ä ÍïPUiEËÑ 05“uZ£l?Z~^€9\\'óÈ»%ÕˆÜqğÜ–¡bõI‘ÚÔÍ“‰PƒO¬¼¢/åLL[gœù_90zo’$Ã.¨…n9½J\"wÆ§÷Æ§÷Æ¤ôF³`^d÷ó¸$¡‰°vëu`;ÇÄháàhK‚Ô`@Â6³_ıÙ·Ê7Ã9˜\\r3pï“Ájù»{#®§şˆv¯vÏz¥…\\nYZ©­Re¬tzıRœpàŠ\\råˆ\\r;s’Ğì³p}%4ÎÀ¥)øC´A:Ua¬]%»6]L¾ÜÔvÆ›îV9oeŸ)^°y¼u¬ÉY«æ›n	İ±Ô~œŠ•4y¶Æ¬`\\\\BŠàÇG	¾iäÜÇ‚çWˆâB¦ênÆ*WbÍºİ¸È-Ï_ã?¡.)åwŞQğìÚHÚÁ‡ğ¨‰ì½›ş«ì—˜ù1mìLÕÌÔØÖ#÷ièYÂd‡ÆÅÍ³Íê™ ö—ìø7«+Aå_2GÒi¿ÛßÇ/÷Uï÷[ùŒÃµ|3±NtÿËGxn”ü™O®œ¢´GÌŸÃÃû…àrA¹)>kÊƒ¿<RŞ€6°îã¬ÖE÷æYduÃG÷éK²¼=íıÂ«S9.\\\\o.ìTÌ/`Ë9õ-ONu[ó/{İ7y´ôF½xV=R_g\\nöäªw\\n@¦D°S˜™°ë¤—Œ7GüN	§Ô[oÿO\\'µ€-¥e½ß×ÒH³5GÕ	ÍÀØŒÀÌ¡lûtEcé€ÚL3«]};mMğçOWGáÆ,#.ÄêÅ^úßé¥1§-b€üsV0öï¬7Íéı˜®4ô\\r-%og%Ë4«\\'5`n¦ğ66Lqß|úZ†rZ†¹ü‹zY	¼37WôPGå¶™üËQ]ëtú©jÚqoRş¯k¢û1¼“°ì’[-6o@W°µšû.P%ãá›Ç¦¶_ãª¿ä‹è£VÌÒrCã\\'!DIb]÷oÁ§ØßVŠÉZp)Ò†´POnÓì‘ËOµ²Ú!Á\"ÿ. *@¾X1­!ÔN‰e j4s©ß\\'èhP†(Éy­ı6ù%-|êX5¸òk\\'PvÇıòVyhÇ®ıÍú6‹(şóíän¦U¿=¼2e…®”Ûô ™ÆšŸ´/26b3¦;¦üõïØœl!²Á17Z˜o†ì7ä[ÏegµÌÖ>‘Ø„R3\\r¹r¹`8±àğ<R–Šï™b©KdáÄŒ€€©bØ°6<“º’52Ë¨añ¶É[„¢éÊC3šˆ7>-ÅÏ-Ú·®w2İ©»¦Ú/,×—_Ù†şcæÙNuEƒ9^a”e³ŠG\\rÌ®q2nMÕ\\'3ÉÜqÎÅ¡ö5mt$şÚ/ç‰Šcjã\\rcß¨N³¼ÆeªÕÃè_SïÀû‚Ğ^¸JìÒàM(„_m¹¹„U´ğe!İ(¨óN=sef/ç<\\000ó3…7ƒéCØ!şUØ	 ¥šİMD‰¾—‡Gj¶¡Œ]ÈÃ¨VÓ‡YÄŞ¼Œ&(0\"‡nU2úíW%@„İˆğV«¸+û4AŠMæÅ¯Éğ\\0008ŸÜ˜â™QäIdîšÅ’n\\rÇ!œïŞÌhÛTd@G±®÷Ô}UjĞª~»fyÍÎ0g«T.rdRßºö	Æ‹\\\\£Ğ#¹m‰ıè¦2‚<KuCÚàNSµÉ˜QÓ4à_òrPVeuHğzÆ	ù¿-Ñ»²a„ÆMşº2{ø0@™ü+kÎ¾—õ]Ê-	m>bÒQlÜ<ªqújZh6®¥Ô~û\"U¸}¦ïfşÛ+ÂG_æ —¤ïï:Â\\'+T-äF.Œ‹ù¸õêÈùÖµÄ{y$|7àµ¡Ó¼0éş¬’¢ô±fCÿ¾Z®|tÅSù$âé<ØıÏÀ7koÚ¾ÃNø|’ÌùÀ€H:ş)úk»8_Šşºø®×ÆlA†ÂE³\"8‰çQÜ-³¢oœµğµèÕ\\rÙÈ`Wï”‡ãŒî/ß\\rİEğ§¾ıVB¥Så”õÃ¼çW¿…¹qVm±$À=„cáô\\\\8œÁ[ ˆŸ®i-)(Ñr4<.¥x¬â_òÄáÛ~\\\\›¤®oëad,¥g@ÔÁd3ÓÂ#xnåsá1«Šqˆg`Dt%Şoô~}½gğ	\\r:b	FPÚş0µ.¹^ˆÈ7:a1ßŞTİùùTÏ«½‘~ª÷gT–NÅÕ”álÊ²CØî âª½\"Ùˆj+\\nG}. IÙ<Næö6$§:¸å;ÍLéæ.6Š§v¡«L+ K?Å0ÒÇz*¼ú\\\\ÎyNgæ\\n©ˆt¼ğÂš|$ :Ğ«jâN6Híº;ÈƒŸÀ´ÕTø¯XÈû¾E–›¤5¡lÀåÉq¢´%9j¥ó”ô·Mq1dÉEzP†dò¢ØÓ²´ÇYPí\\000»Ô-°ñ%Q7yòõÜÊ‘Êóäø„ı|-wï¯ñæŸ3•Ø)ä’Şt\"Êõh5ÄÖ™	%UKVËÀ5\\'ên³4À{eÒ_\\\\@J›Ò.G²¶Ô¢áÇ­ª\\'—>›4\\n”íMÂÆ‹ÍJM¿m¹è=i&…ëdå.B	Tp!zŒºıñÕÚ¬}­ÌŸ‰zà ÕKyƒ&el¿pT³×»Óò	@§d€I)hÉİ6èB½ĞÄ0Åœ¹dÅ,°ö‡ÌR%\\'c^4»ÖA! <\\\\Şpàé:)†9”ÂF‘êÑ‚ù<¶”ª,øáææhb†%óïY†dÌ1¨<£ß \\rÏÁÿ\\000ö§‡\\000q@ÑÈÇ4@xüg&†OÑ|)x+Ç÷½qÓ…»ln¿âú‰i&²/¦=.µ/¾QŒÏã æ¨ã ôBj]ªÂ˜ÍèËv¬ƒP0=ê­(%ág¿ƒ<~‘îÒ5m“f­¿şDa‡L½Ä†Ó!\\000/]@\\000îeÑ©ll|[¥Ü\\rm…ù!®º‡ `S²ÖUŸ.ÁTp‡ŸÖP¦KÅ[H(Îƒñ¹ÆâØèJœ*?ç9¿nŸ„—’[õ®D\\'1qBHº”.\\000•PgaÇ‹µlbÄÇƒwšì•­£“*í[±@ø2(.àizOmêı\\r™Ë~åîP¡\\000ÛüË¼B÷a\\r~Ä÷[s©BƒÇ7÷î íÅbe/‚ÀwŠ\\'#ó\"!9bGË›OšĞ<Š‰±\\r¢6@Ç.(ÒjÆƒks§[rçÚ¢î“êçB<u“5§‚3G1`Ê¨iÜ‰¡”ÈeÃuÎ¶Iñ»t®H$v!ì¹¯ı‡İPc¦Fâ¦¾£h@÷W^>ğÉ&˜\\'\\nãÄî¯ªx·[†<û*òáäà®ä.šùÙşÔvTGwÄcÕfÀù»›ëÌĞıê \\n¶Å{Ò›¿èælEÊÌšudİaj£µr¾otÖñZp6ğ·pÍ¨ÂƒíƒeôÂÚ—E€·)ƒÀıuE(ƒl¤2§Eê28–ŠÅŞ{Ç\\'vU”_/_ñ8B=rD!\"·†Ä~oÄ¡óGpF{$t¶|Ğ_L’XşáUùUÏ·”È•ò_‡lœX¨æ[vÆ/™÷H:z<¡¬lş´äŒk©=„&GF•#Ê–,cL­zHÚˆğâÄ¤m@K†Ô¡â b¬MS\\r»„?0tÑŸÙsá-qŠ¦oIU\\rªs3B6´yk!ƒ÷@Ô,ìùt1ÿ™„v7-’¼%n<ù]-\\rÁu±¶ã+@£¯¯]PP…\\nÂ…¿ïô\\rü^€³NÏcQRßá¹”EFÅ’;ï;	Hß5›}ÁÿáGŠ·¨÷šßç2Æ™³Océ<ô’t»k±#[÷ÛËXá*èÍù¸GÛ2:èÏ›ËW{â¿5u›»NâÆ•4ßèÓ~ÃN×Y¿Û4ªÁM³¡Ïš<ô‘^ÏÌn>B3m×\\\\Z›rÒk|¨qb/Å³ÖtÖ+`É{f‹”³ Zı)HJXt&Ü«@<náê4(Hg´ eÚ•µ”K¢9½¦sîÿÖ;a3³®[¤$ìC&¿uH¦|ôŠa)N®`¬çK$÷şx½ç×Ú[è}S(\\rü»-÷ÀÁg\\']~à\\000É¨ÑÄı[ë@±còÙkœî{¿Ç~—]ĞÅ+IØY}eUCü}@ÀâÖF„rh“ƒYöóù»şGÒ@DN²f0¢š…¿rè+èË¶6>¹“-#wdròúÕöT`øœÔÛÏ¿Ì<Ü¤½(Ğè!¤•²ÃúËz6”¿¼«;Ö³_kr¬CBÍyë‘Ë®)@9¯×Âë<(¡´?	\\'™x•êA_Şaiÿd”w]aŠ“µ\\n×GÓøt…{U)mŞ¯Ør6Ã¿…l/0q—!ÎÏ†òùlc™”ª  Ä‰Ğfcï~¼iZ¡A_Æ\\rC°‹†e’Ğ4p«‡êğ½`k±ˆB\\'…#ÛMÿm¾zÑ±ØC°£Ø×îSm§\\riZ%,Ã\\r`ñÖ]ôŒÃUèä9´Á´ĞÎhÙıfİBPß²Ûä¼Iõ4e½Á\\\\Œt5ŠÍ3¤@\\rBR±\\\\½2Ìq“Á•=FtËó	†©;k€T¨#ª™® ·ám;«ş-Î¡şÅI)Ë×™ª´7åLéDš~«Xoñ-(¬ÿ—H“éSöÏtŞµÈ ƒƒ`ìV1ŠüĞ$z:¬;hãÿÕÔbK%*~ñ»Fâw}ôM¥¼Ğw)„¢Ğ;<˜H‹ ºõjº[ä¤s¤ókß–×ù{y‚Hä\"Ğ>‹•BŞªœƒŸn#hğkW m¬Œœ•ÑÒnQ‘hòa¨Ä§ã|\\\\‰Ô!æø‘¸H+—/ Ú3Mœ,ß‘wëbì—~/>=APˆÏÎl‚cQXGä$sâÍ£cúºbï‚ö¿â²p³MsB:³Q*ÎÈÔPÇ“NÌWÑ1¾p9ô+±¡ °ÚsäªïÁxXƒ¤›³™ÍŞë_êJ¬pÄ¹æ½Ğ9o‡[\\\\DƒCí‚Ü<]¼ÚpôùÃÓ50ŞQ€Y\\\\×Šµ·GËè<®D`Ò¶Ç\";Ë×ìsÁqöËEƒ\\nË†÷ĞMe¬ê2›#Õ‡^J¡6lƒ[Pò\\000s%h™;\\nŒ˜W)³ÔÃaFööÓPáIíâòˆó¦ö<\\n·V;k|ÎTf^­’Q†d3¶órNN\\'aš}’ãgÓûG—\\rëÅ²œZ	—Ç¦\\nQZ+ŒU\\'V=÷r§¸³§?ÔoÔ»\\000Hì §™ê\\'´w`¥Ö°5èí)àó ¹º·YÂm~×ƒ.ô’hò/Û¹ÅÚ¢¹¡fm]2×e³õƒ\"İbˆêïÂ\\n˜nH”ôš™Ó0Òİ=¨af›9Lˆ?Şby‡®WÅä@·õ\\000%&Rja”¥·M&±^v‚ü¬@í@ÙJ‡Î¿ïÔdÑ{1­±yI.Ìƒ©îÎ!T«¶ ½ml·La¬¸¤‘ÎL³Hô,UtVĞ[2/bíôÜËå]×Áé—Eù3\\\\ª yv°“¿ˆNO°[,Š¾+†¹‰.ĞŒôŒHÈ«5ä	·Pâ¶²âE–“áwÍ4:¡Ûâ¾·ˆízJÊŒ÷“¬JÓ’CÁ¢IXÿ^°\\000w‹—N\\\\Oí@~^`iVÃÌ¸QÏş7²šÉó¿Ã~PœÔ“›î-’úÀ±7¼l©s\\\\*Õ2MAbWmİòaıÅÚ\\000[ş*\"ìÕ	úİ?…lªæ5:5b¬ÔZÆ³±¢k\\000à©oŞY6tóu’Ãm\\nIéSJÑ õşòŒ+;Å´KÂFyn€aõ)à‚Ç±İğ}ş_zFh†vè\\râ$z®§àuÄäÜıİ‰Š±ƒÏÀ4ŠWÕ,Æ÷ÖÕÃPÂºŞÌ7ÖÂ”4+ÊÈĞˆ•Rl#ÑÜî%a|2yûÈ®ø„\\n>\\'Ïâ÷ü¯,ÅP­4ïr9‘¥tzq-ì€GüB›„„`vâçV€~#\\rÜP¬¡ÎºÔa<h%êíğRÑ¼J.†çyÄ=+cQc¢[şú´#Å:43¯~çÎ×áaUrÈ^ˆÜâY/®,C¶æì­)9Å‚V@,må¤Ë\\nb\\'µü8¿@òs5“Ÿ½ÓàÏWàiòú¬’~Y~²Uı%üÁÔ£a7™øèÿùL^Dô=‡ÉU ZØÑrrÚ.h— 	ö(”òul•IúcjÏ¶Çq„DöÙ¦düo>ÅñO_1P î²;Š@Hˆ´·uãMÚ5Fë>0ršQòkúD`§ÖYËeå)î!ç}¸Ã±]iÄZüG½gê]Gà/Úîø/›j)Lê³aİl\"q@‚J&[‘M­!‚øE½5Y†Éâ£z37N_²•C,yÆÕO–èšÆWÌÂ„7¬±¼t`$¶#fTg]0/-/¿A[å~å¸ºÿ%¨xıO!×Î!È†¢Âˆb¤.ç·$Jä²uuZ7 Â\"jR(T ¸^NæIŸÔ‡®Ÿ°‡QôQU¤j™YTWÁ€2à‹÷a9’AhOóåê4f~o[+OÑ”³RhSşÎÎŠ‹ÄŞÖlD†Û†FgˆòÂ9ˆÈ0ù×Ûş÷ØT¶¢÷c2”´Ä¢,äÌ¦ğÁgjwåÛÓ)HÑ‡æ(Qè?B9µĞ Ê±@£¥µ[l¥ÚfNŠ}œ¦O\\000ûœÄØSªï—ÚtîğÄğŸ®\\rÎ/\\'ØïÔ3E ^ğ€³¼$=µl£ç–FÌ‰]BşÍkºËŠ*¹’&“ëh}7¬:î j’üƒûíJæ™Ğyµ†TÓ6sRß@ì›[BÌÖtÆT„9ïÑ<\\rH1d¤&ôJH>†5«QSs³`ºy¾^‘kÀ’£æåæ5Xœ¥Å\\000Ôğ3{Œ	êZ¤YÁ:+Í¡u\\n\"ÂY\\'!»—’bÕyv½n”¹‹ÔÒ‹]úòÎ\\000Ø¹ “9²ÔNDâ‡GU`Ë+<z¸ıè¾/~˜\\\\ñ¾KØedçXÃş\\000³á±¢:Û«aïşóM#Œé”( ìêïK¥s!f[Ğƒkõù½d)<±m`y¬hë;îSh+Û@ÓE¯”%4ÏEÖ¡¤å×p 6#ŒúÆ»ó»2»ñÆZB`wAJú0Ò,£7~ºÇ?n»â:¹“èm›½şàJÃÂËàß ËGRZ|ÉYy;p_?/‰ÊQc4+¥×c|m>Œ]´fÃ3¹Ä¬„ÏXnx	Ú•—)¸? îºã™\"A½(•n!pÆo×Ï	ğ›™ÎÁ{¾İT^½ã<•öä©¨J±æÍ‹Ê¦ò.ù´–«¯ä^ì#{jöOÏv¥ªÄ6êK kı\\rRP9ÃfGFa`$4İ†œUÎhóú{Úù^xÑ]ˆWƒRPéÖŠ…û½œ¿¿ÜyA‰³ 9ñFÓ¦›¹£ºŠ/İŸ½~ ×ë{îªW·ŒRŞµŞM¢¤ÌBaŞ3™®†û\"ğ\\'wŠ;WD––©Šê¯#I4NÔëÑªKPKiƒ^G!Ğ£¤ç~7Øš\\rBë.óv¬¯uf’sí§\\n­9H&*rİV qBu•}ƒM„Î’@xéX¤°¦àÁzGöÂ¡å-N©—b@è`g„ÇgŠ{ùÇ;pŠ×ñà¬“–ŸÔ&ChÔ¸MÑ:C7Úxğ8cüSmªË;Ûf—¥guÎ²‚|Åië÷‡JÏ}ğıg %`?ƒjÍùìñJDŞ#óYf–ÜÆ×šåTŠe ÄÃËêñl´ZÇÈ®Ü¹lÒóY9‹”8¾»ã€Æ£º¯ùÎU¾uìdAOú[eÌœ=rJÊ®¼xKmü(5awmhoeFÈß	§¤©…ŞäõJÅ®zKŞ’»ó…\\r•G¶LéÇO½SuğJQæôp,¹âä$Ê¾\\\\,ˆš†\\rŒí‚á(–t˜2¡Ğpaøœ»ò·Dv%PPÀê´1m¬^k\"B+I›ßÉ;§UÁÆW—&oûx…$4÷39ìuÜ’%jlğä™V¤º;Î¸P,­ğ.şFÒÿÎqD;¡îŞäJ¼ı9*wR$­ã‘ãœùh7îÉöºÙvëÇ7@ı£êª\"™&Êà‘³èIX m\\\\4Ÿg¹Ò¸óé¦Ú¥KSG½Ü$²²ö-BšÁB Î“ñsg¤ˆ~İ˜56wáÒ£µÎšş\\'½Jîì‰enz\\\\\\\\gêÆq†·Î¯¬¾s:%u]fÊş|$Vö3Gæ´¤§ôâÑ\\'Ã\\r?‚ñ]Î¶-ö[29)Msø”ByaÈóträHíîJÌ~Ï¤.Áñ¨PÓ+:$2>íÙßnJV² ÁŠœs†‡ø½ˆxOÇÃŒâŠ<CçXxéş²#W{½Æ	‡ö,0îø‹õU™IÖë(uyÎé4ØËw`Y¶á‚áıƒ·Ç6]\"Sıc“¨=ò\"#[Õp]¥¼–«Ñ9F_}¤kÍp™ÙáX\\'®Ÿ³õ¹Là>	_Ñg1ÚŒ\\000Q!B?a–?Æ0Ï&kî–f¯‚^KC·CkVİÕ†ŸÀĞë<!ªëëw¶\\'Ö·â0’&>–úZ÷ÿåI<(©×èÄ\\'çû„¨\\000[pm”†Ü87i\\\\÷UÈ¤,\\0003{»“ÏRâäåúu2?Û0øÙ½ıÅyLHèhªS€æ©úd§º=,Ÿa!àA¹ÇW/å|Š9\\000S)®ÏĞôwU-’Š¹*×ûÿÖ¾½$³=¯âêøLôñ½‡ı‹‘ä‘Hùhµ™#ù/{İa|F¯nfw2ŒÜ§Ó+\\000¡€/ø/óĞXMüú\\0000Şv(d·nwÇ‘¨\\'fö… 8&iÌkŒŸ…ÿ/ÀŠ‡\\'QËû³.|€e#ÃÇ‰œ\\000wC±İ¨6¦ıi»¥ms0C™7IÉDAŸ1Œ…l]|.¬TC°—‰öKæ?3„<¦”]±8á$^—±# Ïuh#›/Ÿ4l¸Vs9¿dæ ë,<Y\\000§vñD{àâ–TßB>Ún[[´2D	?îsĞ„zvK;˜à•ù¼<ü‚[›YÏ@tï}ÿ?%º÷º,“7O}â4S·N¨’+£ò;OLÄÍÌoaæ¹eßoDµuÏÒúRCÛ0\\\\óôå/‚ÂûmÜHÿ¯Ö;¤§\\r`šwBoCÚ.gî€ÂeG«²˜QÃ™ê/Ÿ9°ñ¤ÁG©Ài¢;¨Z\"8WrN¨aæ)ŠZ€Â8$É‰í[Œ²d¿i©)I%íZz³a ÌÓAéëSñÀ<†NÒ‚şá|tsÚIÃ¾’ˆµ7·r+MXø%a©ZúµÓB[Â@”\\'YJœuP¶6u«+Á(ap‰ÇÒÁ÷¾?mª şî5<Â[ÆÊzÚjı‡¶‹IÚš`N÷‘İ#\\'z§Ø\\000ÿÛhVjµEª—‡İ’áÀb\\'?­ÙoìˆŞ,ğç;\\r–¬9{ÿo²ÀH£ŞÉ“\\r­½L†ÛGÖ÷>ÙA\\\\&¤,¢”N“hDX\\000Om¿¯‚ª»Wn0+Ÿ¬¿ŸßÁ\\000ñgÓÀuç†ÂÓ¹úyóşS_^òxtmÖ©ãx6x‘¥îı@£‹ÌDg°”³:2¶t@\"F0P÷‰>•~1ã¢ï’TP™˜ŠÂ’Ô”qvÆ’UO“âôŞ˜2ƒxüâBÎÀ\\\\`EâÅîM„kêXö7;ôƒ¾±Ç˜ëüÇ6Ÿs»ºCHÈ+Üû“%lˆÌ)>›¶/óª>g·X8‘\\r\\nÁFÔsZÊËdŒõuCŒÑUÈ\\\\Iv§á:ˆK9§Y±Nd}!Fí&îsv•¥J0c8YGQÏÛÅA@¨oUãÃ\\'·ÁuÌ\\n92Ù¥ÅğfªóïÛNùîÕÊÍŸw…rìı¤J]>ıŠ>ÛSşóOî9\\rÔ†¿>#ŸpcÖâ\\rX¬¤Û¶ËÑ °¤«xë¨û¤	Ø 8™WúiÂš¾¹LÒİcÅ5Ñ¤¿»¨õs±’•¸è¡šäQÔ1\\\\Ğ‘Ë·0%¬šå¤hØª‡N(ÄÍø»%¯mÖä\\000~Î†UŞÛPgI¦ÙX¨ˆ¥]0EyW’2†nä-ò1Ğ\"fw…g+ŞŸ•7M5#nÙ<iÑssg.v*„úšo`Àœß\\000Ç«Ë{£K©D@E¶}èİ…ÊX¨D!\\\\ÑC7£¼où\\rĞ;çv%Cã…¨‡{›jZ] ¿f2ªÒaCŒX	©Ñöt4È©‘·ˆ<ô6Âœ›Ş¡Ï«L)€È…3Ä_Éãu³§°Á€ö¦[¹hŒ„Ù1É‘!™(]s´ø=	æÏ0İp¶dJƒ*\"~pOó}J8´FÎ-M)Ü1dZ¸{şd|Ú÷¨&¢Bg;q,Ÿ˜p*”ó&¥5zËZ‹ú!xbXpäÚr†Şx\\000O™Y|@HÛ`À&saÖeäÁoFv, …lèâ@Zr!’|ä;$z;Ãƒ@—¢¨ÚŒºÌhQGËË^ÛØ¦C“ßgUŸv¿yûp•uMrµ|jEÉ»Q™óM „>ğ!ÁÛ,ñF>Æ¯ˆ}x[@ºEŞ’\\\\j¨Ô´ÛmpnOùìyRåÚ¿y‚k¡ak¬X¦ähÇÄÈDxwxmædõx¼İ;!£åh+ÿÇZ}ÙOŸ®»\\000qÏ(­Sø<<zÃqp¤¹\\000#\\000P\\rë™ÿş|+Ò±\\\\±ûÖy¯†(J=HŒPî‡FÁú0\\'Dpn.¨És‘®)¼³ŒFí‘VW/èímâHjV‚Iw?ÂT \\nV:D{äI¦Í¤ƒÒö‚˜Ã|8¯G+#Ìóì¹õ‡µ?5!³<çi†7¢ÿiFõ…\\'Åu—\\nöÚI³€\\'Šuq#i˜ÇPtZ¹X5|pXU‘2ÒËïSN5èÂ8¢aß¤s‰³µ„DÄiB›Ó•íz¹!N¤ş»ŒqO’[íäüR®\\000°¸É ³!”Òo{Ô•`àÜoRÔ³Ûûü´­ÖˆTQŠç~©ù$]µÿ§~!¦GÕsÆÚ–KüeE©NšP ~	¤!Êj°[UäãßÌ~\"ƒœ¼bÎO@  ]\\\\W2ºO´€%ÒB³¦Ä¼1Æ1œ8|7;,ôS¢¡ÍÁÔ¥eY=ò›‡ZR³¢ÚW¤×ñfñ…ú…YdDÆ²ƒg(}¬DPáÂ&-ˆµÊ„uÔ“-GÖÒ;ÜlÀÛM2÷‚)C‹¼)1—,a§M\"“~d*GŞ”úËé™‘—¶cZ]´!ÖÄs9áì‚«±†½lË:W:¸F²É=m9Jèã3V3y^±&s½¡ÚÄâˆ˜lÏÉĞléIiˆ\\n±D x44Â7ŸiPüTõî-À³­{ä\"~G-;g¿êl92Ëõ,ù‹C‘üË¤ŞˆıUß11Óé@ÊÒ\\\\„',11070 if\"ä\"~=\"\\xE4\"then local a=assert(fs.open(shell.getRunningProgram(),\"rb\"))local b=a.readAll()a.close()return assert(load(b,\"@\"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error(\"File corrupted (expected \"..size..\", got \"..#disk..\")\")end;local c=require\"cc.expect\"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),\"\"repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,\"invalid chunk\")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error(\"invalid chunk\")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch(\"[^/]+\")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)==\"table\"and\"\"or O elseif type(O)~=\"table\"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match(\"^\"..aj:gsub(\"([%%%.])\",\"%%%1\"):gsub(\"%*\",\"%.%*\")..\"$\")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or\"\"if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)==\"string\"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak..\"/\"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if type(ad)~=\"table\"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch(\"[^/]+\")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)return type(ad)==\"table\"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,\"string\")if ac(disk,ae)~=nil then return\"mem\"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)==\"table\"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,\"string\")c(2,ao,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao==\"r\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local ap=ad;ad=\"\"for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and\"?\"or string.char(a7))end;ad=ad:gsub(\"\\r\\n\",\"\\n\")local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;c(1,au,\"number\",\"nil\")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end}elseif ao==\"w\"or ao==\"a\"then return nil,\"Permission denied\"elseif ao==\"rb\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,\"number\",\"nil\")if aq then error(\"file is already closed\",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end,seek=function(av,aw)if aq then error(\"file is already closed\",2)end;c(1,av,\"string\",\"nil\")c(2,aw,\"number\",\"nil\")av=av or\"cur\"aw=aw or 0;if av==\"set\"then A=aw+1 elseif av==\"cur\"then A=A+aw elseif av==\"end\"then A=#ad-aw else error(\"bad argument #1 (invalid option \"..av..\")\",2)end;return A end}elseif ao==\"wb\"or ao==\"ab\"then return nil,\"Permission denied\"else return nil,\"Invalid mode\"end end,find=function(ax)c(1,ax,\"string\")local ag={}for M in ax:gmatch(\"[^/]+\")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)==\"table\"and 0 or#ad,isDir=type(ad)==\"table\",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,\"/init.lua\")_G.fs=fs;if not ay then printError(az)end\
" local name = 'Files' local desc = 'Manager_for_your_apps' term.setTextColor(colors.black)term.setBackgroundColor(colors.white)term.clear()local function a(b,c,d,e)local g,h=term.getSize()local i=math.floor((g-#b)/2)+1;for j,k in pairs(c)do term.setTextColor(k.color)term.setBackgroundColor(e)term.setCursorPos(i,d)term.write(k.text)i=i+#k.text end end;a("App installer",{{text="App installer",color=colors.gray}},2,colors.white)term.setCursorPos(1,3)term.write("-----------------------------------")term.setCursorPos(2,5)term.write("Name: ")print("")print(name)term.setCursorPos(2,8)term.write("Description: ")print("")print(desc)print(" ")print(" ")print(" ")print("Enter to setup, BACK to cancel...")local l,m,n=os.pullEvent("key")if m==keys.enter then local o=name;f=fs.open("appData/"..o.."/app","wb")f.write(app)f.close()f=fs.open("appData/"..o.."/data","w")f.write(textutils.serialise({name,o}))f.close()print("Done!")else term.clear()end
-- End of File: .cbuffer/Files.app

-- File: appData/FileManager/app
local disk,size='Øï2œ¯:hˆ_…¯ªâ°½öÆÙ¼ğlÇ‹\nï7*ìÿ!+a²Aû`ø{9÷_+µqBNøA*ªÈkòI=«yÎmŒ ¦0‚½Znóó+è7=vÑ‘‚N4T˜È¬¤Ù±Ö{rãq‹ÆÕ+=7’€»¶œZLušKˆ@»•£$y…èóêiò;‚2e¬b›ôg¤­-@Ò\000 !X\\…ã³‚® ûv™ó‡2"Ì]¹W41ç¨1rãn…±ÅY•W]õÒ¯·Ñ¤zùJDZRà¸¤\rşHF»U0ø—ï–Rªª$Ø³|¬Ñ9KÔ&ù‹¥ëZ2Î«şˆØÀ‰T¥2=w—EnF™Xj”ê]o\nR\000!Ö¶0ˆÖ–ÄÕïØÛYÊ¾}âuk€“-Í83…rq«¡öld!ã18øœÃ\r:ã<r\'|»4/¯u=ª÷”âŠzG8P©¥¿#‚™pÚ³ÍÎ\rÃÿV…Iğó¢°ÏuÄ¬{¨0N5…¥ÒÙdÖşÔÙj_ªñÇ4ƒÖv)¯SÈ·íÙJıëıJ‘À2ÍKDWÍiÒMò}¥€–çf‚Ş‹»–ò[\nwnªa³Lƒá¸Û½MñIE\r$JFÕÁ;	ÔiÇ*ÿÃ\'zl„	¥îvá©œ”=%v4†_ù=Ív,â,?`xÕë>—®N­dêš31ïTs®uìFìŸõJ¢Šv=êÁD×SÅ)‹CĞBÑl¬¬ÃííÑ‘U6ğ8a»\000‹\r°2#6˜1H5‘åaÚ†ÕIÚrlcZ‘h&’¾J9ØÕ¤@.C„¾7:¦%ª±<=l*(€ÿ¼#Í÷EIL±Ih±‹Œ1°)\nAŞjAÖ²÷(¦¹™÷8èşÓ”±!Ç¾ønÁf‘8Lè_ÇpşÉ|ˆ‘æ×a1¡]ğ (ç›Ë‚ƒ%xj°_tÉX¥evJGC~ã¬µ“ğ<TÉc9!ƒÏŒòD4có6_èHÎ¢£koY‹i†¬Å´²ÒÔ@H\000}š47WïÓğ‡)H\000ã8wô03oƒömÉ]ÒÃÌ«m‹»å(BºÍø„TÂ\000×YÌ\r°x~QğÓ”ª+Pvv~$lM;Uå8üiÙ<N•˜*RÏÜğó—¡^o¿ÓLwjvNÈù$5 7cb	r4–P:ŞP*êW"µÀËî‘LÇqŸ’QG]fŒ¼‰LÉ t‘÷•¸£UZ%İÛ~šÚüú1œÎ3e°-NÆ‰]ìì\n\r\rôd5¯èª«Êùˆ‚6	5ÊïY§ù°¶ì\000Ù|ï¡ñö‚˜|î4ÉïÛ¤&pH-~œ°Hİ§õ\000êb.¼ò©»D‹ì–}˜ºb‚èWN!‚ÃÈ?ıŞ¬Ól¿³°ë[•r±¸AüÉ~yÀÔš(R~ˆDŸì|¶Ij‘<?ÖÊŞÜ–%ÊÁ5¾	İ_ß¡É.(ddÆ>gá¸›şSXä‰åØ?Åÿ” å/Š±<~-5}öÔÙõö13?oÙvy8	Ç=\000°	wôŒ	Ë™y&Ëd‡fÿ¦ì«ˆKó ,7‡ŸIúUxùs¯³âà½®^ô«In_\rxˆàŸŒ¨$}‚8È ´VƒYßšÆ¾„›sV€:ØªT\000¶|?Æê6V{¦´Å„¦ú’Â¬¶²Mrñ¸xì	²‚ÒÀ ¦PËg>ó¿JÖü(Dr•o\nÂ…¾œERBqJQìâ1‰»Şä½{Ñ„¸CÆŸ·ÿÆ ¤¢åà’ÊHãÚÊİ÷ÊÇ·\nÕÓ¥WŠæj•µ’^e…õJuIâ®ÃªÒ÷[”µ—y…÷Ù…ÍP‚@2ù>§Á¾ä¼×J–Í%ú"eT}H-S•?ßëÌ7ÈÙá<Èëè%ô\'KØÀÇâ‚ï>Á¿c}ùœä!¶18EÊk#µiò[îÒıà´²yµ¨À3ı‡‹ÎÑ™†_¹üæÁ½#ˆÆ<ÅŒbFÙ‡Ã\n3µ>˜%şpì‘—¸Á/=c¡1EÎËowÒE ¿ë‰RÉRiŠ›a6/\n°RLé°cq,õi†hõŒe÷éJÿ¼æ¡öQ¾_i_šyÂÄˆ0D	¯\r.ö!Ê..Q8[÷:Ru\\ßûaOf ‚Gjzš¥:…D,S—<U¡E½\rTW÷´ÖÕ\nßÒMQÅg3,Ò“øãWb±“ímÆ~¾¡I\\›XTÅ¥±ƒ?EV<9­¦« ;äëOIì6´šÍ‘Yğæ\'„Ú„Ò;Ng\r	"#ÈV¢®¥W‚“$ËÖÎ¾¤ÎX°°ÁCû84AN	D»fej9œ-à†<J\000¦9-z\n¡OÂÊ>læºoc†âåS â˜¤ÏıKHŒ=,ıûÇG<ñ,Ád	¤`—„/<]ÇV…B\rùæì20àhµöW¨ª¿õ„çíûîCùL»ğœ’º4ÊÀŸêì­^Ú´DFŞ\000C‘¦;4=ëñ¨àA¥D{øH›À/æ+¯Ûuuûnš?mÁÑêP1?Nq‘rm\\êïGù€É5è,\000VŞ‘ÖQE úÖeÀ­\000ÀÀ#DüÖkğ0ú÷ÙøED“Çê$bëãÇØ+8Ş¿ Ê§ñÌ@ÿñ­ÏÈIJ:[>àÑˆt†ÉÒ·wEûAvÙ@_<g¾NŒa0şÒ:ÅÑk" …®ïŞ*}N~äå?ıç5od¥Œ½)1S“ñÖ,k÷*¾¡Ù˜7z¬ší[2Î{HZÈ•Ò{‚5§]`Ø_aöH{éOÓ›üxŸn‰Şœu¬–uGK[1*ğòC¬Üˆ¹;@kÚ$¨$•ÇfE/E{³Ònì 1í—&1¢†~ö=“«EñÙM÷,¬¢¤k—O˜k­‘6ÌPhËü&¾‡ê”ÓñRÍSJ–D§¥î)*$Åó“Q¶i›ô‚ Â£Òˆ\r•=ñ•BÅ$éÎA€Y<º}”g˜›ëè¿Ş¿Ş¿ä1áxÏÎX’Ü&ğòˆã}±Ï ÛÖÂ\r„æª[°Ÿ”fpŒPæÕRsû RöhÏÔĞíÖÙÔs1–Slåi¢ù“\000I¬ÁQÛ„Å·XEh2y‹(.g&QékCf1é|G{ÔùV\000Eæ»°é5ñ-ÌglÏ~äS¢ñ­›\rÒÚÎm´>lì@¢›\000ë4¬«I;lÀrM,šY¬L4®&u4›øªÌy—wU{¦ê°uÉxyS?ÆuØˆ~êFÒ{cÂÉıúO(¦ñ\'ÏşÅë0tœ9+HÇúö™øKÿ²ràJÂ9cbç§õÂ.1¼îÕ`µIœ-«foÅ4˜ NÖú°+	\rAã#5€RfƒÛÇ×Èû®èûªşÇÚ“™¹?Cå³€7òLï/˜g7aCCˆ´‡ø~H¨òÉ’óÕò£WgåW]««r\rçl&8éß‘r©”yÊãÁúPòì¹]+DnónKT×Ë¾bU2HØ1Üš–fç=±ù¯î¤Ú;CSŒ+]^_<œáä¨ÜŠTF#°\r²œÜí:š„—GÖD¤ÖÅ¹å+Ÿ#? Q\rî[”&g×şH±¶é”+	ƒÀÅéyë¡èÕ&\'—Ì/‹`ÑÛI9kéqY?â»GÃHœì©ßC¢Ä­D<çMÈƒÎJÈâ"7h‚ş$\000ØşKSé½Î£îsŠXĞªèïN!O«zÊŸôNŸyö¾P¾oıÍƒ¾xZ­:ÎÎ˜ôf@^êé÷—x#½ì[)ÃñçÅß7¬Ç‡¨iU¦·³pöÈ¨—X¸ÉµØ×Ì¯AĞ$µdÎ•5’9Õ[˜\000uÒEš³kêŒ:¹Pƒ]SB»Fl¾À²V5à˜¬FÎ@èÛ7Ø£ÖjöSÏDšIâJ>£ÙÒXM%1c½ûe#°ËÿÀ³•M´k¦\ré•j÷*·óø‚>Ş§ê.{6«Ug:ôËŠ)PöVy«)¯oÇÏoˆk¿&z:¤eçs÷ \000ŒÀ˜ˆñ›Æ‡Ißq}ü†í™ ¡ F3ïT q³Æé‚ïÛívu\000÷¨vAäŒùÃqœÎÀ ,~6*†Ã±^°ÓüUCl=*˜‡&€\000ÆÇ”¡h#R¬ºÊ‹œ<Ñ«|‡ğmiÚB&Lmğ¯¼²zöå…XUg7 ª¤E\\ú<:©¯O$ª´0£ïÓ”-3|SãB°ï÷}ÍÀÜcß;<ä@Ø7&@Ëdü‘ş	l\'61¬Kö›ê¤S"P	üEò\rj`‚w€¯ÿJ_ÊbÊò1Ñ"­&Vre§İH›«óe<}Vy~¥Èîznÿ,‹¾›;K\\âfúºÃ¸Òği<áLİ; sz¤^Û‹¬Ú]€6¼&]òÁpn\r	óáµª!¼ 4™@<&joÍµ*cïÙi6 ÛDcÜ²y}†#!D8Nƒ©/ºnÚpC°öAİ~«=˜cò`µ·“šÇgˆ-ûÛ¶=’õ1•fú4N.Åüé¹Óáâ2<T´\nã‡Òõ\\ÀÕŞ§YíÉ¦U)¶„¦RªGroÌÁsÙ”EI]DYß¢äÉ«+°›çQş6½Ù5¸À>5/ÇAÕhPHû£aQaw¸¢Æ(A•¤pqÁËÑ¹üæs§‘®x&F—óém_GV·i’BŞ¥&€".±&ák/ƒ+Ğúò,°oÌĞ„Ì± à2@üt}Ügö“î#½´ı´¤Ûø)O<-QşU³“jÅ¨>ƒD{‘ÃĞÔ·sƒK_ÔÑ¬+–ÀrÇŒ£_{)x›8FTı\000Ùú"CÏa]ò+öò*Ïy.+÷â…NğŸ§kü>iG\\y)ì†GÇBO%óä!(ÿÿüôùøM›oÑ»CÕ#ÜÃñëş–Ïf›ueíòt²ŠU¸-3îéËáe‹²İ•úXå:²&¶/¡ÂÅİû•æòn˜Wc8ÙğgÁƒ»†…xĞLQr€¸‹æÙÔ’ †“,:åp´h•›í¸º/1‚ø‚¿ì”øıiEŞ1›ß k¦@Ùÿ¾@ØÄ‚.*àœËÂ\rà=;ûÕ-óŠ=½‰\';Rğî¡Tõ\000JQ=h¤ö_h”ÖÑê¶ò4Pq/ˆd\nNñ²6„“¡Ù/O™ÔëK¥»ã¨Èd\'£8vnXSáY1`\nq¨OùTthŞïô~{ğ·Ä$‹î«	SŞ~£•EM¦ç£:\n•È\'®Öê\'R6£Öş…—ë»§,¾‡+9Ç”gU¡OˆiSİV£×»pÜû–?ô¼İ4’OR$Ù~6ĞRmÉO{Ï&¬÷ŸR‡7£ûÌFc¦E4òØäŒLXš®¾Òãœ³Ò/úB#ğ|à½}âøïÃÀµ°vUmbgÛ¤ıã2|OäéçY|šÃBpd­şCıu°³ºõíA`ÅÃ¦ŞqÓÀß`ÄM*ÊÉŞÅ²Ş‚ø‰‹qMÇE„âö–*?îLåF2kZ’tÆ7V;ØòÙÁÂŸ6_õ9uú¿j¥]î¼MÔ¨ı\'­ézG\n[E¶‰çĞö”]•.e®í6Òä—¥élSÆ½[ÎélW\\ûİ”[ÑZsÓ¯İŠ¸î­ñ‘5®\rÄŒ··`SüØ¹ìƒ@N-;Q?tØÏ”MDø5G«Â—Ùv{z;&{Ìøï0ñ¶Êà-.ÈTéLJ¨#ş\'ög²ËjFZvëh‚EîËÌŞÃÅ"±(d˜°;Jf²o)2²\\¢uD¡†yÁ@€Êa@È#HãIwíBÆ¥e$ˆ>Û\000V¦SyĞ‡…®{c‚Œ;Æ|GgL*.ôèËs„DµñÖ¶©ˆ¯İ†OPY.è¯Î¬|f¹ŸËÖ¶oõCùƒ¹6ÇXÉ7Ü•ebÈ€ë£e˜y²r²º)3N•Ô#õ3*\000Gò¼Iğ!ÇBÿMS@\000‡Ì²”×õÍ¥ÛrBZS¡[¾ØZú_’$7$Á0x/ô„\000;1x1v\000Â¸‚üÖ ı³‘\n€aªV‰q!Ç>%•VjíIºsú£LóœŸS½Yh¾™·H±ä°ŞÒ7AUÏK¶Ñ1‹Ë‹ğt!,gcˆ]Ê1~§ŠL\nÆdÖùü¶\\0èf¿{3Ã$‚÷äE†ò¸˜¯ŸÄ–‡Ö¶¨:Uy5$E›w0)m’ì  ´êP¡0ú\\½üÈÜ‘ğEÉ+Ö3ÿË„Üª;	ô…ã¯4mÑ!O©ÍéX!öÿvïßH•ëĞCÊ‚Oº°4\n**§µòå~Êt	D—Q"Ò24šr¤ì\'KÑKµïÅ@“rˆ|ëß›ó«¾Ã`jvÚô«Aúçy¼ı¢Ò³æ*2(Æjt²Õö÷¡J>3ôgõ7Ş36Æ,ƒduL$ìJ½·Œrƒ°¸¥ã)zŸä"\'ğ³Z[Û½_jşwNYïešÂY@9ÚÜNpú§`}Z” Şº@¾¼_™öŒö8Õ8xPØ¶¬CêtŠ‡ì5ü.ÑëDÌñHşô¯Pì•_9^¾œ`ƒšè¶¢(Æ9	}Û-«håŞÑ¾(UE¼Lª³@TÖ±ZföV‰%,«ßûv‡_]¤§Ÿ]ô¤K5"š$›x¸tÂ˜QKX8ı–¦³*ïyNŒ?öE¢‹ŸôNµÀHÕ*é­Ÿ>Ğ”€dàaQ>Ğ¦A÷ª„I‡Ü_™¬ƒïo^eĞP¢O\\ogÄ¡0Êdüu•‡#ÃvvX¦b¬Âcï°…¾÷ÍÑ¹LHlAVˆ\000\n&~Ñ{Ÿ‡órÍÿ2‰d>fBˆîİ¬VÊèÙ*°g³Ó=Äõ~*8š|âß/’–vâëˆs!v¬ßcØÈšá~ÿ”Uàş:½Õ²c}Öüv¿…®šNù`VøeLSé­g/ÿĞ ÅÙÕE1÷\\azÅí‰šŞgìÛ%\\»YÕQZùÚ8¤]àĞÉÎât@!Òõ¦?Ş%:“5QqS¬¹æ§0øA™óÊÆõ	È\'iŞFË¿ñÂ×Føˆ#’r.ÏMõ¹\r„ó£‡/$UÉ™*g>¸DÎ²?EglÈ^˜İO1uJ‡n3™æ½ëİíXjÅ>ØtäÕb	÷lšc[9 8÷-;Ó¡ÅÁòr¼VP„Äiä:G†GVîôîèe6¼lvİ/’L\\Şa2”öì¼ßŠKeğJü­0u$@ıÇz*¬‰7m‡«ÿQøÿÈ£‡.\\#ÿdN$K`x*AnÀMÙ®Tw%)¾s*—È²íX—ÚñØØi¼ÁÀº0¬`±d½Ê°£ŒŠ z\\éŒëä[”S™DáËçAÙ÷1D$¦6”}I¡­ş7yÑnæ‚û6ÍÂÛ$=Âì+Ç°s0ôâ³Å¼êZ@“ğcî·kïöÃB€øì©ş–¡`²(+ÍäùĞ3Q\nÁÂ@‘›€±Gª\n^³ÜxÊ³¾pOªš°}ÍaBÒXB0"ã¥©J³T,$taŸ¡ıGeÎÂEbG„(Pñ¥ôvøJC¶L\nŞ’Ÿy”ÿõySQDÄ\\öYÔE«àå˜£İªÂh#Œß#×tU5h¬ßÖ¨Q„×“~F6Xº£˜µÅRÊ£VâàCû2ó‹£â4!£yüOö¹€I‘‡AÓyF±öÆTäÀÃ£Í\rRúœôÌ$ùº©í\000¼,_#”ïgû¶¢Ó1ñ^%ÎeÆÙ%Ë˜éG8Ù¶¢P$Î‚M5èó{¸òxÿ•ÇwKÂèúv£ğËWcR\'L‰„±…¸µ $Ÿ%V¤‘FkS?%A´‰0­¤ŞÕo\n<îËè©u³ÛŸ‹Ô6@©}!ëDt©YV•Â‘Ì<X"fZÕX¤+7"µÓ8ók\\TeÌ¼ÆêÁşÑê;âª:y©MÈó¼5ïNyÁj)°Tè;:“Éº”²n|O!Ëğ÷e›+È8ßş¤dtVIr=\'ïs¾wÀyüí=¯·×®ÃÛ/ÕÒœCôè¨Ã>­q`tü\000¨/_‹¿¨ß‘rO¿\n™¡t(^Z“«Mö×ôˆI£œllªùCuâöü;¼ïH¡µ%5ª\\prJş”±;šuÓÌ›4y"‘)šû•t[—÷?©_(ˆ¬îw~T3·8^—X•^ª6"²i)ÖåKuÑ}]ê¥ Aû¦À<İ8İpìåsº:Ù¥^1M*øWÀ&^%Àí\'~U*]¥Œ\nØ¾LmCy$—HÅP–"l1”ğu/)¡ù™`²ÇÚ—ÓğÒ \rŒüÑ-H^[6¡PË=‹t5øŒìÂ¯Á0×jBÓœµ\'×‘&1Hx·õ{H\nŸÿÆÁ8§şL„Ï¸+¿Ï±ve-ß‹Cß½éÔ2,,ÈZû½Ó5ië İF)Ñt^-3{:2H°«ÄŠ‡ŞZşİúâx:àprS4S:b›š¯VáêsUßúıaŠõ6|X‹GÛ9ñ§Å|"tTá©ºRsï¡—\r°µ5Á‡hA«ã,a!ô†Ow.ûİºqÓ7÷rNSRòÕ¶´¿ø:›³\'8 ‚î-tJ7²tú/@Ñ´Ëÿ6KxØÃâÊw@k0^uÁØnµQğÀm*D0uIº¤‹1ê6ñÄÎhw6#f	oÿp„Ãuø)µìàZ~oï¶BÍu[:Ç¯oc»@ì\rqÇ&O??Õr°ÄÍç­Yš%8åŒam¡D=Œâ„$Hôˆ SÑ_ où0eÁ5Ü5šãåù„\000zökÍñıÜ½ÍôÀÉN/"«68¤ÉBOº€SŠCZ_‡†r|ëã	\\‚ú/ˆ#y/«µW!+÷\'\r¼÷fµÀğo„V(¡“Û½K‹Óhiîl«¡sHÃ]OT/«rğH+$j–âkh\000|f„@HW5!!ú1íê€r-ã<h˜¦	hœğÔÎXÈÑRr‰”H¢ÕÇYÜr‹«Û¼NÛÕµ\\cÎÎß!7ÜÔôÌ×ÊQ¸•iG$Œ5>œáä2¼‘9½ñŸ`}˜€İR×‰>*Ár³¥‘Ïäò0Ø¿æk`è´ ¸Oâe/şâúb\ráÕ9)€’jKiÇ„‹ï»cO“,j#|Ús¶¬šTW“˜Ey+°Q«à`í”øÅª6 @=ä1ø²=ù£-\nÀ¼•P«…EJØhÕÆÖXjÊ¬©¡–Iú¹-€Áslø‘„œæŸŒ"†Ôî°2OŒŸØ8ó«Ùş¨•ÿóø’	(ÌªÁšXKúx²$qí„“$¹ÇdºÏ©æÊ¬h¥µÁbG-eİØúÉ=$LûÊXRÜŒíÀorB°pfÂÈnÕ{¡	X"[îl{é²bşK©\'\000©ø#!´Ó)~È<‰ç;¹@rÑ~›zS5íÅ„•bŞK©í1qƒ©ÏËMiUziøºB~±O8Mc=‚IR¬ƒíy,„SÙ&®3Ièåf²ºnf0Ófiï]FYtŠ_Æº´ª“²>ĞäÁ§GšªñÁÂ—í•*õı*ş¸ğçâæÀŸ¹°Şni‹(z­*qÊ»¸ÜÔ¶^½kBE0™=1™Q“ÖJYY8T…É—Ìc8b°¢Ëñw4‡4›?uµ2Ç¸y@±……C%Ùç/³JY„™¤MÄï;”Y+•!ŒI~Å=Ü§.‘‡"m5ê•%^GQm¾È`clÈ†&-iİC¦*úÊ\000†~!€Û®Ù4Oj,(¹½;;Äõ£íåÖl„\ršU@üİdN«	/A˜io°é9êãĞËùràÊùİtreî\rï³«è;tŞ£ê·„³¹$l€ª<rw+Àw¨Ğ£°’ø”[l’/.Š?1†£ÌgÒï˜ğCWS‘°ºw­Aôé¡…eí÷%($z³ZÔuá{4l6¥7æˆ,é6·•™G¯3e9RÇ¿vô· Â¿›Ñ© Vølz­AD„Š£´;\r6ĞYàÈ¯ğëôˆ³Q$ ®?7O2á²Èå\r~,\n¤ù¨½ÜbHÙõbÎ)Ñy`m0 ÈQ‘–U	D‡/ÀMÓÔ	ûÙêSbğª¿ÆeµĞ?¦wHí~ÒÉæVb«ÈPùê¬©c€âù|½eóÚ…—YÀ¾ÁOŒuÒm?¸šÎZC¯úÖÿùQr8ÀR‘^JŠ.	®ü¹êR™\n¼„ş¿§Íè¤@ò¡µˆõğ¡n×¸\n¾Œ\nØ/YSÃ$Œ‹¬CM†¼àÀÃ@ª‡	õÅxå6fiÖ:œ°`j•¬ŒÉNlÿÇÿQ›~u“kwıpÖÂÂÇàßĞe¥,d¬´ßËèâr”}ŠÄºÜo§à86ü¦p8ƒ5«àŸĞ;DP¯2ÓŠaîAÈ×\\s$O7¦ò½‘Ä¬Ñâiù>ÿ\000"Š74æõı¯ØPKVI¦xdILøŒ.©ö=<ÒiÖü"»~öIÏvu¯WÄ*êH lú¤£¸ÁÂ¦Dæ`S`²\nnÃEÏ/çhyû½†íw[ÍÃœE\rˆã¬cZ5rc Íùô*ïÛÈ(ŒMŒj°æÇ›l:b³!Z	»,ŸL£Ï·[š´#É1Ãy5Š†6	‡4ÎbºßÙ%UŞ(m\\t­/`JÛ ¿<b¨YÍT\\k–êòEcêœŞ+b<6	·¬ÎóMÉšHÏö:„é8øiÓ	[øáXV¸9ò¥Âéy6(±€ÚE¥„ÿLA•º¤\'Ñ‚Õ5OGa:ëqŠ+ö|ö_K4êQÁ³ª$„—Mò(<E[C+a@\'C«RÑ$£º)6ÑÊû¥<E}1ÒmÄš?f?.èfø\r¯"Š¢pÜPv7şœÔ{Ù~%ÑCæ÷ÃZ"y"QA­^úªÛ4À±î§«OGtÓqáÍÆ§àyíßü\rç’—˜™É¢SÓrî×aJw&MZïqæÃ¶,p¡¬÷Ÿ½òËãQe£íaéèšb§»¡—h×/9¬q—ô¤ˆd¯¶éÁ5˜<CuJ÷úTqÂ¹åÏÊ¯>Ëï*$::“y‚\\ÑØË;iI’©Ã¹Í·+G{eY˜4ıHğ‡©¶¦³r"ªó{»Y\'êjTF÷Râ½ÿ\'’!=hÎonºîQĞ-J½ŸZ“.L«jƒ‡n‚õ—Š.ÀÚ\'yÉ˜‡Š!†ÿD:œ‘”½¤äÄgRİûŒì»Äã±iOOÎÓVMÍ"«¨A±”ŞîÀHÚòÙ9or%qWÓÁ«_;)êY÷p€ÊA˜¾æi•\n;1ÄŒÇ¾ykbØÛXİGö˜ætiÌğ*Š»W²½£P9¥i~bu‹È-Ú:¶¨u w//‘ğ\000ÛàdŒliU >u½£‡PÖÕböUÎ–,¦B&•âI\000\n•ós¤}29$B$éæƒˆ\'ÆÂşşĞ¡–W¬İ}3şíÔoÔJ5¼°Tqˆ\000è\rùKöŸ‡ÃŒ"ŠÍ¦¢cøê‘ó+†Cq„y}³B®šÿEbÒVÍ©ÏœàO¶‹GT0¯ÿ’°sX+}Ë¢¡ÍÕ_VCv€7#@`¸zİ›yĞaKê=³%÷ZAe8#ğf<Î¯=u´ı¤MrÑÚd˜’-NÿcàÁ^Šì¹`?:ù3¬¸Ø®[3ú_Ãkw"kİÓFŸğÑ+,!¸ùësv ØÖ\'â ’1!¿,±õöZ¯ûlıÀí<¸&ş!?Ô¯Ë%P~Û,¤NáÈ»KTw¹®U,±ğÍê^Q4K‹¯—÷ÔÉÜjÃó&÷¦+¸aÇCSR˜”R¡Óéèd°m}„d€E†è¿$)÷z(ä]Á<|€*~Åf×ğÊJ°şRË8õ}{6ÍdØz—`Ä¯fMÔô¿Õ‹“ZqHYh³YE9={İA€D¯nwãnCI•¬PÎôùè,"şx¸™O>B9ç7ãÀÕFÎ…8iÆ×>kş_ß‡5N¢w÷B\\´€g“Àãä îf›PQ»ø“wzÛe_‡nŞÉ@dÛ¢ö.ƒ>Ö(áØwÄğ»RŠ1Ã³N1p¨p†/J©ÚĞ7À;F÷›.Ÿ‰äl½Ó9±dá +ë)š<±\000ÇùpDmğA±KE@ïÍm`÷-¶Ú"é¶}à¤Š·%°pö¼Ÿ<<‡]+yÉ,@töûõ¤J9Nu&5n“ÄèÒ9bHÃGè;OxÄpoAæ±e_oHµuÏRúVCû ]\'è-Ê\\E…ÇM9‘ÿn”vIN`úWB¯C‚V§!tÂeç	ë±QÉÌ’/Ÿ˜µ_¤ADtà<‰_ä5"œrÄ“ª¸y*b†x0‹	òbe2[2_dÔ@ğ«CG…›áæš\'O__!äöä•w÷ã¾ÔÒOõôÅ©Õ¹XàkwÁ+ÜÅJ@¥×ÕşšŞR°´:¶T"j€*,tà3°P0cê‚Üd‹Íñ3mF\0000ÇpÅ©çBŞ:SØ‰«¼ªZOìĞöx\\l)kÒ…?üÄ[Cû%ª0*O¯»/c¨UN4–\000äÃo0ˆû|ğáï\r”9aŸ°©`qëq²o¬˜oÓ}6Ğ?ß7Û’+ÑÔ¯›J$A~:Ÿ@ctïtçš¤û¤·ç,¼ñƒ¬şnc–yåÁôÀPXcºÿÖK%Xqœ5R½?O\000ó»Á:kèŞIĞ:Ò<lƒg¬D3óìk7‘BRÊènÊÙÅ\000ˆXÁBßfşUùg’Æy@B}K2KSğ1mÄuîz	UO¿Óz@Ê	ã¹Y\n;;\000™¡w‹/¹6	¯¨£Ø­&Ònú"Í%BG¯ó¬ØX™NŞé\rPl_ ¯“¦L”¹°k fp¤ü©À¿ÏÚ¨tù›İ`ØÄ<+ÛQk*!’;ÕÔN3ÅWq%úr$DéDósš{Åš”æ’m®Ínç÷iZ¡( …˜rŒŞêó5Ct¯¼â=Õ!ØäıŒ8§¿¿Q»çËV?UµiQèW§è*P‘‰÷ÜQõºŸïšvÈî¤6ùáõƒ7•c±“nˆs¯F–Âmç®Ò?é\'*€9Bg_é\n~úå{KtÏÄ×.’ü˜î¯Ô@Ù*ô[)@VkQÅsW6.İ€”:²[”/‘£0\n©æ:·5\'âVÆ8ÔR¿dDs›\\\000{:¹TS˜ëTi@­&ser¢ tÁKÊä…”w#¯‘’KQ/wıVsQ!§mğqSjÓz6ì	®¾77Fr$â¬O©Úö\nIÍ\rº±0·½4¹TA„PÛ›°—Ù«™†kšÈfşqÊÿQ Fœ£bHcp¿×p0HşúõÆBÉZE(qS´z!"‡Ù/"6ŞG¦Øb“—»ÔMõiÊ¡ğqè¦ZŠ€İh`éü0`©™îXƒ!<LrÔ$BfBªhÊNø”üÏ05pŒædIS*(~pDÒrİJ7dFÍÙM)Ñ†1Z½ûşj|2÷©²¢B;|,“˜q«›ñæ±5{‹Z!ú ìIXø"mùC—<\'Ì˜¾ ­$`#‰±ë~øO`­£:îR6kt9<yii2Í’	½­Á„#×TNóŞ]fä(‹Ä„ç/máÓ!áïsÇ­Ï»lı¿\nº’¹Y~5%Nä	İØÌùÆĞE8øÒAàí®û#“WÅYÖÈ[c[ÇË‚Õì›Ã.\r)ÿ8é‚\\¸ö¡|Ã\rt-­uëBÊÜ`™³§\000ï/Ú¬Î¯=y?sY´]-¸,ú»*éõÓVDéh5íßd¸zëqp²\\™‘¨ğŒß‰ù>ï^¯ß#k>WÃ¬%äFhwfÃ¬àÿxˆ8ª7wkƒïÄè#\000»vÛ«.—ôl¶ñp5«A&;OàœÜçÉ«%Eæ$ÓşÒ\ré{F¬b?tW)•‘òyŠv\\³zÃ>Y6Š@ÙŸÓ´ŞÑX·†£RÂ“!]qÂ¼æ’a`	Î…Æİ\\nÈÚl1ã:®V¥_ÖÅdr´²›Ôñ“€zP;˜w±úláa\000ô˜C$`Gzrœ/W(1Î©+…ƒ{CDß˜x1‚µUÀ‚**”¥Å7½2J°² 4ÉkÜöÙô­+k¢?c‡9÷ª~UmßéÀ¿§N$‘\\Æñ§ÎÀÂÅ‰Qj\'“ª”(T…)>šlµy6Ç÷ùˆ\000ä¨³«ĞÂè>×§ë¥]$š@9 YÓâ^(xÎ	2z	ÁØsĞu*¹W$ü§)á×Ä¬ñÓÑU.F|_xÈıD,¶/±¬àÙïJ›g=ğ‹G³­rù$•¨õÚBo{…˜i¢Æ^ûE"(u{Â–r’tj ä7ä¶@y´§ÔŞ_N`¬Š½±sµĞÃÀÑ§¤aÅdÅ]µëfF\\ĞÚ³UÂ1öIöi’WGè¸c¸r¶›Ê›‰\'ízÖ"Ëy‡ü•\000Í ) ˜‰ğ¶J³C¤#v•{ÅM__Vü;W¾Z\'ÈrÛ¤6{¦É‘Œ°¢RÏÄ´9L,»­èˆ5]ù!”8%@',11247 if"ä"~="\xE4"then local a=assert(fs.open(shell.getRunningProgram(),"rb"))local b=a.readAll()a.close()return assert(load(b,"@"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error("File corrupted (expected "..size..", got "..#disk..")")end;local c=require"cc.expect"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),""repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,"invalid chunk")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error("invalid chunk")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch("[^/]+")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)=="table"and""or O elseif type(O)~="table"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match("^"..aj:gsub("([%%%.])","%%%1"):gsub("%*","%.%*").."$")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or""if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)=="string"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak.."/"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if type(ad)~="table"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch("[^/]+")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,"string")local ad=ac(disk,ae)return type(ad)=="table"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,"string")if ac(disk,ae)~=nil then return"mem"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)=="table"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,"string")c(2,ao,"string")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao=="r"then if type(ad)~="string"then return nil,"Is a directory"end;local ap=ad;ad=""for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and"?"or string.char(a7))end;ad=ad:gsub("\r\n","\n")local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error("file is already closed",2)end;if A>#ad then return end;c(1,au,"number","nil")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error("file is already closed",2)end;aq=true end}elseif ao=="w"or ao=="a"then return nil,"Permission denied"elseif ao=="rb"then if type(ad)~="string"then return nil,"Is a directory"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,"number","nil")if aq then error("file is already closed",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error("file is already closed",2)end;aq=true end,seek=function(av,aw)if aq then error("file is already closed",2)end;c(1,av,"string","nil")c(2,aw,"number","nil")av=av or"cur"aw=aw or 0;if av=="set"then A=aw+1 elseif av=="cur"then A=A+aw elseif av=="end"then A=#ad-aw else error("bad argument #1 (invalid option "..av..")",2)end;return A end}elseif ao=="wb"or ao=="ab"then return nil,"Permission denied"else return nil,"Invalid mode"end end,find=function(ax)c(1,ax,"string")local ag={}for M in ax:gmatch("[^/]+")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)=="table"and 0 or#ad,isDir=type(ad)=="table",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,"/init.lua")_G.fs=fs;if not ay then printError(az)end

-- End of File: appData/FileManager/app

-- File: appData/FileManager/data
{
  "FileManager",
  "FileManager",
  "timuzkas",
  "v0.2",
}
-- End of File: appData/FileManager/data

-- File: appData/Settings/app
local disk,size='ØßB«†Š(¢\n(¢Ùw€Åg•@mˆd ‡Ç¼M	8ôÚ@˜¿a_ÎÕõq¯(O<ŞÍÊJ©ñ†@tÍ¦ÍÀĞ†!&¬1m†A°F³°¹½\rn¨§ÒÃ3º˜qO-7*—¿vtGØUqÿñI˜š½ßYuÀGîxKÈQu\r·>kñ s_¾Û`0ÏR¯^Y –àvLá‡eÿÚÀc—ÃÌ\'ˆ>×Oºşf×KßÑøÇ€D2G¹ªôBƒ4:ªxŠÎBÕ\\\\~y~XËeéc¤›Éñ™#L†–#U¼M®Æ¶[êÜŸ¸@‡…#¾!Æ[I/éÒyÓ8ˆ§b_õZS ÃÏB*¤Jag{ó&nòi\r…‚ú6¬X²/3¼4JÀÊÿ4·\réä]°>›s­¬‚zBäÉc&s”!ËÎ^çgá”£kV±cÊx–Ï¼±-ZüƒÊ6}yy×$W+*¨¹ƒ£¨­>ÊµğÈï³÷_$ßJ ©–1«ŞÍFÂ@Š3Şæ&|ZÊêF.èÓ4Ü\'V.±¼zä¡S§ÔÃ?ºóXÏßÆmƒÙ1ÔĞ‚“7‰°æ–ç¥]6Ie(Û—®Êd‘9ƒ>d¹¡”Sõ#¯Bo\r®0Dœ†`»Ç‹å!ypFœĞíBø6šV`¡dAà!)_GlOöÛ¼wìÎàû%æÌRşc9“º€á b t\000=“’§UYÿ‡´â­"†ôoæ’"›$“}âÂ4†*àİë—x=%^”MJ¥÷Ö¯¾í³Ô>&….ìˆlO’Ğ±™;ß(ZI½È—%”›’‘Ym\\\nå#©³·ÒÂ{yÑ’µ›\000XN¸„ Ìù‹Õ›³W?%&îÊ#T¸TivÒkz‰ÀOmzõ HØVi]œ‰í4»»œIÛ"jR—LGÙN\ruòQ™Ô7ıQ$3Öq\'aÕì,F6óÅ¾5E;m‘Á‹·P|ÜíåS,Á:ù¯Ûİ–WUuÄ÷Äèï¸³hó2›m\n»ÈÁÈpÒæõ\\V÷}W¼˜¿)yÃ¦ïÀz®á¸û¸†0j’Un!@ºs)Of†¦ôO‚k’SSNÃ‚=n°¡\n)^ˆzO.!k;@«ÃŞÚ˜Ç®tØéœ¸x¡¿qÀ*öyoy/¿Çÿôÿa¤¶>éÒ	„\\%ÿz%%:yw]˜CfÈm¾à6×ÃbŒocğgŸÒkÈ*ª@#€Y®ŒÆ­¡3µ!bo7ƒø—öAò•D…ÕPv|´±}óAÖÈÙB›ğ›ŠìÈx¹,ŒàëqÒãaÚ°	Ş:X"+‚ïè^™DšSj¤Ú:K~›õ‹à¼™Š‡û!M“ø´‹D/\000áæê¥ğ\000Å\000ÚùÂ;"İûÖ?\\xâSpÕHOE{Ò_‡.ú°»~K†]Ú]S•ªNÓ\n‹¶¼Ø¾ ¹©5İ™E+f[\'ßaŠ’Â3 Òq‡Ç—:P„ŠÈÙLW‚ç¹FÆ¡nwm-©•Â‚„œŸÅ”/]£şâ}M\'½ö´&­ÒØˆüÒV(YwàoZŒájU1O¦qnªÔ(ngF\r¶¿+6hrCËµÖ¿í»“\\Vø9—Ğû\nMöó‹ygÓĞã9Çôÿ-EªŞ)„Û¹FÎ÷´¬×©ÁµÁİé`Û²hè¼z®55aÄ]öÊğV?€ Öí­ß>;ÀÔåøé[¾Û.@²³;é„Qøõ‘]NĞDP­Jòœ²!ã>îÂÕº	ºh‰P#[“Ü û³‡K3ÿ’ù°»qûŠpÅ…J–ï˜®KbKşG.`¢“Ş-5Š[{h*²¦ÜMÇÃª\rÉŸ‰VÀş35ïHşÛ]ìV±ĞÇCƒhçêÇË«2ÂA»C-¿uú\'Àè‚‹ı’İºÂÄ°ÀâeÑufÅŞ•l÷™*”:2áÕ¨H_ÁD‘ß‰\0002×y ¾òK’†dGÙç¥°A\rØB8?’\000B+ ü>	Çİ|ÈzÔÔ~ìÜZÀ€£Óù×2¨o„éQb²1]ƒ ¯ygN~ó<‚Où\\›­e[oıÉı’^Ö,vµ{¼jCRsqK}˜ßŞNï´™2yŒq²‡ûÉR6L#¬T’ìc\n2TĞ¥Ùßl²=;0pj¬Ùæ¿¯Ê´ÖÔ_Õ[8ÒÕÛÆk·}9“N²ÃXåáEÏ+ö—ğç–Ù‰e”‡¿©ÃØï\'%ëöÌÓµæ™Å2lm;œgİìU—%Ë ŠgW*/5àbëOáDÍÙ]«öıİ9C˜HÿıkÄ…3/	&]8†5°ÊCi$ZÚ ¢†ÜÌI{X±`ğ^EØÎ‡bo¸PÅî":Ä˜:„QŠBE¸w—0[&«sr6ğML	6ôºå3ñ1Š×/%s{í€öd­œ^3ïb\r|^ŠäÌ*)~H¬<“ô¹ÛÓ¯4òÉuM‘Ô(Şãê;Éµ%\nİŸŞf VxL]Y¨œŒğ#ò@ğï&e*}(q²Gª¼FÁSfua€³Ù»M°>¡ögì£C\000u¼ƒN½ U•ÏN‡áÀ¾`ù^¡îı¥™Dñ†~ÏPŸ±Ñ|ã+¼Îà„x“¶ŒÜ—¦«úÀ;í:8İçÙòúŞ<4«ªñ¼:éè„°‡\rØõ÷„}	Ûüù@õú’›\\î9|›iv’Ú¢à‰f°¸RDµ:°Ï¾ãF™	6q5€–À\000™†Ä~v¿È®7·Ë(ÿ+`B)åË#Á2L«=é5M3¶l4Ú‹HÎyÔ&3C!?şÛâêbİéßu¹»¼`Ì»¹)*.¹Í²Paí65%`O›9	•n`µp0ØjSÕö»„R\rrÂÑMêÃodiRóıİúº°B½*&§…‰2¬½?9:¶¢|t<·u&±*ğ>—kå¯•å_rŞÊŸÇ]"²ı›%,·ìé¹!(¥†Níéøl©\'oğ6®Ü¨ÎÅeàL06|Ã½œñÙÊnò‚Õ7¶‡ŞÀäàüH.ìW´îyÚ2\nŸÓúB/ÜB8Ã¹Åè”hİÃªÈÇ8wQÜHnÂÆ!¸ùÔFòt±å¶é­Å³´kå®4şˆöV	É}E¿-FtÅ@†o"•\000õqt1åOÑücƒ‰wgÛĞD?:¦\\|äõT:?Ÿ·w¶:—ÀÒ·v§º´¦Ë\r¶`dµD[C@YÂcúˆ€{ò¦ÍIÎëb,#mÜêEX\000‚Y;£‘”·{#ªÇJÿÓ8Qe¼UEÌRÕƒ¨?ÏDúf9züo­ìNŒ˜5VÚÀja`”Ëó_0M¸H8³¯´®/‘/‘:Íf£‰õòÙƒn: s¥öÏCs´pKíş¸òza½òÇ‡Hä©Â»÷@ğtF#±–˜4ĞÌì¸g²¸c£û¾.7S¯G¡h4gñHTMŸÛ)}oCùƒÔH`¡!y¿[ı5vºiµnÃid–)?ŠE°„+QFe)Ø„³Ka¬èU=”Ø»“úµ¼áÄº,3Æ´²ªM7/«o¨ÂùNe?xåÿ—‹Ği‰ß{®±OÌ~‡šÉşöÛŠğ\'b»¥ç;tt¥õ0Ó¹vşûQåò·Õ¶.¶ÿ°¬:\nî\000²ŒõeWÊ@@x—_˜Ù@"3µ·ŒéÄ¬ËÜÀ×Påñ}ØÌ¦iµOşÖím1ßÊCg™™°$B2Ïò(ö2z†ê}•‘(‚îê‹G±\\az7(UdøÆb¶XpJsNt¹ßË3·#çÄq˜HÒáûZ¾«æOÕ)`LŸo!ù[p75)ñ½9vLVÌa{Û_r-ÖE\näj-õ7[ÉÕ0S8õ¾§p]ëÿ”üZÜíÆ3j¨Fì¤åSjK!ƒ‚øN-h0¦°H„“EŒğ‹Xcø„]åú­—_IÁMëK¨è ;Ó w¯}•5ÒÑ‘‰šqx^ŞºÁJç€oN}¸™Úœ“Õ§¬‡‹ké¿ê>a¸Ş•RÒ_•ïUx±ş ö¯´¯\r`šGò>x•|«½¸‘¼kÃHøŠ»<[Ç04 U›s–Ò÷n¶G÷©JV‡·MßíT\'˜Š¬CF´”eKÌ÷’íÇJõVıN³Z•]Å˜ÂW Józ&ø­¸L[ÍÙÇrõŒ ·‰"¢_ÜİZ7=Öõ£7rø¸1Z5ƒz”c8…²óäØdeÆ4Içü˜-ì0Úï¥£Äa\'’K.ªKv|ö(8úë”;õºfœ\rM¡±òª›s~Î§z¹MÃîiÿÀ*áöı!­bÖ ®}1‚Z”€',3367 if"ä"~="\xE4"then local a=assert(fs.open(shell.getRunningProgram(),"rb"))local b=a.readAll()a.close()return assert(load(b,"@"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error("File corrupted (expected "..size..", got "..#disk..")")end;local c=require"cc.expect"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),""repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,"invalid chunk")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error("invalid chunk")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch("[^/]+")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)=="table"and""or O elseif type(O)~="table"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match("^"..aj:gsub("([%%%.])","%%%1"):gsub("%*","%.%*").."$")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or""if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)=="string"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak.."/"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if type(ad)~="table"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch("[^/]+")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,"string")local ad=ac(disk,ae)return type(ad)=="table"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,"string")if ac(disk,ae)~=nil then return"mem"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)=="table"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,"string")c(2,ao,"string")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao=="r"then if type(ad)~="string"then return nil,"Is a directory"end;local ap=ad;ad=""for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and"?"or string.char(a7))end;ad=ad:gsub("\r\n","\n")local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error("file is already closed",2)end;if A>#ad then return end;c(1,au,"number","nil")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error("file is already closed",2)end;aq=true end}elseif ao=="w"or ao=="a"then return nil,"Permission denied"elseif ao=="rb"then if type(ad)~="string"then return nil,"Is a directory"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,"number","nil")if aq then error("file is already closed",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error("file is already closed",2)end;aq=true end,seek=function(av,aw)if aq then error("file is already closed",2)end;c(1,av,"string","nil")c(2,aw,"number","nil")av=av or"cur"aw=aw or 0;if av=="set"then A=aw+1 elseif av=="cur"then A=A+aw elseif av=="end"then A=#ad-aw else error("bad argument #1 (invalid option "..av..")",2)end;return A end}elseif ao=="wb"or ao=="ab"then return nil,"Permission denied"else return nil,"Invalid mode"end end,find=function(ax)c(1,ax,"string")local ag={}for M in ax:gmatch("[^/]+")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)=="table"and 0 or#ad,isDir=type(ad)=="table",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,"/init.lua")_G.fs=fs;if not ay then printError(az)end

-- End of File: appData/Settings/app

-- File: appData/Settings/data
{
  "Settings",
  "Settings",
  "timuzkas",
  "v0.4",
}
-- End of File: appData/Settings/data

-- File: appData/StackBank/app
local disk,size='Øç6â¦š(¢\n;‹#¨,‰İ4µg´ıU&5\000Ÿ¹†ß¿`\'^\000ßí¾èdÓ–ªÀ`\nĞĞİãÍk¼ÉíÙqÀËaöòbM¬¨ÜÉ\000}Uê¡•NŒz‘ØÇ4läå@-‚´iv=¦ S»Læd±°âXÖNìê[dSØOÉ¡Cìg¦¿ n~­ªIßáŸK\\RnÓ\rèô\000ƒÖ¤k	{¦ø¢ññÊ%„óu^WUyhL	ßA)<õå¸sâI9ƒ«¨™Ù™[\r èR5g`¼‚)ë\\øqÊàúŒobrìúòéÎ\n˜ÄvVªô„ÌIßFN\'ñ\'@Í¢ÁW 	 Ãø°v6=?—6œñ²œAà!¤ıFqU«ÙJ‚„@Ì?N˜ú’¹ÜWÍ-	ºß‰. JÈ¸¯òç\r/›¥¡Ø‚ä’¤q~‚,„e5!Ú˜¹2"Ræ"áFAƒs	hX97_‹	Ø9¾É5kâ™MH±™1y æ;bô‚ÚüwãJÿËTM!t¶Ó^Œô4JkJy&‰ÉNÈ˜	|^Rp\\¯D3júZ©\000Ü‹\\o"\n Ş*MÃ\r‹(t¬t8z46â<Î_[;¯‰ˆ§P);…&ÜÓ…¨\'£%°$Nşr+a(ŒÔÓWd`DqÌÊÌ¶ï«àNB<yĞwìsTfÃïİ3¿mcİöh–ßÔÍI\',-“¡¥(ìÚvF\\G‰\\·–qXD<ƒÄ\'!\'ºzïµP™Ñ¸<ÖNşÉÉSaÇÀBùYL†&4sÄí²jq¨Óàù~M÷Iì#¬º¥\\ç¨æ2ËÅÙìGÒšÊpãí¥ã«J¸î˜ îh,ø’QÙ„d¯³4.Ä,Æ·S”"ƒTU³£6®öQbÔİ¹¹tûŞŠÒ\\şîºö „ˆp\rY˜ÇèÜEş\'+ì›Û9A{˜¿†ãî>Ì6|&‘Ö–sÃ—\na8tz8ëÖuKÀ\\Ÿ·IJf#HÉ(…W@;¹¤ñÈÇ!\000Ì†€$Çl.ahõ‘‚¿q‡I¢İd$D:/—b`Í‰BÒçÔ™’ğNU”ü uê¡^ånu\n¸í7ERóó0…›³ö¡z…5Şƒ§ìO|:É‚AF¥z²ú3x%&SCKK)¤ßÇáÈ¥ºNlÒÀMo6ÒpbGåG2º@|26¤ê}5ß½xøšÀ,Ödy6ª³³ÃÅE/1”oÜÆ{Øl€yyªğü"\nÎ™ed´³ØÂ#”ëî™Õ<}eµâfÄÛ×©!xûâñ}.ànàKüÍ±„ùQIs#Ë‹­=ê\n+ìX¿XcÉüaÀØê,8İ®Š$RœVk\000ƒôòµü¢	Ÿ¼z’÷)-W÷\nŠNowÁ7 ,qN®qå¾½4È¦g˜hØ¤;b¼Øğ¼ãôú6Éû2ë€Ò‰#_7O}gÚğ‡‡Oc0wiq5cµZ®¶O¦ôÎ`—Æy?Zâà¡¢ÖY{bªà¸wœW½¸—ÀÌJ9	€‰s¡„\000 ä¨F“F¥õË®™:Iï/\000ğµ©ƒñ±ĞÉ^™‹ç5å§¦\000HıkGKÜŸ­µiäyÔÍf–6’“®­%Mñ\rùMŞî+¿3­ø"§´\\—Uõò³@r6t&ÀOŠN¢»)Í%$%”ü•¼U-&aşìg‘L`8¢‰ˆt#õ^\r$#Æ\\©¶›X¶ˆ2s×U*ñ*ÀòA»AYWS¦‘­¹‘Õ@W3X{Ÿ<õo¥¤ÇÀeÿ`Æ~i[ñòğ«Z¹°Ò5O°l)å)ºéÛ$ÅşI\000/ô+Hõ—§éƒ»mÇ0l-qœ t¯Tp…˜	ç@Zûª:®ÁRÃ¢Tº´ö¬öÉê›ÈI…lŞ¢ğ†sÛEâR»úÆën¼8É9*\000ö™¼L*Åy®ü£²n âmµ(¾İµÄ—äÏûT„´Œœâvl_­R2ÿÁü\0003¡TxsÍu‹ú·{P!&ï‡ËpOhQK#×ÎPóãhãÀdU•*®ìóeà®Ì»Á‡ÕÖ\n¤/EÕq÷\ræhóz4•j‡Ú*ˆâg£ğE¦\râ\\Ï"f8>-{	£BïĞ%¦£<şı§ÄC½nRk?lâBÿ¹ÊfP|1W£ƒ}{¹täZîD"5\000æ…³ÓÇ@PÛÀ1Œ®ŠåÙÄ4œÖpód/ØèÚM•ÄçIÀR–…\000DJ¹¯[ æ¹åb*‘\r½÷AIåÑXvX5şu}yX=²ºVì³1¤Yò§üí#œÂ.Y|{~ï;\rk7q¨ÁÇÇÅuoi„¿¤Â*;*Š1éÓ{¶ÁìVNjSƒ“¨¼½wŒOe¡g®¯”Z÷¸ ïõhMi+äÇæ S¶0\000Š›7– ô’dôenaK¯ÿçˆI]‚ÃÄS^i@vÈ²M¯›Û«<\\@ÁR‘8-û7v^^ºtËĞo\000×&É½3=‚v¤mZ·AG)|¦ÌÖõ…ô\'$‹@oÇìõÅq\000¶:‘ø.pWùOyÖ\\#·ÛÉİÛÂpŠ"al°6ƒ^Ôê_ná-&î‹ ÉÄÂœÁğê|J™!§	`~0Å£ÄçEÉÜQÔ]‰™g5üNé‚œò7)o–Lz±öëƒØÌ[/æ»›3•‹®Å7 Æ’ªÑQ\r…Œ{g,´É\\_İ-R§½[Œ+Vp]ö_oÉÓ¿Y&¢Ydi,²4YË\\Ì.W9˜ÑŞÖ…~ô4]ıÔ+ÍÔYŞÜÉ´®Àİ{{ò¶üîÜçÌÌNÑNs_Í8›¨Ä‘µge&øutsSÇİ÷`ßmWØAşüP{Aè¤¡!õDwúælsÆë~ÿÂì$¡~{\000‹²_\\.ô“–©›˜ ÚíYîà2¾ßdÆ©óò4z·uÙ#Ì£ì¥v¸zí†"½ˆs§IÆ-êAB¹ˆë\'Lcf|¾9^“{­Õ¬(ÜüqÀ ?ëxDçnS¦Aªİ&—¢¼òüÆIPéåMÄEÈr#PIQ2ˆuí±èL â@ó‚f5d›cú÷5IwL`šB²îLõŠ¸ÛĞ~ú…$éªoT¶S‡OŞ÷ÁèÔÂë\nÑWÈù¿\r‰¸(Ÿ	"ÂÖ‘h²ÛØ£¢52+3]#Ÿ qas¤üHÁ‡¼®§Şâ¯u=ŠÎ†-}º¨&mjPüûèıA¶]wU¶¥—"ù‡İò¥y2¥&`˜a€šU›O²?% a§µ(56!1Æp®ZÑø„#ÓãİH*B™R¥½v³İÕõ§˜è]e±?¯Œ7À=b”É”ŠşÊM `ÙZûp\\¹3tÒ¹ÎıE^¹ÏûKà=-RP`S5(¾EÙ!IˆgNleqßÓ¹‡ZnQ/Ä.·\'À½ÖøÓÚUYÏta­Õˆ×¡ÑÉ°Š´ƒ¦Èu‚(‘ ó(š‚ÓÄJoP«9˜´Ê=dë=õjºŞÙ3F¡´ÇJ"|yyğSÆÈ‹ÊŞ£œl‰{o`n@îµÆ«,‹ÖÌôÙMO¤à %ı\\kJiLíÆv×ìnDFñ¢ÿ2ùÓdxIİïî:å¥3 ¨W½eÓ÷ìØßáe‚‘p~VhB%ßÍö__ßÂg*P`uGÄĞôX„!ã“+S@â´"¨É@K^HïC¶è ç<ïÿ¦Ñx]éŠ˜K¹ÆÔ@áå^=âl-¹O–†¤ºIÑŒ¡~pË3›iñv«­ài´r¿rÒû©íwş5É×e(8sàê\nBĞH™Aë\'ŞŒ‚¶Ã3‘6\000„QXKÎÎºxÚYqXP!hq@(ôƒ4ÈãL³€Ìƒ²=x+ÓŒiÇjÁ¾Ë˜ûÃHf*ÇlıkÿÓôİğ8‚¨¡Œº¤…±l,Êb$‡Ä"u@-²9>¤d‹e\rIq–ø¢5¬ê©‰¦DÕÆTúÅQëĞå4$Ë½ïŒF†\rÀğ–Äè#.Ø\r×OPv«v©2ğ0õrŠëƒÏ,IZ!#=ÔKŠÇ ˆ´¹Ôã¬¹H„-ŸÈ/_½6@¢9¦#ª¡nTÿ¬F7’åÂıó(àÅ¹±q¢Ø…¦ÚsÆÕ4·ÿŒôû_o—Uæ"â®·÷eSîK\000Ër­kiã+/8Gì©5õmÌ¼´^31bŠ–6	´òw7šOê%ˆ™åJı²˜o1Ş|¨Š†XNbí9©óş‰È9u]\n§Ôû½†-Pdó4TŠ\\Öçû˜ cS2†€¨ œ²}!ÈR)¶eÎĞ‰ß•°d€ræÏç™Ìƒbå\rÓÜÊ&‡ˆÔ†x¼M(`Óğíû†¾áŠq‰ƒ‚÷Mw$Ì‡“ºÈï_ª}ò\r…Í6Ğ«tªù¸öò\rÚOCÂe|e6¿¸9{™GN}9§³5š>cŒŞÉğ˜›ËhL„câU¡?|¯÷Ç&r>ãƒŞOzngØ)7’"”	Ğ„*ìí¸K\n¦ÈòU~»P†…H<Ìwgè–4l¡ĞÖ/“gWÌŠ$·ÀÎî ·ÿm\\šœŸIĞèùhzÚTg"yáô?Å93,œ¥û™Ï³×&,ğäÇYÎ®l1£Ÿ5\n5³!#[œÊ1Ègtz1Û‰Ç¥b²;¾Ê±I¼¹ÄŸ äºÄÄó?Õfze/ä)v?¥²˜ÿ~=“2PâYÄDƒc˜Û½n\'´İq^!	1[b—>3µ³§Õ^}ÖÎ¸V½ü1ÿa±€ju§ÈS¼†äRş¤]EÈ©Û\nZ3ø1*}DªĞÅN}\'`€>pì,êØ©¨´rp³¯E@WS`/ÙT¹hòvc‚èbé£ëÄÜÆş„-Õ˜?¤Ú§<¾åÍ¤ÖâğÖd<ºèÜk‹·z©µ:§€¸òêÓaTµ!!^‚øTÚæÓå¶08ÕzñÓknU½÷–‚ÔcNúw}kcšïó¿£X¶Ì;o!Ûn¥=Êù€ØlDœ×©x|‡F¡‚x’?èŞùÖ”3“Îrt¤‘*<ı.»ˆıC¡ú‡âÕ…x¯‚­#0s_(Ó ÍŞ Øy\\1øxJmßbo7Gö+)“2¾{ŞÆïÛ[-Ò%	—~x–®¢:·ê£‘9£g°ºÒ®s\'¢ôE<}V;€‚ú«¡ï|rï€ƒümåèT•*V¿|»D¶Ê¦aÇwVS|ãÓutn·ì|¦Dl‚º”=F?¢2†´[V‚ÂçÏk])dûèC$*Ö¤«ªwI–Ïvf¢¦Ï;©*˜¯Ë+BL#óNÜí„ÄYÏK±úôL,Ì3IA8€«P „$¹£ß]ô‚ğã·§õ¼¾t]ù¼¯kŒÇXq Ïµ~¶bî¸Ğõ²9ãÔ[6"S¤dá»¯ÕÀ•n¦Z¸UŒı‘2˜ÉÎ&VĞWÊŸûõÈÿ<Aa\rışæâĞ/Û±UÍoıBU‘*A‡ûÌ«Ä¹ßrIY5Ç¹2(aäØ·3¹‹÷î›ï§§fóû—	=Ş&¶ï¯ï­ÁÖC˜1œ$,\r>»\000pFøª;¢<4¬Ÿàh\000nÿ ´¿ñ0ÖÏ’â^êÎµ5B†|#¤/	ƒîºi9m,ï=«‰Ò¬„•_;2†Á¨—nÍ£¦LMXfAfŒR¿[Î§²3àû„ˆ&™)H•†ó©-XBTzÑ“6ÃÖZõÅ,’íåñj‹[ ÊİRÓÎµC¦ĞÈÒ3şšZupÍÆ+è¶ƒä—İENªvL;5†q“*SøX”Ó¡Ò‚ÓŠ\\\nSÌ\000í-ò k%îs½PQ\'‡ï&¶oõÏ°í^"µ~\000ã°H™$N"¾,|3é;ovåÚ3ø™­´Fp÷)PHn‹ˆÇ&…Ì¶ÿÂÎÊøh-a-¡Üag²ÂG¾Ó€È-ßF±~QV5Ëğ3Ÿ²ë2üŒrÍ².U\000xÓ/r(øc*>?áŸ¢ë\'2òæê‰Â“¾&E.·ûu|hRˆ&_@ı	oXDG÷Âµqôş<×¢½±pPkC	1|÷Kl:M³ñï!´dŞ4£Ölû:²Ü\'©î/Ï²ùüœ¾s¬_§ìè±” ŞèÄc	ÄĞÍx­ıpÕGŸ\000uîA˜(ğyV´«—n“3^\000—¾I"‡ê9q#c’k’Üğ?µ…aœã½ŒEšƒ¨OÌwƒ|óŸkv¾H ZtÅ·ı¯,mü¡˜·Ò1É¥º€\'C[?ÜeM€Bá„RÀáü?T2j4´4ùZÑb Ä¨ºı^Háá¨2¬GD¥…ÂÎ¼¡Ø“ÙF©°äaqğ«@ P ?ï¦è¶ìWØ[zr©‚Œef¤Ó#N²Xˆñ—õÛäÔÇÄ8ßíZÄå›v»zÜ¹åÂmğËC¡üàŸ–Ñ¹ÊS|Pqà!9~r N²™æÉ(£³‹BúáFfƒ?;şJLUp¤è%éew½áJjeÅêÍ‚9]¸ÏˆÊª­«´–7gQØ)©p¹NY[ºæÃ&’WÎ0‘5Õ·ğÁÖ\rõúæ‘9A¶Ïe_=ÔÁo²éeK!¦á€A´_mg?ùë÷i¤t<Ç^5·¦M)¼TR4Å-·Ç˜„XüIY ;íÛ°&¿fnßX|\nœU‹ÿ\000NÄûéÊè®½b”Å¹•t¹6€	â 5ÛŸ\\Vv\\\\Çî~_ êÚ5ú¬ä¦êÙ¨´ßY\'»AyMnÂ–ÃqÇn @z@%•8DœMs©âÚ©0lªQû±k¨ÛO™â£ëı#”¯F(ğŒ™‘x<¡›FfooÔ%.ÉJô0š’`¶‰ƒáâÈB8ËõO.zªR/ZŸ¼ÅÅÚn¥oÏNJî4»5òJûİØ¨tB«eÄ°ÔfÆ"{–Aêğ ¾\\uâÿ6ì	~óÊ‘m…Î\\À–røá‘˜3İštî‘ÙS6²(×¬XZ–¬Ø¢ú4stıŸ]şoB‚€?èAZõfâf`Æ^W°T2×D¯¤… #\'m…^L•|†_Î—O#¿(ÏT^¥n*%øÆL7í;íj²Ó%ÓLjó>Û3Ô… =2‘’®­£É|—£˜«Ş¼µ^oz{ÚÏÊ­Jô	Ll®[|Îõûk},@.ôËÒ¹õ÷d“Î—™èŠÚWÇŠÕ?º\rw])v’É¸)[˜¬˜‚OT#°†âÂ‚zs,|ÃÕ+°#:~O§a¼·\'VÒr.%áÉælµ`?ÍlœËËÑráõÚôçÿ~Ëm[êCF¾O.ïM£<û÷mŸU= ²yàê3ıìP;ï/Ö» ä[(uÄÍŠ\000vàs.uÀ;Ë5“t×yeåKê“§9âîS–©¸ ò¶Ø4wò»>T¿ÆO°Í(¾;Q†ë7è 1Aé·6¬“PÆè>M×atÄÀ\\¯ß7\rKÏ6S§Xîøï%âšÇXøñ›aM7AUñ¼Ê·Ğá~\000€¹bÅ<\000å«"ö#f±µfbA”,aM\r¹”u|¸p˜ã,ë\'™ÖoZ²ÿ{lbĞa&«•x3ky2yZn#cŞ[ $›ÉI÷ú®½9±À"İÍÃØâÎ\000{gsE(z#j¤ë²›«\000PùÅ­Ïê¨Š”vzDÀ\rcş„­¡/ò³…ùu§ôH%_gí,OXºğÔ9ÙÉi¡SÛsÄ\nÈ¡®\'gé2fÛ¯¬Æ¯4mkæâ!-d§ğÌQS&EsgvÃ,¡oq(_²,é"ÜtİUÌsªFu—[œ’È@!n’Æüá¸¨Ru¼»4®ãM*&I\r	£‹F½åK†½¥PF|½@ğ¦—-?)+…WÊï3\nĞôÓKêaéÎ»æ¥4Yûø÷Óÿ	ıïì;ƒv6)@3¢	3C5—%I“°D‘É%‚D‘\\×Õ¿âC™¯dŞ‘Ü¤û”ö<ˆ¼ĞÚ?ŠóäWÅL«ÌxJ’äÂw›ïf®öˆ*ÍæÇ¥LŞöñ²¢ğæ²Ëç²Û¦®Y(ÒéÁü:G6®Æ4Ã\nS5´·ÃÏÛ\n:iMoB¬R«µëeö›0ÂH³˜EE±ó~ñ’z…öGnÃåø•Øyg*Ûø@íŒ?,ƒ€pjrY¤#\nÄÛ‡«Ÿd_™{Ü¦±¸ije”[§Œ²)Ó#Èæ­<kÃ6õL;=²Úewí*]Íá„ÚªG¼Ê±Î¶$ÔŞòˆX0àólîmàá#ÆÁÿM´0‚ê;>6qº¸Fß76¶ÿûıOƒê°`’‰ÎUª m“Ç®û	ğÂÃ7Å‡¤ã°Á[’B†ÌŠ\\ñˆ‡HwDÚNC›¶¨„‡D?…@À™q“®#,TW4síµL;¸›ENET˜2pğ4é	^;Ê×¾fÅr«&K6’¡e|LËøï_!F¹Àˆàˆl=Ât(Òë1hØÊáz¥™óöaªÃ%2°–íäÚS”GIl”Ê0Ø¨êÜ„Œ¹à°‰üĞ)æUOZ]2€º849á5D¯(„c}h‰OdLöŸ &±l­ç‡6s¶!nn"®œi«ÕCÜãG\n‰CDsÓZºÍ(Y(fr“¼>œ:8Ä Y¯†PÉ’ÍıtŠÒíó¤PHáÌ|;z‡×EáËaÁlaôfÎıÄ”râ§eÅ¿Q›Õw…<Šx’Ñ‹t¬ûƒl³Üëâ?ëè¾FÑ<^<¤åÉ\'ç#ç/‚\\\nåªØ¯¥&ÿRvê˜r•ş¼İI"a„½*¾½(ºPT;²YçÏÕ^“ç\'ãë…³Ë<ffı6£Ô,…?9*Ãd‹.xšè1¼›ã\000Û`',6818 if"ä"~="\xE4"then local a=assert(fs.open(shell.getRunningProgram(),"rb"))local b=a.readAll()a.close()return assert(load(b,"@"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error("File corrupted (expected "..size..", got "..#disk..")")end;local c=require"cc.expect"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),""repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,"invalid chunk")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error("invalid chunk")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch("[^/]+")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)=="table"and""or O elseif type(O)~="table"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match("^"..aj:gsub("([%%%.])","%%%1"):gsub("%*","%.%*").."$")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or""if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)=="string"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak.."/"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if type(ad)~="table"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch("[^/]+")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,"string")local ad=ac(disk,ae)return type(ad)=="table"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,"string")if ac(disk,ae)~=nil then return"mem"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)=="table"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,"string")c(2,ao,"string")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao=="r"then if type(ad)~="string"then return nil,"Is a directory"end;local ap=ad;ad=""for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and"?"or string.char(a7))end;ad=ad:gsub("\r\n","\n")local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error("file is already closed",2)end;if A>#ad then return end;c(1,au,"number","nil")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error("file is already closed",2)end;aq=true end}elseif ao=="w"or ao=="a"then return nil,"Permission denied"elseif ao=="rb"then if type(ad)~="string"then return nil,"Is a directory"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,"number","nil")if aq then error("file is already closed",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error("file is already closed",2)end;aq=true end,seek=function(av,aw)if aq then error("file is already closed",2)end;c(1,av,"string","nil")c(2,aw,"number","nil")av=av or"cur"aw=aw or 0;if av=="set"then A=aw+1 elseif av=="cur"then A=A+aw elseif av=="end"then A=#ad-aw else error("bad argument #1 (invalid option "..av..")",2)end;return A end}elseif ao=="wb"or ao=="ab"then return nil,"Permission denied"else return nil,"Invalid mode"end end,find=function(ax)c(1,ax,"string")local ag={}for M in ax:gmatch("[^/]+")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)=="table"and 0 or#ad,isDir=type(ad)=="table",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,"/init.lua")_G.fs=fs;if not ay then printError(az)end

-- End of File: appData/StackBank/app

-- File: appData/StackBank/data
{
  "StackBank",
  "StackBank",
  "timuzkas",
  "v0.4",
}
-- End of File: appData/StackBank/data

-- File: bigfont
-------------------------------------------------------------------------------------
-- Wojbies API 5.0 - Bigfont - functions to write bigger font using drawing sybols --
-------------------------------------------------------------------------------------
--   Copyright (c) 2015-2022 Wojbie (wojbie@wojbie.net)
--   Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met:
--   1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
--   2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
--   3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
--   4. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
--   5. The origin of this software must not be misrepresented; you must not claim that you wrote the original software.
--   NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY NUCLEAR FACILITY.

--Switch to true to replace generic currency sign "\164" with krist symbol.
local krist = false

--### Initializing
local b = shell and {} or (_ENV or getfenv())
b.versionName = "Bigfont By Wojbie"
b.versionNum = 5.003 --2021-07-21
b.doc = {}

local expect, field if require then expect, field = require "cc.expect".expect, require "cc.expect".field else local ok, did = pcall(dofile,"rom/modules/main/cc/expect.lua") if ok then field, expect = did.field, did.expect else field, expect = function() end, function() end end end

--### Font database
local rawFont = {{"\32\32\32\137\156\148\158\159\148\135\135\144\159\139\32\136\157\32\159\139\32\32\143\32\32\143\32\32\32\32\32\32\32\32\147\148\150\131\148\32\32\32\151\140\148\151\140\147", "\32\32\32\149\132\149\136\156\149\144\32\133\139\159\129\143\159\133\143\159\133\138\32\133\138\32\133\32\32\32\32\32\32\150\150\129\137\156\129\32\32\32\133\131\129\133\131\132", "\32\32\32\130\131\32\130\131\32\32\129\32\32\32\32\130\131\32\130\131\32\32\32\32\143\143\143\32\32\32\32\32\32\130\129\32\130\135\32\32\32\32\131\32\32\131\32\131", "\139\144\32\32\143\148\135\130\144\149\32\149\150\151\149\158\140\129\32\32\32\135\130\144\135\130\144\32\149\32\32\139\32\159\148\32\32\32\32\159\32\144\32\148\32\147\131\132", "\159\135\129\131\143\149\143\138\144\138\32\133\130\149\149\137\155\149\159\143\144\147\130\132\32\149\32\147\130\132\131\159\129\139\151\129\148\32\32\139\131\135\133\32\144\130\151\32", "\32\32\32\32\32\32\130\135\32\130\32\129\32\129\129\131\131\32\130\131\129\140\141\132\32\129\32\32\129\32\32\32\32\32\32\32\131\131\129\32\32\32\32\32\32\32\32\32", "\32\32\32\32\149\32\159\154\133\133\133\144\152\141\132\133\151\129\136\153\32\32\154\32\159\134\129\130\137\144\159\32\144\32\148\32\32\32\32\32\32\32\32\32\32\32\151\129", "\32\32\32\32\133\32\32\32\32\145\145\132\141\140\132\151\129\144\150\146\129\32\32\32\138\144\32\32\159\133\136\131\132\131\151\129\32\144\32\131\131\129\32\144\32\151\129\32", "\32\32\32\32\129\32\32\32\32\130\130\32\32\129\32\129\32\129\130\129\129\32\32\32\32\130\129\130\129\32\32\32\32\32\32\32\32\133\32\32\32\32\32\129\32\129\32\32", "\150\156\148\136\149\32\134\131\148\134\131\148\159\134\149\136\140\129\152\131\32\135\131\149\150\131\148\150\131\148\32\148\32\32\148\32\32\152\129\143\143\144\130\155\32\134\131\148", "\157\129\149\32\149\32\152\131\144\144\131\148\141\140\149\144\32\149\151\131\148\32\150\32\150\131\148\130\156\133\32\144\32\32\144\32\130\155\32\143\143\144\32\152\129\32\134\32", "\130\131\32\131\131\129\131\131\129\130\131\32\32\32\129\130\131\32\130\131\32\32\129\32\130\131\32\130\129\32\32\129\32\32\133\32\32\32\129\32\32\32\130\32\32\32\129\32", "\150\140\150\137\140\148\136\140\132\150\131\132\151\131\148\136\147\129\136\147\129\150\156\145\138\143\149\130\151\32\32\32\149\138\152\129\149\32\32\157\152\149\157\144\149\150\131\148", "\149\143\142\149\32\149\149\32\149\149\32\144\149\32\149\149\32\32\149\32\32\149\32\149\149\32\149\32\149\32\144\32\149\149\130\148\149\32\32\149\32\149\149\130\149\149\32\149", "\130\131\129\129\32\129\131\131\32\130\131\32\131\131\32\131\131\129\129\32\32\130\131\32\129\32\129\130\131\32\130\131\32\129\32\129\131\131\129\129\32\129\129\32\129\130\131\32", "\136\140\132\150\131\148\136\140\132\153\140\129\131\151\129\149\32\149\149\32\149\149\32\149\137\152\129\137\152\129\131\156\133\149\131\32\150\32\32\130\148\32\152\137\144\32\32\32", "\149\32\32\149\159\133\149\32\149\144\32\149\32\149\32\149\32\149\150\151\129\138\155\149\150\130\148\32\149\32\152\129\32\149\32\32\32\150\32\32\149\32\32\32\32\32\32\32", "\129\32\32\130\129\129\129\32\129\130\131\32\32\129\32\130\131\32\32\129\32\129\32\129\129\32\129\32\129\32\131\131\129\130\131\32\32\32\129\130\131\32\32\32\32\140\140\132", "\32\154\32\159\143\32\149\143\32\159\143\32\159\144\149\159\143\32\159\137\145\159\143\144\149\143\32\32\145\32\32\32\145\149\32\144\32\149\32\143\159\32\143\143\32\159\143\32", "\32\32\32\152\140\149\151\32\149\149\32\145\149\130\149\157\140\133\32\149\32\154\143\149\151\32\149\32\149\32\144\32\149\149\153\32\32\149\32\149\133\149\149\32\149\149\32\149", "\32\32\32\130\131\129\131\131\32\130\131\32\130\131\129\130\131\129\32\129\32\140\140\129\129\32\129\32\129\32\137\140\129\130\32\129\32\130\32\129\32\129\129\32\129\130\131\32", "\144\143\32\159\144\144\144\143\32\159\143\144\159\138\32\144\32\144\144\32\144\144\32\144\144\32\144\144\32\144\143\143\144\32\150\129\32\149\32\130\150\32\134\137\134\134\131\148", "\136\143\133\154\141\149\151\32\129\137\140\144\32\149\32\149\32\149\154\159\133\149\148\149\157\153\32\154\143\149\159\134\32\130\148\32\32\149\32\32\151\129\32\32\32\32\134\32", "\133\32\32\32\32\133\129\32\32\131\131\32\32\130\32\130\131\129\32\129\32\130\131\129\129\32\129\140\140\129\131\131\129\32\130\129\32\129\32\130\129\32\32\32\32\32\129\32", "\32\32\32\32\149\32\32\149\32\32\32\32\32\32\32\32\149\32\32\149\32\32\32\32\32\32\32\32\149\32\32\149\32\32\32\32\32\32\32\32\149\32\32\149\32\32\32\32", "\32\32\32\32\32\32\32\32\32\32\32\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\32\32\32\32\32\32\32\32\32\32\32", "\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32\32", "\32\32\32\32\149\32\32\149\32\32\32\32\32\32\32\32\149\32\32\149\32\32\32\32\32\32\32\32\149\32\32\149\32\32\32\32\32\32\32\32\149\32\32\149\32\32\32\32", "\32\32\32\32\32\32\32\32\32\32\32\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\32\32\32\32\32\32\32\32\32\32\32", "\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32\32\149\32", "\32\32\32\32\145\32\159\139\32\151\131\132\155\143\132\134\135\145\32\149\32\158\140\129\130\130\32\152\147\155\157\134\32\32\144\144\32\32\32\32\32\32\152\131\155\131\131\129", "\32\32\32\32\149\32\149\32\145\148\131\32\149\32\149\140\157\132\32\148\32\137\155\149\32\32\32\149\154\149\137\142\32\153\153\32\131\131\149\131\131\129\149\135\145\32\32\32", "\32\32\32\32\129\32\130\135\32\131\131\129\134\131\132\32\129\32\32\129\32\131\131\32\32\32\32\130\131\129\32\32\32\32\129\129\32\32\32\32\32\32\130\131\129\32\32\32", "\150\150\32\32\148\32\134\32\32\132\32\32\134\32\32\144\32\144\150\151\149\32\32\32\32\32\32\145\32\32\152\140\144\144\144\32\133\151\129\133\151\129\132\151\129\32\145\32", "\130\129\32\131\151\129\141\32\32\142\32\32\32\32\32\149\32\149\130\149\149\32\143\32\32\32\32\142\132\32\154\143\133\157\153\132\151\150\148\151\158\132\151\150\148\144\130\148", "\32\32\32\140\140\132\32\32\32\32\32\32\32\32\32\151\131\32\32\129\129\32\32\32\32\134\32\32\32\32\32\32\32\129\129\32\129\32\129\129\130\129\129\32\129\130\131\32", "\156\143\32\159\141\129\153\140\132\153\137\32\157\141\32\159\142\32\150\151\129\150\131\132\140\143\144\143\141\145\137\140\148\141\141\144\157\142\32\159\140\32\151\134\32\157\141\32", "\157\140\149\157\140\149\157\140\149\157\140\149\157\140\149\157\140\149\151\151\32\154\143\132\157\140\32\157\140\32\157\140\32\157\140\32\32\149\32\32\149\32\32\149\32\32\149\32", "\129\32\129\129\32\129\129\32\129\129\32\129\129\32\129\129\32\129\129\131\129\32\134\32\131\131\129\131\131\129\131\131\129\131\131\129\130\131\32\130\131\32\130\131\32\130\131\32", "\151\131\148\152\137\145\155\140\144\152\142\145\153\140\132\153\137\32\154\142\144\155\159\132\150\156\148\147\32\144\144\130\145\136\137\32\146\130\144\144\130\145\130\136\32\151\140\132", "\151\32\149\151\155\149\149\32\149\149\32\149\149\32\149\149\32\149\149\32\149\152\137\144\157\129\149\149\32\149\149\32\149\149\32\149\149\32\149\130\150\32\32\157\129\149\32\149", "\131\131\32\129\32\129\130\131\32\130\131\32\130\131\32\130\131\32\130\131\32\32\32\32\130\131\32\130\131\32\130\131\32\130\131\32\130\131\32\32\129\32\130\131\32\133\131\32", "\156\143\32\159\141\129\153\140\132\153\137\32\157\141\32\159\142\32\159\159\144\152\140\144\156\143\32\159\141\129\153\140\132\157\141\32\130\145\32\32\147\32\136\153\32\130\146\32", "\152\140\149\152\140\149\152\140\149\152\140\149\152\140\149\152\140\149\149\157\134\154\143\132\157\140\133\157\140\133\157\140\133\157\140\133\32\149\32\32\149\32\32\149\32\32\149\32", "\130\131\129\130\131\129\130\131\129\130\131\129\130\131\129\130\131\129\130\130\131\32\134\32\130\131\129\130\131\129\130\131\129\130\131\129\32\129\32\32\129\32\32\129\32\32\129\32", "\159\134\144\137\137\32\156\143\32\159\141\129\153\140\132\153\137\32\157\141\32\32\132\32\159\143\32\147\32\144\144\130\145\136\137\32\146\130\144\144\130\145\130\138\32\146\130\144", "\149\32\149\149\32\149\149\32\149\149\32\149\149\32\149\149\32\149\149\32\149\131\147\129\138\134\149\149\32\149\149\32\149\149\32\149\149\32\149\154\143\149\32\157\129\154\143\149", "\130\131\32\129\32\129\130\131\32\130\131\32\130\131\32\130\131\32\130\131\32\32\32\32\130\131\32\130\131\129\130\131\129\130\131\129\130\131\129\140\140\129\130\131\32\140\140\129" }, {[[000110000110110000110010101000000010000000100101]], [[000000110110000000000010101000000010000000100101]], [[000000000000000000000000000000000000000000000000]], [[100010110100000010000110110000010100000100000110]], [[000000110000000010110110000110000000000000110000]], [[000000000000000000000000000000000000000000000000]], [[000000110110000010000000100000100000000000000010]], [[000000000110110100010000000010000000000000000100]], [[000000000000000000000000000000000000000000000000]], [[010000000000100110000000000000000000000110010000]], [[000000000000000000000000000010000000010110000000]], [[000000000000000000000000000000000000000000000000]], [[011110110000000100100010110000000100000000000000]], [[000000000000000000000000000000000000000000000000]], [[000000000000000000000000000000000000000000000000]], [[110000110110000000000000000000010100100010000000]], [[000010000000000000110110000000000100010010000000]], [[000000000000000000000000000000000000000000000000]], [[010110010110100110110110010000000100000110110110]], [[000000000000000000000110000000000110000000000000]], [[000000000000000000000000000000000000000000000000]], [[010100010110110000000000000000110000000010000000]], [[110110000000000000110000110110100000000010000000]], [[000000000000000000000000000000000000000000000000]], [[000100011111000100011111000100011111000100011111]], [[000000000000100100100100011011011011111111111111]], [[000000000000000000000000000000000000000000000000]], [[000100011111000100011111000100011111000100011111]], [[000000000000100100100100011011011011111111111111]], [[100100100100100100100100100100100100100100100100]], [[000000110100110110000010000011110000000000011000]], [[000000000100000000000010000011000110000000001000]], [[000000000000000000000000000000000000000000000000]], [[010000100100000000000000000100000000010010110000]], [[000000000000000000000000000000110110110110110000]], [[000000000000000000000000000000000000000000000000]], [[110110110110110110000000110110110110110110110110]], [[000000000000000000000110000000000000000000000000]], [[000000000000000000000000000000000000000000000000]], [[000000000000110110000110010000000000000000010010]], [[000010000000000000000000000000000000000000000000]], [[000000000000000000000000000000000000000000000000]], [[110110110110110110110000110110110110000000000000]], [[000000000000000000000110000000000000000000000000]], [[000000000000000000000000000000000000000000000000]], [[110110110110110110110000110000000000000000010000]], [[000000000000000000000000100000000000000110000110]], [[000000000000000000000000000000000000000000000000]] }}

if krist then
    rawFont[1][31] = "\32\32\32\32\145\32\159\139\32\151\131\132\133\135\145\134\135\145\32\149\32\158\140\129\130\130\32\152\147\155\157\134\32\32\144\144\32\32\32\32\32\32\152\131\155\131\131\129"
    rawFont[1][32] = "\32\32\32\32\149\32\149\32\145\148\131\32\145\146\132\140\157\132\32\148\32\137\155\149\32\32\32\149\154\149\137\142\32\153\153\32\131\131\149\131\131\129\149\135\145\32\32\32"
    rawFont[1][33] = "\32\32\32\32\129\32\130\135\32\131\131\129\130\128\129\32\129\32\32\129\32\131\131\32\32\32\32\130\131\129\32\32\32\32\129\129\32\32\32\32\32\32\130\131\129\32\32\32"
    rawFont[2][32] = [[000000000100110000000010000011000110000000001000]]
end
--### Genarate fonts using 3x3 chars per a character. (1 character is 6x9 pixels)
local fonts = {}
local firstFont = {}
do
    local char = 0
    local height = #rawFont[1]
    local length = #rawFont[1][1]
    for i = 1, height, 3 do
        for j = 1, length, 3 do
            local thisChar = string.char(char)

            local temp = {}
            temp[1] = rawFont[1][i]:sub(j, j + 2)
            temp[2] = rawFont[1][i + 1]:sub(j, j + 2)
            temp[3] = rawFont[1][i + 2]:sub(j, j + 2)

            local temp2 = {}
            temp2[1] = rawFont[2][i]:sub(j, j + 2)
            temp2[2] = rawFont[2][i + 1]:sub(j, j + 2)
            temp2[3] = rawFont[2][i + 2]:sub(j, j + 2)

            firstFont[thisChar] = {temp, temp2}
            char = char + 1
        end
    end
    fonts[1] = firstFont
end

local function generateFontSize(size,yeld)
    local inverter = {["0"] = "1", ["1"] = "0"} --:gsub("[01]",inverter)
    if size<= #fonts then return true end
    for f = #fonts+1, size do
        --automagicly make bigger fonts using firstFont and fonts[f-1].
        local nextFont = {}
        local lastFont = fonts[f - 1]
        for char = 0, 255 do
            local thisChar = string.char(char)
            --sleep(0) print(f,thisChar)

            local temp = {}
            local temp2 = {}

            local templateChar = lastFont[thisChar][1]
            local templateBack = lastFont[thisChar][2]
            for i = 1, #templateChar do
                local line1, line2, line3, back1, back2, back3 = {}, {}, {}, {}, {}, {}
                for j = 1, #templateChar[1] do
                    local currentChar = firstFont[templateChar[i]:sub(j, j)][1]
                    table.insert(line1, currentChar[1])
                    table.insert(line2, currentChar[2])
                    table.insert(line3, currentChar[3])

                    local currentBack = firstFont[templateChar[i]:sub(j, j)][2]
                    if templateBack[i]:sub(j, j) == "1" then
                        table.insert(back1, (currentBack[1]:gsub("[01]", inverter)))
                        table.insert(back2, (currentBack[2]:gsub("[01]", inverter)))
                        table.insert(back3, (currentBack[3]:gsub("[01]", inverter)))
                    else
                        table.insert(back1, currentBack[1])
                        table.insert(back2, currentBack[2])
                        table.insert(back3, currentBack[3])
                    end
                end
                table.insert(temp, table.concat(line1))
                table.insert(temp, table.concat(line2))
                table.insert(temp, table.concat(line3))
                table.insert(temp2, table.concat(back1))
                table.insert(temp2, table.concat(back2))
                table.insert(temp2, table.concat(back3))
            end

            nextFont[thisChar] = {temp, temp2}
            if yeld then yeld = "Font"..f.."Yeld"..char os.queueEvent(yeld) os.pullEvent(yeld) end
        end
        fonts[f] = nextFont
    end
    return true
end

generateFontSize(3,false)

--## Use pre-generated fonts instead of old code above.

--local fonts = {}

local tHex = {[ colors.white ] = "0", [ colors.orange ] = "1", [ colors.magenta ] = "2", [ colors.lightBlue ] = "3", [ colors.yellow ] = "4", [ colors.lime ] = "5", [ colors.pink ] = "6", [ colors.gray ] = "7", [ colors.lightGray ] = "8", [ colors.cyan ] = "9", [ colors.purple ] = "a", [ colors.blue ] = "b", [ colors.brown ] = "c", [ colors.green ] = "d", [ colors.red ] = "e", [ colors.black ] = "f"}

--# Write data on terminal in specified location. Can scroll.
local function stamp(tTerminal, tData, nX, nY)

    local oX, oY = tTerminal.getSize()
    local cX, cY = #tData[1][1], #tData[1]
    nX = nX or math.floor((oX - cX) / 2) + 1
    nY = nY or math.floor((oY - cY) / 2) + 1

    for i = 1, cY do
        if i > 1 and nY + i - 1 > oY then term.scroll(1) nY = nY - 1 end
        tTerminal.setCursorPos(nX, nY + i - 1)
        tTerminal.blit(tData[1][i], tData[2][i], tData[3][i])
    end
end

--# Write data on terminal in specified location. No scroll.
local function press(tTerminal, tData, nX, nY)
    local oX, oY = tTerminal.getSize()
    local cX, cY = #tData[1][1], #tData[1]
    nX = nX or math.floor((oX - cX) / 2) + 1
    nY = nY or math.floor((oY - cY) / 2) + 1

    for i = 1, cY do
        tTerminal.setCursorPos(nX, nY + i - 1)
        tTerminal.blit(tData[1][i], tData[2][i], tData[3][i])
    end
end

--# Generate data from strings for data and colors.
local function makeText(nSize, sString, nFC, nBC, bBlit)
    if not type(sString) == "string" then error("Not a String",3) end --this should never happend with expects in place.
    local cFC = type(nFC) == "string" and nFC:sub(1, 1) or tHex[nFC] or error("Wrong Front Color",3)
    local cBC = type(nBC) == "string" and nBC:sub(1, 1) or tHex[nBC] or error("Wrong Back Color",3)
    local font = fonts[nSize] or error("Wrong font size selected",3)
    if sString == "" then return {{""}, {""}, {""}} end
    
    local input = {}
    for i in sString:gmatch('.') do table.insert(input, i) end

    local tText = {}
    local height = #font[input[1]][1]


    for nLine = 1, height do
        local outLine = {}
        for i = 1, #input do
            outLine[i] = font[input[i]] and font[input[i]][1][nLine] or ""
        end
        tText[nLine] = table.concat(outLine)
    end

    local tFront = {}
    local tBack = {}
    local tFrontSub = {["0"] = cFC, ["1"] = cBC}
    local tBackSub = {["0"] = cBC, ["1"] = cFC}

    for nLine = 1, height do
        local front = {}
        local back = {}
        for i = 1, #input do
            local template = font[input[i]] and font[input[i]][2][nLine] or ""
            front[i] = template:gsub("[01]", bBlit and {["0"] = nFC:sub(i, i), ["1"] = nBC:sub(i, i)} or tFrontSub)
            back[i] = template:gsub("[01]", bBlit and {["0"] = nBC:sub(i, i), ["1"] = nFC:sub(i, i)} or tBackSub)
        end
        tFront[nLine] = table.concat(front)
        tBack[nLine] = table.concat(back)
    end

    return {tText, tFront, tBack}
end

--# Writing in big font using current terminal settings.
b.bigWrite = function(sString)
    expect(1, sString, "string")
    stamp(term, makeText(1, sString, term.getTextColor(), term.getBackgroundColor()), term.getCursorPos())
    local x, y = term.getCursorPos()
    term.setCursorPos(x, y - 2)
end

b.bigBlit = function(sString, sFront, sBack)
    expect(1, sString, "string")
    expect(2, sFront, "string")
    expect(3, sBack, "string")
    if #sString ~= #sFront then error("Invalid length of text color string",2) end
    if #sString ~= #sBack then error("Invalid length of background color string",2) end
    stamp(term, makeText(1, sString, sFront, sBack, true), term.getCursorPos())
    local x, y = term.getCursorPos()
    term.setCursorPos(x, y - 2)
end

b.bigPrint = function(sString)
    expect(1, sString, "string")
    stamp(term, makeText(1, sString, term.getTextColor(), term.getBackgroundColor()), term.getCursorPos())
    print()
end

--# Writing in huge font using current terminal settings.
b.hugeWrite = function(sString)
    expect(1, sString, "string")
    stamp(term, makeText(2, sString, term.getTextColor(), term.getBackgroundColor()), term.getCursorPos())
    local x, y = term.getCursorPos()
    term.setCursorPos(x, y - 8)
end

b.hugeBlit = function(sString, sFront, sBack)
    expect(1, sString, "string")
    expect(2, sFront, "string")
    expect(3, sBack, "string")
    if #sString ~= #sFront then error("Invalid length of text color string",2) end
    if #sString ~= #sBack then error("Invalid length of background color string",2) end
    stamp(term, makeText(2, sString, sFront, sBack, true), term.getCursorPos())
    local x, y = term.getCursorPos()
    term.setCursorPos(x, y - 8)
end

b.hugePrint = function(sString)
    expect(1, sString, "string")
    stamp(term, makeText(2, sString, term.getTextColor(), term.getBackgroundColor()), term.getCursorPos())
    print()
end

--# Write/blit string on terminal in specified location
b.doc.writeOn = [[writeOn(tTerminal, nSize, sString, [nX], [nY]) - Writes sString on tTerminal using current tTerminal colours. nX, nY are coordinates. If any of them are nil then text is centered in that axis using tTerminal size.]]
b.writeOn = function(tTerminal, nSize, sString, nX, nY)
    expect(1, tTerminal, "table")
    field(tTerminal, "getSize", "function")
    field(tTerminal, "scroll", "function")
    field(tTerminal, "setCursorPos", "function")
    field(tTerminal, "blit", "function")
    field(tTerminal, "getTextColor", "function")
    field(tTerminal, "getBackgroundColor", "function")
    expect(2, nSize, "number")
    expect(3, sString, "string")
    expect(4, nX, "number", "nil")
    expect(5, nY, "number", "nil")
    press(tTerminal, makeText(nSize, sString, tTerminal.getTextColor(), tTerminal.getBackgroundColor()), nX, nY)
end

b.doc.blitOn = [[writeOn(tTerminal, nSize, sString, sFront, sBack, [nX], [nY]) - Blits sString on tTerminal with sFront and sBack colors . nX, nY are coordinates. If any of them are nil then text is centered in that axis using tTerminal size.]]
b.blitOn = function(tTerminal, nSize, sString, sFront, sBack, nX, nY)
    expect(1, tTerminal, "table")
    field(tTerminal, "getSize", "function")
    field(tTerminal, "scroll", "function")
    field(tTerminal, "setCursorPos", "function")
    field(tTerminal, "blit", "function")
    expect(2, nSize, "number")
    expect(3, sString, "string")
    expect(4, sFront, "string")
    expect(5, sBack, "string")
    if #sString ~= #sFront then error("Invalid length of text color string",2) end
    if #sString ~= #sBack then error("Invalid length of background color string",2) end
    expect(6, nX, "number", "nil")
    expect(7, nY, "number", "nil")
    press(tTerminal, makeText(nSize, sString, sFront, sBack, true), nX, nY)
end

--# 
b.doc.makeBlittleText = [[makeBlittleText(nSize, sString, nFC, nBC) - Generate blittle object in size nSize with text sString in blittle format for printing with that api. nFC and nBC are colors to generate the object with.]]
b.makeBlittleText = function(nSize, sString, nFC, nBC)
    expect(1, nSize, "number")
    expect(2, sString, "string")
    expect(3, nFC, "number")
    expect(4, nBC, "number")
    local out = makeText(nSize, sString, nFC, nBC)
    out.height = #out[1]
    out.width = #out[1][1]
    return out
end

b.doc.generateFontSize = [[generateFontSize(size) - Generates bigger font sizes and enables then on other functions that accept size argument. By default bigfont loads sizes 1-3 as those can be generated without yielding. Using this user can generate sizes 4-6. Warning: This function will internally yield.]]
b.generateFontSize = function(size)
    expect(1, size, "number")
    if type(size) ~= "number" then error("Size needs to be a number",2) end
    if size > 6 then return false end
    return generateFontSize(math.floor(size),true)
end

--### Finalizing
return b
-- End of File: bigfont

-- File: config/configManager
os.loadAPI("system/b64")


local function encode(str)
  return b64.encode(str)
end
local function decode(str)
  return b64.decode(str)
end

local function readFromConfig(variable)
  local file = io.open("config/"..variable, "r")
  if file then
    value = file:read("*a")
	value = decode(value)
	file:close()
    return value
  else
    return nil
  end
end

local function setToConfig(variable, value)
  local file = io.open("config/"..variable, "w")
  if file then
    if value ~= nil then
		value = encode(value)
		value = file:write(value)
	    file:close()
	else
	  file:close()
	  fs.delete("config/"..variable)
	end
  else	
    return nil
  end
end

return { readFromConfig = readFromConfig, setToConfig = setToConfig }
-- End of File: config/configManager

-- File: config/nfc_menu_opened
bm8=
-- End of File: config/nfc_menu_opened

-- File: config/nfc_menu_opened_now
bm8=
-- End of File: config/nfc_menu_opened_now

-- File: config/nfc_toggle
bm8=
-- End of File: config/nfc_toggle

-- File: config/pin_toggle
eWVz
-- End of File: config/pin_toggle

-- File: files/cEdit
-- SPDX-FileCopyrightText: 2017 Daniel Ratcliffe
--
-- SPDX-License-Identifier: LicenseRef-CCPL

-- Get file to edit
local tArgs = { ... }
if #tArgs == 0 then
    local programName = arg[0] or fs.getName(shell.getRunningProgram())
    print("Usage: " .. programName .. " <path>")
    return
end

-- Error checking
local sPath = shell.resolve(tArgs[1])
local bReadOnly = fs.isReadOnly(sPath)
if fs.exists(sPath) and fs.isDir(sPath) then
    print("Cannot edit a directory.")
    return
end

-- Create .lua files by default
if not fs.exists(sPath) and not string.find(sPath, "%.") then
    local sExtension = settings.get("edit.default_extension")
    if sExtension ~= "" and type(sExtension) == "string" then
        sPath = sPath .. "." .. sExtension
    end
end

local x, y = 1, 1
local w, h = term.getSize()
local scrollX, scrollY = 0, 0

local tLines = {}
local bRunning = true

-- Colours
local highlightColour, keywordColour, commentColour, textColour, bgColour, stringColour, errorColour
if term.isColour() then
    bgColour = colours.black
    textColour = colours.white
    highlightColour = colours.yellow
    keywordColour = colours.yellow
    commentColour = colours.green
    stringColour = colours.red
    errorColour = colours.red
else
    bgColour = colours.black
    textColour = colours.white
    highlightColour = colours.white
    keywordColour = colours.white
    commentColour = colours.white
    stringColour = colours.white
    errorColour = colours.white
end

local runHandler = [[multishell.setTitle(multishell.getCurrent(), %q)
local current = term.current()
local contents, name = %q, %q
local fn, err = load(contents, name, nil, _ENV)
if fn then
    local exception = require "cc.internal.exception"
    local ok, err, co = exception.try(fn, ...)

    term.redirect(current)
    term.setTextColor(term.isColour() and colours.yellow or colours.white)
    term.setBackgroundColor(colours.black)
    term.setCursorBlink(false)

    if not ok then
        printError(err)
        exception.report(err, co, { [name] = contents })
    end
else
    local parser = require "cc.internal.syntax"
    if parser.parse_program(contents) then printError(err) end
end

local message = "Press any key to continue."
if ok then message = "Program finished. " .. message end
local _, y = term.getCursorPos()
local w, h = term.getSize()
local wrapped = require("cc.strings").wrap(message, w)

local start_y = h - #wrapped + 1
if y >= start_y then term.scroll(y - start_y + 1) end
for i = 1, #wrapped do
    term.setCursorPos(1, start_y + i - 1)
    term.write(wrapped[i])
end
os.pullEvent('key')
]]

-- Menus
local bMenu = false
local nMenuItem = 1
local tMenuItems = {}
if not bReadOnly then
    table.insert(tMenuItems, "Save")
end
if shell.openTab then
    table.insert(tMenuItems, "Exit to run")
end
if peripheral.find("printer") then
    table.insert(tMenuItems, "Print")
end
table.insert(tMenuItems, "Exit")

local status_ok, status_text
local function set_status(text, ok)
    status_ok = ok ~= false
    status_text = text
end

if bReadOnly then
    set_status("File is read only", false)
elseif fs.getFreeSpace(sPath) < 1024 then
    set_status("Disk is low on space", false)
else
    local message
    if term.isColour() then
        message = "Press Ctrl or click here to access menu"
    else
        message = "Press Ctrl to access menu"
    end

    if #message > w - 5 then
        message = "Press Ctrl for menu"
    end

    set_status(message)
end

local function load(_sPath)
    tLines = {}
    if fs.exists(_sPath) then
        local file = io.open(_sPath, "r")
        local sLine = file:read()
        while sLine do
            table.insert(tLines, sLine)
            sLine = file:read()
        end
        file:close()
    end

    if #tLines == 0 then
        table.insert(tLines, "")
    end
end

local function save(_sPath, fWrite)
    -- Create intervening folder
    local sDir = _sPath:sub(1, _sPath:len() - fs.getName(_sPath):len())
    if not fs.exists(sDir) then
        fs.makeDir(sDir)
    end

    -- Save
    local file, fileerr
    local function innerSave()
        file, fileerr = fs.open(_sPath, "w")
        if file then
            if file then
                fWrite(file)
            end
        else
            error("Failed to open " .. _sPath)
        end
    end

    local ok, err = pcall(innerSave)
    if file then
        file.close()
    end
    return ok, err, fileerr
end

local tKeywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function tryWrite(sLine, regex, colour)
    local match = string.match(sLine, regex)
    if match then
        if type(colour) == "number" then
            term.setTextColour(colour)
        else
            term.setTextColour(colour(match))
        end
        term.write(match)
        term.setTextColour(textColour)
        return string.sub(sLine, #match + 1)
    end
    return nil
end

local function writeHighlighted(sLine)
    while #sLine > 0 do
        sLine =
            tryWrite(sLine, "^%-%-%[%[.-%]%]", commentColour) or
            tryWrite(sLine, "^%-%-.*", commentColour) or
            tryWrite(sLine, "^\"\"", stringColour) or
            tryWrite(sLine, "^\".-[^\\]\"", stringColour) or
            tryWrite(sLine, "^\'\'", stringColour) or
            tryWrite(sLine, "^\'.-[^\\]\'", stringColour) or
            tryWrite(sLine, "^%[%[.-%]%]", stringColour) or
            tryWrite(sLine, "^[%w_]+", function(match)
                if tKeywords[match] then
                    return keywordColour
                end
                return textColour
            end) or
            tryWrite(sLine, "^[^%w_]", textColour)
    end
end

local tCompletions
local nCompletion

local tCompleteEnv = _ENV
local function complete(sLine)
    if settings.get("edit.autocomplete") then
        local nStartPos = string.find(sLine, "[a-zA-Z0-9_%.:]+$")
        if nStartPos then
            sLine = string.sub(sLine, nStartPos)
        end
        if #sLine > 0 then
            return textutils.complete(sLine, tCompleteEnv)
        end
    end
    return nil
end

local function recomplete()
    local sLine = tLines[y]
    if not bMenu and not bReadOnly and x == #sLine + 1 then
        tCompletions = complete(sLine)
        if tCompletions and #tCompletions > 0 then
            nCompletion = 1
        else
            nCompletion = nil
        end
    else
        tCompletions = nil
        nCompletion = nil
    end
end

local function writeCompletion(sLine)
    if nCompletion then
        local sCompletion = tCompletions[nCompletion]
        term.setTextColor(colours.white)
        term.setBackgroundColor(colours.grey)
        term.write(sCompletion)
        term.setTextColor(textColour)
        term.setBackgroundColor(bgColour)
    end
end

local function redrawText()
    local cursorX, cursorY = x, y
    for y = 1, h - 1 do
        term.setCursorPos(1 - scrollX, y)
        term.clearLine()

        local sLine = tLines[y + scrollY]
        if sLine ~= nil then
            writeHighlighted(sLine)
            if cursorY == y and cursorX == #sLine + 1 then
                writeCompletion()
            end
        end
    end
    term.setCursorPos(x - scrollX, y - scrollY)
end

local function redrawLine(_nY)
    local sLine = tLines[_nY]
    if sLine then
        term.setCursorPos(1 - scrollX, _nY - scrollY)
        term.clearLine()
        writeHighlighted(sLine)
        if _nY == y and x == #sLine + 1 then
            writeCompletion()
        end
        term.setCursorPos(x - scrollX, _nY - scrollY)
    end
end

local function redrawMenu()
    -- Clear line
    term.setCursorPos(1, h)
    term.clearLine()

    -- Draw line numbers
    term.setCursorPos(w - #("Ln " .. y) + 1, h)
    term.setTextColour(highlightColour)
    term.write("Ln ")
    term.setTextColour(textColour)
    term.write(y)

    term.setCursorPos(1, h)
    if bMenu then
        -- Draw menu
        term.setTextColour(textColour)
        for nItem, sItem in pairs(tMenuItems) do
            if nItem == nMenuItem then
                term.setTextColour(highlightColour)
                term.write("[")
                term.setTextColour(textColour)
                term.write(sItem)
                term.setTextColour(highlightColour)
                term.write("]")
                term.setTextColour(textColour)
            else
                term.write(" " .. sItem .. " ")
            end
        end
    else
        -- Draw status
        term.setTextColour(status_ok and highlightColour or errorColour)
        term.write(status_text)
        term.setTextColour(textColour)
    end

    -- Reset cursor
    term.setCursorPos(x - scrollX, y - scrollY)
end

local tMenuFuncs = {
    Save = function()
        if bReadOnly then
            set_status("Access denied", false)
        else
            local ok, _, fileerr  = save(sPath, function(file)
                for _, sLine in ipairs(tLines) do
                    file.write(sLine .. "\n")
                end
            end)
            if ok then
                set_status("Saved to " .. sPath)
            else
                if fileerr then
                    set_status("Error saving: " .. fileerr, false)
                else
                    set_status("Error saving to " .. sPath, false)
                end
            end
        end
        redrawMenu()
    end,
    Print = function()
        local printer = peripheral.find("printer")
        if not printer then
            set_status("No printer attached", false)
            return
        end

        local nPage = 0
        local sName = fs.getName(sPath)
        if printer.getInkLevel() < 1 then
            set_status("Printer out of ink", false)
            return
        elseif printer.getPaperLevel() < 1 then
            set_status("Printer out of paper", false)
            return
        end

        local screenTerminal = term.current()
        local printerTerminal = {
            getCursorPos = printer.getCursorPos,
            setCursorPos = printer.setCursorPos,
            getSize = printer.getPageSize,
            write = printer.write,
        }
        printerTerminal.scroll = function()
            if nPage == 1 then
                printer.setPageTitle(sName .. " (page " .. nPage .. ")")
            end

            while not printer.newPage() do
                if printer.getInkLevel() < 1 then
                    set_status("Printer out of ink, please refill", false)
                elseif printer.getPaperLevel() < 1 then
                    set_status("Printer out of paper, please refill", false)
                else
                    set_status("Printer output tray full, please empty", false)
                end

                term.redirect(screenTerminal)
                redrawMenu()
                term.redirect(printerTerminal)

                sleep(0.5)
            end

            nPage = nPage + 1
            if nPage == 1 then
                printer.setPageTitle(sName)
            else
                printer.setPageTitle(sName .. " (page " .. nPage .. ")")
            end
        end

        bMenu = false
        term.redirect(printerTerminal)
        local ok, error = pcall(function()
            term.scroll()
            for _, sLine in ipairs(tLines) do
                print(sLine)
            end
        end)
        term.redirect(screenTerminal)
        if not ok then
            print(error)
        end

        while not printer.endPage() do
            set_status("Printer output tray full, please empty")
            redrawMenu()
            sleep(0.5)
        end
        bMenu = true

        if nPage > 1 then
            set_status("Printed " .. nPage .. " Pages")
        else
            set_status("Printed 1 Page")
        end
        redrawMenu()
    end,
    Exit = function()
        bRunning = false
    end,
    Run = function()
        local sTitle = fs.getName(sPath)
        if sTitle:sub(-4) == ".lua" then
            sTitle = sTitle:sub(1, -5)
        end
        local sTempPath = bReadOnly and ".temp." .. sTitle or fs.combine(fs.getDir(sPath), ".temp." .. sTitle)
        if fs.exists(sTempPath) then
            set_status("Error saving to " .. sTempPath, false)
            return
        end
        local ok = save(sTempPath, function(file)
            file.write(runHandler:format(sTitle, table.concat(tLines, "\n"), "@/" .. sPath))
        end)
        if ok then
            local nTask = shell.openTab("/" .. sTempPath)
            if nTask then
                shell.switchTab(nTask)
            else
                set_status("Error starting Task", false)
            end
            fs.delete(sTempPath)
        else
            set_status("Error saving to " .. sTempPath, false)
        end
        redrawMenu()
    end,
}

local function doMenuItem(_n)
    if _n == 2 then 
	
	else
		print(_n)
		tMenuFuncs[tMenuItems[_n]]()
    end
	if bMenu then
        bMenu = false
        term.setCursorBlink(true)
    end
    redrawMenu()
end

local function setCursor(newX, newY)
    local _, oldY = x, y
    x, y = newX, newY
    local screenX = x - scrollX
    local screenY = y - scrollY

    local bRedraw = false
    if screenX < 1 then
        scrollX = x - 1
        screenX = 1
        bRedraw = true
    elseif screenX > w then
        scrollX = x - w
        screenX = w
        bRedraw = true
    end

    if screenY < 1 then
        scrollY = y - 1
        screenY = 1
        bRedraw = true
    elseif screenY > h - 1 then
        scrollY = y - (h - 1)
        screenY = h - 1
        bRedraw = true
    end

    recomplete()
    if bRedraw then
        redrawText()
    elseif y ~= oldY then
        redrawLine(oldY)
        redrawLine(y)
    else
        redrawLine(y)
    end
    term.setCursorPos(screenX, screenY)

    redrawMenu()
end

-- Actual program functionality begins
load(sPath)

term.setBackgroundColour(bgColour)
term.clear()
term.setCursorPos(x, y)
term.setCursorBlink(true)

recomplete()
redrawText()
redrawMenu()

local function acceptCompletion()
    if nCompletion then
        -- Append the completion
        local sCompletion = tCompletions[nCompletion]
        tLines[y] = tLines[y] .. sCompletion
        setCursor(x + #sCompletion , y)
    end
end

-- Handle input
while bRunning do
    local sEvent, param, param2, param3 = os.pullEvent()
    if sEvent == "key" then
        if param == keys.up then
            -- Up
            if not bMenu then
                if nCompletion then
                    -- Cycle completions
                    nCompletion = nCompletion - 1
                    if nCompletion < 1 then
                        nCompletion = #tCompletions
                    end
                    redrawLine(y)

                elseif y > 1 then
                    -- Move cursor up
                    setCursor(
                        math.min(x, #tLines[y - 1] + 1),
                        y - 1
                    )
                end
            end

        elseif param == keys.down then
            -- Down
            if not bMenu then
                -- Move cursor down
                if nCompletion then
                    -- Cycle completions
                    nCompletion = nCompletion + 1
                    if nCompletion > #tCompletions then
                        nCompletion = 1
                    end
                    redrawLine(y)

                elseif y < #tLines then
                    -- Move cursor down
                    setCursor(
                        math.min(x, #tLines[y + 1] + 1),
                        y + 1
                    )
                end
            end

        elseif param == keys.tab then
            -- Tab
            if not bMenu and not bReadOnly then
                if nCompletion and x == #tLines[y] + 1 then
                    -- Accept autocomplete
                    acceptCompletion()
                else
                    -- Indent line
                    local sLine = tLines[y]
                    tLines[y] = string.sub(sLine, 1, x - 1) .. "    " .. string.sub(sLine, x)
                    setCursor(x + 4, y)
                end
            end

        elseif param == keys.pageUp then
            -- Page Up
            if not bMenu then
                -- Move up a page
                local newY
                if y - (h - 1) >= 1 then
                    newY = y - (h - 1)
                else
                    newY = 1
                end
                setCursor(
                    math.min(x, #tLines[newY] + 1),
                    newY
                )
            end

        elseif param == keys.pageDown then
            -- Page Down
            if not bMenu then
                -- Move down a page
                local newY
                if y + (h - 1) <= #tLines then
                    newY = y + (h - 1)
                else
                    newY = #tLines
                end
                local newX = math.min(x, #tLines[newY] + 1)
                setCursor(newX, newY)
            end

        elseif param == keys.home then
            -- Home
            if not bMenu then
                -- Move cursor to the beginning
                if x > 1 then
                    setCursor(1, y)
                end
            end

        elseif param == keys["end"] then
            -- End
            if not bMenu then
                -- Move cursor to the end
                local nLimit = #tLines[y] + 1
                if x < nLimit then
                    setCursor(nLimit, y)
                end
            end

        elseif param == keys.left then
            -- Left
            if not bMenu then
                if x > 1 then
                    -- Move cursor left
                    setCursor(x - 1, y)
                elseif x == 1 and y > 1 then
                    setCursor(#tLines[y - 1] + 1, y - 1)
                end
            else
                -- Move menu left
                nMenuItem = nMenuItem - 1
                if nMenuItem < 1 then
                    nMenuItem = #tMenuItems
                end
                redrawMenu()
            end

        elseif param == keys.right then
            -- Right
            if not bMenu then
                local nLimit = #tLines[y] + 1
                if x < nLimit then
                    -- Move cursor right
                    setCursor(x + 1, y)
                elseif nCompletion and x == #tLines[y] + 1 then
                    -- Accept autocomplete
                    acceptCompletion()
                elseif x == nLimit and y < #tLines then
                    -- Go to next line
                    setCursor(1, y + 1)
                end
            else
                -- Move menu right
                nMenuItem = nMenuItem + 1
                if nMenuItem > #tMenuItems then
                    nMenuItem = 1
                end
                redrawMenu()
            end

        elseif param == keys.delete then
            -- Delete
            if not bMenu and not bReadOnly then
                local nLimit = #tLines[y] + 1
                if x < nLimit then
                    local sLine = tLines[y]
                    tLines[y] = string.sub(sLine, 1, x - 1) .. string.sub(sLine, x + 1)
                    recomplete()
                    redrawLine(y)
                elseif y < #tLines then
                    tLines[y] = tLines[y] .. tLines[y + 1]
                    table.remove(tLines, y + 1)
                    recomplete()
                    redrawText()
                end
            end

        elseif param == keys.backspace then
            -- Backspace
            if not bMenu and not bReadOnly then
                if x > 1 then
                    -- Remove character
                    local sLine = tLines[y]
                    if x > 4 and string.sub(sLine, x - 4, x - 1) == "    " and not string.sub(sLine, 1, x - 1):find("%S") then
                        tLines[y] = string.sub(sLine, 1, x - 5) .. string.sub(sLine, x)
                        setCursor(x - 4, y)
                    else
                        tLines[y] = string.sub(sLine, 1, x - 2) .. string.sub(sLine, x)
                        setCursor(x - 1, y)
                    end
                elseif y > 1 then
                    -- Remove newline
                    local sPrevLen = #tLines[y - 1]
                    tLines[y - 1] = tLines[y - 1] .. tLines[y]
                    table.remove(tLines, y)
                    setCursor(sPrevLen + 1, y - 1)
                    redrawText()
                end
            end

        elseif param == keys.enter or param == keys.numPadEnter then
            -- Enter/Numpad Enter
            if not bMenu and not bReadOnly then
                -- Newline
                local sLine = tLines[y]
                local _, spaces = string.find(sLine, "^[ ]+")
                if not spaces then
                    spaces = 0
                end
                tLines[y] = string.sub(sLine, 1, x - 1)
                table.insert(tLines, y + 1, string.rep(' ', spaces) .. string.sub(sLine, x))
                setCursor(spaces + 1, y + 1)
                redrawText()

            elseif bMenu then
                -- Menu selection
                doMenuItem(nMenuItem)

            end

        elseif param == keys.leftCtrl or param == keys.rightCtrl then
            -- Menu toggle
            bMenu = not bMenu
            if bMenu then
                term.setCursorBlink(false)
            else
                term.setCursorBlink(true)
            end
            redrawMenu()
        elseif param == keys.rightAlt then
            if bMenu then
                bMenu = false
                term.setCursorBlink(true)
                redrawMenu()
            end
        end

    elseif sEvent == "char" then
        if not bMenu and not bReadOnly then
            -- Input text
            local sLine = tLines[y]
            tLines[y] = string.sub(sLine, 1, x - 1) .. param .. string.sub(sLine, x)
            setCursor(x + 1, y)

        elseif bMenu then
            -- Select menu items
            for n, sMenuItem in ipairs(tMenuItems) do
                if string.lower(string.sub(sMenuItem, 1, 1)) == string.lower(param) then
                    doMenuItem(n)
                    break
                end
            end
        end

    elseif sEvent == "paste" then
        if not bReadOnly then
            -- Close menu if open
            if bMenu then
                bMenu = false
                term.setCursorBlink(true)
                redrawMenu()
            end
            -- Input text
            local sLine = tLines[y]
            tLines[y] = string.sub(sLine, 1, x - 1) .. param .. string.sub(sLine, x)
            setCursor(x + #param , y)
        end

    elseif sEvent == "mouse_click" then
        local cx, cy = param2, param3
        if not bMenu then
            if param == 1 then
                -- Left click
                if cy < h then
                    local newY = math.min(math.max(scrollY + cy, 1), #tLines)
                    local newX = math.min(math.max(scrollX + cx, 1), #tLines[newY] + 1)
                    setCursor(newX, newY)
                else
                    bMenu = true
                    redrawMenu()
                end
            end
        else
            if cy == h then
                local nMenuPosEnd = 1
                local nMenuPosStart = 1
                for n, sMenuItem in ipairs(tMenuItems) do
                    nMenuPosEnd = nMenuPosEnd + #sMenuItem + 1
                    if cx > nMenuPosStart and cx < nMenuPosEnd then
                        doMenuItem(n)
                    end
                    nMenuPosEnd = nMenuPosEnd + 1
                    nMenuPosStart = nMenuPosEnd
                end
            else
                bMenu = false
                term.setCursorBlink(true)
                redrawMenu()
            end
        end

    elseif sEvent == "mouse_scroll" then
        if not bMenu then
            if param == -1 then
                -- Scroll up
                if scrollY > 0 then
                    -- Move cursor up
                    scrollY = scrollY - 1
                    redrawText()
                end

            elseif param == 1 then
                -- Scroll down
                local nMaxScroll = #tLines - (h - 1)
                if scrollY < nMaxScroll then
                    -- Move cursor down
                    scrollY = scrollY + 1
                    redrawText()
                end

            end
        end

    elseif sEvent == "term_resize" then
        w, h = term.getSize()
        setCursor(x, y)
        redrawMenu()
        redrawText()

    end
end

-- Cleanup
term.clear()
term.setCursorBlink(false)
term.setCursorPos(1, 1)

-- End of File: files/cEdit

-- File: files/files
os.loadAPI("files/lg")
local config = require(".config.configManager")
lg.setup("term") 
screen = 1
lg.fillScreen(colors.black)
img3 = {"\x9f|0|0|lightBlue|white","\x8f|1|0|lightBlue|white","\x8f|2|0|lightBlue|white","\x90|3|0|white|orange",
"\x95|0|1|lightBlue|white","\space|1|1|lightBlue|white","\space|2|1|lightBlue|white","\x95|3|1|white|lightBlue",
"\x8a|0|2|white|green","\x8f|1|2|white|green","\x8f|2|2|white|green","\x85|3|2|white|green"}
img = {"\x83|0|0|yellow|orange","\x83|1|0|yellow|orange","\x83|2|0|yellow|black","\x83|3|0|yellow|black",
    "\space|0|1|yellow|yellow","\space|1|1|yellow|yellow","\space|2|1|yellow|yellow","\space|3|1|yellow|yellow"}
img2 = {"\x83|0|0|white|lightBlue","\x83|1|0|white|lightBlue","\x83|2|0|white|lightBlue","\x83|3|0|white|lightBlue",
    "\x8c|1|1|blue|white","\x9d|0|1|blue|white","\x9c|2|1|blue|white","\x91|3|1|white|blue",
 "\x88|0|2|white|blue","\x8c|1|2|white|blue","\x8c|2|2|white|blue","\space|3|2|white|yellow"}
img4 = {"\x95|0|0|black|lime","\x83|1|0|white|lightBlue","\x83|2|0|white|lightBlue","\x83|3|0|white|lightBlue",
    "\x8c|1|1|blue|white","\x9d|0|1|blue|white","\x9c|2|1|blue|white","\x91|3|1|white|blue",
 "\x88|0|2|white|blue","\x8c|1|2|white|blue","\x8c|2|2|white|blue","\space|3|2|white|yellow"}
--lg.drawAdvancedImage(2,10,img2)

function fileContainsString(filePath, targetString)
    local file = fs.open(filePath, "r")
    
    if not file then
        return false
    end
    local content = file.readAll()	
    file.close()
    
    if string.find(content, targetString) then
        return true
    else
        return false
    end
end


local folderTable = {}
local fileTable = {}
local currentPath = "userData/"
local function scanDirectory(path)
  folderTable = {}
  fileTable = {}  
  local items = fs.list(path)
  for _, item in ipairs(items) do
    local itemPath = fs.combine(path, item)
    if fs.isDir(itemPath) then
      if itemPath ~= ".cbuffer" and itemPath ~= ".variables" then
      	table.insert(folderTable, itemPath)
      end
    else
      table.insert(fileTable, itemPath)
    end
  end
end

function getLastPartOfPath(filePath)
    -- Split the path using "/"
    local pathParts = {}
    for part in string.gmatch(filePath, "[^/]+") do
        table.insert(pathParts, part)
    end

    -- Get the last part of the path
    local lastPart = pathParts[#pathParts]

    return lastPart
end

scanDirectory(currentPath)
yoffset = 0
-- Print the folder and file paths
function drawFiles(offset,currentPath,highlight)
lg.fillScreen(colors.black)
fx = 2
fy = 5 - offset
maxOffset = 0
lg.clearBTNS()
if highlight ~= nil then lg.drawBT("rename",lg.getSize().x-8,lg.getSize().x-8,2,2,colors.white,colors.orange,"R") end
if highlight ~= nil then lg.drawBT("copy",lg.getSize().x-6,lg.getSize().x-6,2,2,colors.white,colors.orange,"C") end
if highlight ~= nil then lg.drawBT("remove",lg.getSize().x-10,lg.getSize().x-10,2,2,colors.white,colors.orange,"D") end
lg.drawBT("paste",lg.getSize().x-6,lg.getSize().x-4,2,2,colors.white,colors.orange,"P")

for _, folder in ipairs(folderTable) do
  maxOffset = maxOffset + 1
  if maxOffset and folder == highlight then colr = colors.lime else colr = colors.white end
  lg.drawBT(folder,fx,fx+3,fy,fy+4,colors.black,colors.black," ")
  lg.drawAdvancedImage(fx,fy,img)
  folder = folder:gsub(currentPath, "")
  local fileNameFormated = getLastPartOfPath(folder)
  lg.drawText(fx,fy+3,colr,colors.black,fileNameFormated:sub(1, 4))
  if string.len(fileNameFormated) > 8 then
  lg.drawText(fx,fy+4,colr,colors.black,fileNameFormated:sub(-4, -1))
  end
  fx = fx + 5
  if (fx > 20) then fx = 2 fy = fy + 6 end 
end
for _, folder in ipairs(fileTable) do
  maxOffset = maxOffset + 1
  if maxOffset and folder == highlight then colr = colors.lime else colr = colors.white end
  lg.drawBT("f|"..folder,fx,fx+3,fy,fy+4,colors.black,colors.black," ")
  if string.find(folder,".nfp") then lg.drawAdvancedImage(fx,fy,img3) else
  	lg.drawAdvancedImage(fx,fy,img2)
  end
  if not string.find(folder,currentPath) then
  folder = folder:gsub(currentPath, "")
  end
  local fileNameFormated = getLastPartOfPath(folder)
  lg.drawText(fx,fy+3,colr,colors.black,fileNameFormated:sub(1, 4))
  if string.len(fileNameFormated) > 4 then
  lg.drawText(fx,fy+4,colr,colors.black,fileNameFormated:sub(-4, -1))
  end
  fx = fx + 5
  if (fx > 20) then fx = 2 fy = fy + 6 end 
end
local percentage = 0
local rp = 0
if (#fileTable + #folderTable > 12) then
if offset == 0 then
        lg.drawBT("up",lg.getSize().x,lg.getSize().x,17,17,colors.white,colors.gray,"\30")
        else
        lg.drawBT("up",lg.getSize().x,lg.getSize().x,17,17,colors.white,colors.yellow,"\30")
        end
        lg.drawBT("down",lg.getSize().x,lg.getSize().x,19,19,colors.white,colors.yellow,"\31")
        lg.fill(lg.getSize().x,lg.getSize().x,5,15,colors.gray)
        percentage = (offset / 70) * #fileTable + #folderTable
        rp = (((math.floor(percentage) / 10) - 1) * 2) - 1
        lg.drawText(lg.getSize().x,5+rp,colors.lightGray,colors.gray,"\8")
end
lg.fill(1,lg.getSize().x-1,1,1,colors.orange)
lg.drawBT("close",lg.getSize().x,lg.getSize().x,1,1,colors.white,colors.red,"x")
lg.drawText(2,1,colors.white,colors.orange,"File manager")
lg.drawBT("create",15,22,1,1,colors.orange,colors.white," Create")    
lg.fill(1,lg.getSize().x-1,2,2,colors.yellow)
lg.drawText(2,2,colors.white,colors.orange,currentPath)
lg.drawBT("back",lg.getSize().x-2,lg.getSize().x,2,2,colors.orange,colors.white,"/..")  
if config.readFromConfig("copied") ~= "false" and config.readFromConfig("copied") ~= nil then 
        lg.drawText(lg.getSize().x-4,2,colors.white,colors.orange,"P") 
end
--lg.drawText(1,1,colors.white,colors.black,tos.getPersistentVariable("copied"))
end

drawFiles(yoffset,currentPath)


for _, file in ipairs(fileTable) do
  
end
function debug(txt)
    lg.drawText(1,1,colors.white,colors.black,txt)
end
local bt = nil
local selectedFolder = nil
while true do
  local event, button, x, y = os.pullEvent( "mouse_click" )
  --debug(lg.isButton(x,y	))
  if screen == 1 and lg.isButton(x,y) == "down" then
        yoffset = yoffset + 6
        drawFiles(yoffset,currentPath)
  elseif screen == 1 and lg.isButton(x,y) == "up" then
        if yoffset > 0 then
            yoffset = yoffset - 6
            drawFiles(yoffset,currentPath)
        end
  elseif screen == 1 and lg.isButton(x,y) == "close" then break
  elseif screen == 1 and lg.isButton(x,y) == "create" then
    createDialog = lg.createWindow(5,8,18,6,true)
    screen =2
    createDialog:fillScreen(colors.white)
    createDialog:drawText(2,2,colors.black,colors.white,"Name")
    createDialog:drawInput("name",2,15,3,3,15)
    createDialog:drawBT("createItem",2,7,5,5,colors.white,colors.orange," File")
    createDialog:drawBT("createFolder",9,15,5,5,colors.white,colors.orange," Folder")
    createDialog:drawBT("close",18,18,1,1,colors.white,colors.red,"X")
    local nm = 1
    local function generateRandomFileName()
  		-- Generate a random file name
  		local randomName = "newFile"..nm
        nm = nm + 1
  		return randomName
	end

	local function fileExists(fileName)
 		 -- Check if the file exists
  		return fs.exists(fileName)
	end

	local randomName = generateRandomFileName()

	while fileExists(randomName) do
  		randomName = generateRandomFileName()
	end
    name = randomName
    while true do
      local event, button, x, y = os.pullEvent( "mouse_click" )
      x = x - 4
      y = y - 7
      btc = createDialog:isButton(x,y)
      if createDialog:isInput(x,y) then 
        name = createDialog:getInput(x,y)
      end
      if createDialog:isButton(x,y) == "close" then break
      elseif btc == "createFolder" then
      	os.sleep(0.5)
        createDialog:fillScreen(colors.white)
        createDialog:drawText(2,2,colors.black,colors.white,"Folder created!")
        createDialog:drawText(2,3,colors.black,colors.white,currentPath..name)
        os.sleep(1)
        createDialog:hide()
        local directoryName = currentPath..name
		shell.run("mkdir",directoryName)
        break
      elseif btc == "createItem" then
            os.sleep(0.5)
            createDialog:fillScreen(colors.white)
            createDialog:drawText(2,2,colors.black,colors.white,"File created!")
            createDialog:drawText(2,3,colors.black,colors.white,currentPath..name)
            os.sleep(1)
            createDialog:hide()
            if string.find(name,".nfp") then shell.run("paint",currentPath..name) else shell.run("edit",currentPath..name) end
            break
      end
    end
    createDialog:hide()
    screen = 1
    scanDirectory(currentPath)
    yoffset = 0 
    selectedFolder = nil
    drawFiles(yoffset,currentPath,selectedFolder)
  elseif screen == 1 and lg.isButton(x,y) == "copy" then
    if fs.exists("/.cbuffer/") then shell.run("delete","/.cbuffer/") end
    shell.run("copy",selectedFolder ,"/.cbuffer/"..selectedFolder:match("/([^/]+)$"))
    lg.drawText(2,1,colors.white,colors.orange,"Copied succesfully!  ")
    os.sleep(0.5)
    config.setToConfig("copied",selectedFolder:match("/([^/]+)$"))
    screen = 1
    scanDirectory(currentPath)
    selectedFolder = nil
    drawFiles(yoffset,currentPath,selectedFolder)
  elseif screen == 1 and lg.isButton(x,y) == "paste" then
    shell.run("copy","/.cbuffer/"..config.readFromConfig("copied"),currentPath..config.readFromConfig("copied")	)
    config.setToConfig("copied","false")
    lg.drawText(2,1,colors.white,colors.orange,"Pasted succesfully!   ")
    os.sleep(1)
    screen = 1
    scanDirectory(currentPath)
    selectedFolder = nil
    drawFiles(yoffset,currentPath,selectedFolder)        
  elseif screen == 1 and lg.isButton(x,y) == "remove" then
    shell.run("delete",selectedFolder)
    lg.drawText(2,1,colors.white,colors.orange,"Deleted succesfully!")
    os.sleep(1)
    screen = 1
    scanDirectory(currentPath)
    selectedFolder = nil
    drawFiles(yoffset,currentPath,selectedFolder)
  elseif screen == 1 and lg.isButton(x,y) == "rename" then 
    renameDialog = lg.createWindow(5,8,18,6,true)
    screen = 3
    renameDialog:fillScreen(colors.white)
    renameDialog:drawText(2,2,colors.black,colors.white,"New name")
    renameDialog:drawInput("name",2,15,3,3,15)
    renameDialog:drawBT("rename",2,7,5,5,colors.white,colors.orange," Done ")
    renameDialog:drawBT("close",18,18,1,1,colors.white,colors.red,"X")
    while true do
      local event, button, x, y = os.pullEvent( "mouse_click" )
      x = x - 4
      y = y - 7
      btr = renameDialog:isButton(x,y)
      if renameDialog:isInput(x,y) then 
        name = renameDialog:getInput(x,y)
      end
      if renameDialog:isButton(x,y) == "close" then break
      elseif btr == "rename" then
      	os.sleep(0.5)
        renameDialog:fillScreen(colors.white)
        renameDialog:drawText(2,2,colors.black,colors.white,"Renamed!")
        renameDialog:drawText(2,3,colors.black,colors.white,bt.." | "..name)
        os.sleep(1)
        renameDialog:hide()
        shell.run("rename",selectedFolder,currentPath..name)
        break
      end
    end
    renameDialog:hide()
    screen = 1
    scanDirectory(currentPath)
    yoffset = 0 
    selectedFolder = nil
    drawFiles(yoffset,currentPath,selectedFolder)
  elseif screen == 1 and lg.isButton(x,y) == "back" then 
        currentPath = currentPath:match("(.-)[^/]+/$")
        if not currentPath then 
           currentPath = "userData/" 
        end
		if currentPath == "" or currentPath == " " or not currentPath then
            currentPath = "userData/"
        end
		if currentPath == "/" then
		  currentPath = "userData/"	
		end
        scanDirectory(currentPath) 
        yoffset = 0 
        selectedFolder = nil
        drawFiles(yoffset,currentPath,selectedFolder)
  elseif screen == 1 and y > 4 and x < lg.getSize().x then
        -- local id = ((math.floor(y / 5) * 5)/5)
        -- id = id + ((math.floor(x / 6) * 6)/6)
        -- id = (id + 3 * (((math.floor(y / 6) * 6)/6))) - 3
        -- if id == 0 then id = 1 end
        -- if yoffset >  0 then id = id + (yoffset/6)*4 end
        -- if #folderTable >= id then
        -- if id == selectedFolder then
            -- currentPath = "/"..folderTable[id]
            -- yoffset = 0
            -- scanDirectory(currentPath)
            -- drawFiles(yoffset,currentPath)
            
        -- else
        -- lg.fill(1,lg.getSize().x-4,2,2,colors.yellow)
        -- --lg.drawText(2,2,colors.white,colors.black,id)
        -- lg.drawText(2,2,colors.white,colors.yellow,"SEL_F: /"..folderTable[id])
        -- selectedFolder = id
        -- end
        -- end
        if lg.isButton(x,y) ~= false then
          if not string.find(lg.isButton(x,y),"f|")  then
          if lg.isButton(x,y) == selectedFolder then
            currentPath = selectedFolder.."/"
            yoffset = 0
            scanDirectory(currentPath)
            drawFiles(yoffset,currentPath)
            else
            selectedFolder = lg.isButton(x,y)
            drawFiles(yoffset,currentPath,selectedFolder)
            lg.fill(1,lg.getSize().x-4,2,2,colors.yellow)
            -- DEBUG lg.drawText(2,3,colors.white,colors.black,selectedFolder)
            bt = lg.isButton(x,y)
            if #bt > 12 then
              bt = "..." .. string.sub(bt, -9)
            end            
            lg.drawText(2,2,colors.white,colors.yellow,"F: /"..bt)    
            lg.drawText(lg.getSize().x-8,2,colors.white,colors.orange,"R")
            lg.drawText(lg.getSize().x-6,2,colors.white,colors.orange,"C")
            lg.drawText(lg.getSize().x-10,2,colors.white,colors.orange,"D")                    
            if config.readFromConfig("copied") ~= "false" and config.readFromConfig("copied") ~= nil then lg.drawText(lg.getSize().x-4,2,colors.white,colors.orange,"P")                        end
            end
        else
          bt = lg.isButton(x,y):gsub("f|", "")
          if bt == selectedFolder then
            if string.find(bt,".nfp") then shell.run("paint",bt) 
			elseif string.find(bt,".app") then
				if fileContainsString(bt,"local desc = '") and config.readFromConfig("sideloading_blocked") ~= "yes" then
					shell.run(bt) 
				  else
					lg.fillScreen(colors.black)
					config.setToConfig("sideloading_blocked","yes")
					print("")
					print("You tried to fake .app ??")
					print("--")
					print("Now you can't use any .app files on your device!")
					print(" ")
					print(" ")
					print("Contact bank support for unblocking ")
					print("Press any key...")
					os.pullEvent("key")
				  end
			else
				shell.run("files/cEdit",bt)
				print("Run this file? (y/n)")
				if read() == "y" then
				    lg.fillScreen(colors.black)
					term.setCursorPos(1,1)
					local defaultEnv = _ENV
					defaultEnv.fs = nil
					defaultEnv.shell = nil
					local ok, err = pcall(loadfile(bt, nil, defaultEnv))
				end
				print("Press any key...")
				os.pullEvent("key")
            end
            selectedFolder = nil
            drawFiles(yoffset,currentPath,selectedFolder)  
          else
            selectedFolder = bt
            drawFiles(yoffset,currentPath,selectedFolder)        
            lg.fill(1,lg.getSize().x-4,2,2,colors.yellow)
            lg.drawText(2,2,colors.white,colors.black,id)
            if #bt > 12 then
              bt = "..." .. string.sub(bt, -9)
            end
            lg.drawText(2,2,colors.white,colors.yellow,bt)
            lg.drawText(lg.getSize().x-8,2,colors.white,colors.orange,"R")
            lg.drawText(lg.getSize().x-6,2,colors.white,colors.orange,"C")
            lg.drawText(lg.getSize().x-10,2,colors.white,colors.orange,"D")
            if config.readFromConfig("copied") ~= "false" and config.readFromConfig("copied") ~= nil then lg.drawText(lg.getSize().x-4,2,colors.white,colors.orange,"P") end
          end
        end
          
        end  
  end   
end
lg.exit()

-- End of File: files/files

-- File: files/lg
--v3
local function update()
  shell.run("delete","lg")
  shell.run("pastebin","get","sSF7NPYC","lg")
  os.reboot()
end
local args = {...}
if (args[1] == "update") then
  update()
end
function setup(name)
  sx,sy = nil
  buttons = {}
  tname = name
  pixels = {}
  local bg = colors.black 
  sprites = {}  
  inputs = {}
  oterm = term.current()
  if (name == "term") then
    sx,sy = term.getSize()
    local previous = term
  else
    m = peripheral.wrap(name)
    local previous = term.redirect(m)
    sx,sy = m.getSize()
  end
end
function createWindow(x,y,w,h,visible)
  local window = window.create(term.current(), x, y, w,h,visible)
  local scene = {oterm=oterm,x=x,y=y,window = window, bg=colors.black,w=w,h=h,buttons = {}, pixels = {}, sprites = {}, inputs = {},
  drawText = function (self, x,y,color,colorb,text)
    term.setCursorPos(x,y)
    term.setTextColor(color)
    term.setBackgroundColor(colorb)
    term.write(text)  
  end,
  clearScreen = function ()
    term.clear()
  end,
  setBackgroundColor = function (color)
    term.setBackgroundColor(color)
  end,  
  setTextColor = function(color)
    term.setTextColor(color)
  end,
  drawBT = function(self,name,x,xe,y,ye,color,colorb,text)
    term.setBackgroundColor(colorb)
    term.setTextColor(color)
    for i=x,xe do
      for g=y,ye do
        term.setCursorPos(i,g)
        term.write(" ")
      end
    end
    textline = (y + ye) / 2
    textline = string.format("%.1f", textline)
    textline = tonumber(textline)
    lines = {}
    for word in string.gmatch(text,"[^\n]+") do
       table.insert(lines,word)
    end
    if (#lines > 1) then
      for w=1,#lines do
        term.setCursorPos(x,y+w)
        term.write(lines[w])
      end
    else
      term.setCursorPos(x,textline)
      term.write(text)
    end
    table.insert(self.buttons,name..";"..x..";"..xe..";"..y..";"..ye)  
  end,
  isButton = function(self,x,y)
    for i=1,#self.buttons do
      local parts = {}
      for word in string.gmatch(self.buttons[i],"[^;]+") do
        table.insert(parts,word)
      end
      name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
      if (bx-1 < x and x < bxe + 1 ) then
        if (by-1 < y and bye+1 > y) then
          return name
        end
      end
    end
    return self.buttons[1]
  end,
  fill  = function(x1,x2,y1,y2,color)
    term.setBackgroundColor(color)
    for i=x1,x2 do
      for g=y1,y2 do
        term.setCursorPos(i,g)
        self.pixels[x..y] = color
        term.write(" ")
      end
    end
  end,
  fillScreen  = function(self,color)
    term.setBackgroundColor(color)
    term.clear()
    self.pixels = {}
  end,
  drawImage  = function(x,y,name)
    image = paintutils.loadImage(name)
    paintutils.drawImage(image,x,y)
  end,
  getSize  = function(self)
    local sizet = {}
    sizet.x = self.w
    sizet.y = self.h
    return sizet
  end,
  drawInput  = function(self,name,x,x2,y,y2,limit)
    term.setBackgroundColor(colors.gray)
    term.setTextColor(colors.white)
    for i=x,x2 do
      for g=y,y2 do
        term.setCursorPos(i,g)
        term.write(" ")
      end
    end
    table.insert(self.inputs,name..";"..x..";"..x2..";"..y..";"..y2..";"..limit)
  end,
  isInput = function(self,x,y)
    term.setTextColor(colors.white)
    for i=1,#self.inputs do
      local parts = {}
      for word in string.gmatch(self.inputs[i],"[^;]+") do
        table.insert(parts,word)
      end
      name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
      if (bx-1 < x and x < bxe + 1 ) then
        if (by-1 < y and bye+1 > y) then
          return name
        end 
      end
    end
    return false
  end,
  getInput = function(self,x,y,safe)
  for i=1,#self.inputs do
    local parts = {}
    for word in string.gmatch(self.inputs[i],"[^;]+") do
      table.insert(parts,word)
    end
    name,bx,bxe,by,bye,limit = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5]),tonumber(parts[6])
    if (bx-1 < x and x < bxe + 1 ) then
      if (by-1 < y and bye+1 > y) then
        term.setCursorPos(bx,by)
        local text = limitRead(limit, safe)
        return text
      end
    end
  end
  return false
end,
  hide = function(self)
    self.window.setVisible(false)
    if (tname == "term") then
      term.redirect(self.oterm)
    else
      term.redirect(m)
    end
    paintutils.drawFilledBox(self.x, self.y, self.w, self.h, self.bg)
   
  end,
  getPos = function()
    return self.window.getPosition()
  end,
  rePos  = function(self,x,y,h2,w2)
    if (h2 and w2) then
      self.window.reposition(x,y,h2,w2)
    else
      self.window.reposition(x,y)
    end
  end
  }
  if (visible) then
    term.redirect(window)
  end
  return scene
end
function exit()
  term.native()
end
function drawText(x,y,color,colorb,text)
  term.setCursorPos(x,y)
  term.setTextColor(color)
  term.setBackgroundColor(colorb)
  term.write(text)
end
function clearScreen()
  term.clear()
end
function setBackgroundColor(color)
  term.setBackgroundColor(color)
end
function setTextColor(color)
  term.setTextColor(color)
end
function drawBT(name,x,xe,y,ye,color,colorb,text)
  term.setBackgroundColor(colorb)
  term.setTextColor(color)
  for i=x,xe do
    for g=y,ye do
      term.setCursorPos(i,g)
      term.write(" ")
    end
  end
  textline = (y + ye) / 2
  textline = string.format("%.1f", textline)
  textline = tonumber(textline)
  lines = {}
  for word in string.gmatch(text,"[^\n]+") do
     table.insert(lines,word)
  end
  if (#lines > 1) then
    for w=1,#lines do
      term.setCursorPos(x,y+w)
      term.write(lines[w])
    end
  else
    term.setCursorPos(x,textline)
    term.write(text)
  end
  table.insert(buttons,name..";"..x..";"..xe..";"..y..";"..ye)  
end
function clearBTNS()
  buttons = {}
end
function isButton(x,y)
  for i=1,#buttons do
    local parts = {}
    for word in string.gmatch(buttons[i],"[^;]+") do
      table.insert(parts,word)
    end
    name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
    if (bx-1 < x and x < bxe + 1 ) then
      if (by-1 < y and bye+1 > y) then
        return name
      end
    end
  end
  return false
end
function fill(x,x2,y,y2,color)
  term.setBackgroundColor(color)
  for i=x,x2 do
    for g=y,y2 do
      term.setCursorPos(i,g)
      term.write(" ")
    end
  end
end
function fillScreen(color)
  term.setBackgroundColor(color)
  term.clear()
end
function drawLine(x1, y1, x2, y2, color)
    local dx = math.abs(x2 - x1)
    local dy = math.abs(y2 - y1)
    local sx, sy

    if x1 < x2 then
        sx = 1
    else
        sx = -1
    end

    if y1 < y2 then
        sy = 1
    else
        sy = -1
    end

    local err = dx - dy

    while true do
        term.setCursorPos(x1, y1)
        term.setTextColor(color)
        term.write(" ")

        if x1 == x2 and y1 == y2 then
            break
        end

        local err2 = 2 * err

        if err2 > -dy then
            err = err - dy
            x1 = x1 + sx
        end

        if err2 < dx then
            err = err + dx
            y1 = y1 + sy
        end
    end
end
function drawImage(x,y,name)
  image = paintutils.loadImage(name)
  paintutils.drawImage(image,x,y)
end
function getSize()
  local sizet = {}
  sizet.x = sx
  sizet.y = sy
  return sizet
end
function drawInput(name,x,x2,y,y2,limit)
  term.setBackgroundColor(colors.gray)
  term.setTextColor(colors.white)
  for i=x,x2 do
    for g=y,y2 do
      term.setCursorPos(i,g)
      term.write(" ")
    end
  end
  table.insert(inputs,name..";"..x..";"..x2..";"..y..";"..y2..";"..limit)
end
function isInput(x,y)
  for i=1,#inputs do
    local parts = {}
    for word in string.gmatch(inputs[i],"[^;]+") do
      table.insert(parts,word)
    end
    name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
    if (bx-1 < x and x < bxe + 1 ) then
      if (by-1 < y and bye+1 > y) then
        return name
      end
    end
  end
  return false
end	
function getInput(x,y,safe)
  for i=1,#inputs do
    local parts = {}
    for word in string.gmatch(inputs[i],"[^;]+") do
      table.insert(parts,word)
    end
    name,bx,bxe,by,bye,limit = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5]),tonumber(parts[6])
    if (bx-1 < x and x < bxe + 1 ) then
      if (by-1 < y and bye+1 > y) then
        term.setCursorPos(bx,by)
        local text = limitRead(limit, safe)
        return text
      end
    end
  end
  return false
end
function setCursorPos(x,y)
   term.setCursorPos(x,y)
end
function drawAdvancedImage(x,y,img)
  if img then
    for i=1,#img do
      pixel = img[i]
      local var1, var2, var3, var4, var5 = pixel:match("([^|]+)|([^|]+)|([^|]+)|([^|]+)|([^|]+)")
      term.setCursorPos(x + tonumber(var2),y + tonumber(var3))
      term.setBackgroundColor(getColor(var4))
      term.setTextColor(getColor(var5))
      if  string.find(var1,"\space") then
              term.write(" ")
      else
      	term.write(var1)
     end
    end   
  end
end















-- FUNC
function getColor(colorName)
  local colors = {
  white = colors.white,
  orange = colors.orange,
  magenta = colors.magenta,
  lightBlue = colors.lightBlue,
  yellow = colors.yellow,
  lime = colors.lime,
  pink = colors.pink,
  gray = colors.gray,
  lightGray = colors.lightGray,
  cyan = colors.cyan,
  purple = colors.purple,
  blue = colors.blue,
  brown = colors.brown,
  green = colors.green,
  red = colors.red,
  black = colors.black
}
  
  return colors[colorName]
end
function isColor(value)
  local table = {
  white = colors.white,
  orange = colors.orange,
  magenta = colors.magenta,
  lightBlue = colors.lightBlue,
  yellow = colors.yellow,
  lime = colors.lime,
  pink = colors.pink,
  gray = colors.gray,
  lightGray = colors.lightGray,
  cyan = colors.cyan,
  purple = colors.purple,
  blue = colors.blue,
  brown = colors.brown,
  green = colors.green,
  red = colors.red,
  black = colors.black
}
  for k, v in pairs(table) do
    if k == value then
      return true
    end
  end
  return false
end
function limitRead(limX, safe, rChar)
  		term.setBackgroundColor(colors.gray)
  		term.setTextColor(colors.white)
        term.setCursorBlink(true)
        local origX, origY = term.getCursorPos()
        local returnString = ""
        while true do
                local xPos, yPos = term.getCursorPos()
                local event, p1, p2 = os.pullEvent()
                if event == "char"  then
                        if safe and p1 ~= "-" or safe and p1 ~= "." then
                        else
                        returnString = returnString..p1
                        if not rChar then
                                if not limX then
                                        write(p1)
                                else
                                        if string.len(returnString) >= limX then
                                                term.setCursorPos(origX, origY)
                                                write(string.sub(returnString, (string.len(returnString)-limX)+1))
                                        elseif string.len(returnString) < limX then
                                                write(p1)
                                        end
                                end
                        else
                                if not limX then
                                        write(rChar)
                                else
                                        if string.len(returnString) >= limX then
                                                term.setCursorPos(origX, origY)
                                                write(string.rep(rChar, limX))
                                        elseif string.len(returnString) < limX then
                                                write(rChar)
                                        end
                                end
                        end
                end
                elseif event == "key" and p1 == 259 and string.len(returnString) > 0 then --backspace
                        returnString = string.sub(returnString, 1, (string.len(returnString))-1)
                        term.setCursorPos(xPos-1,yPos)
                        write(" ")
                        term.setCursorPos(origX, origY)
                        if string.len(returnString) >= limX then
                                if not rChar then
                                        write(string.sub(returnString, (string.len(returnString)-limX)+1))
                                else
                                        write(string.rep(rChar,limX))
                                end
                        else
                                if not rChar then
                                        write(returnString)
                                else
                                        write(string.rep(rChar, string.len(returnString)))
                                end
                        end
                elseif event == "key" and p1 == 257 then --enter
                        break
                end
        end
        term.setCursorBlink(false)
        return returnString
end
-- End of File: files/lg

-- File: id
32

-- End of File: id

-- File: lg
--v4
local function update()
  shell.run("delete","lgame")
  shell.run("pastebin","get","z3p689g1","lgame")
  os.reboot()
end
-- function syscal = setmetatable({}, {__index = function(self,idx)
--   return function(...)
--     local retval  = table.pack(coroutine.yeild("syscall", idx, ...))
--     if retval[1] then return table.unpack(retval, 2, retval.n)
--     else error(retval[2],2) end
--   end
-- end, __newindex = function() end})
local args = {...}  
if (args[1] == "update") then
  update()
end
local tname = nil
function getVersion()
  return "5.1"
end
function setup(name)
  sx,sy = nil
  buttons = {}
  tname = name
  pixels = {}
  local bg = colors.black 
  sprites = {}  
  inputs = {}
  oterm = term.current()
  if (name == "term") then
    sx,sy = term.getSize()
    local previous = term
  else
    m = peripheral.wrap(name)
    local previous = term.redirect(m)
    sx,sy = m.getSize()
  end
end
function createScene(x,y,w,h,visible)
  local window = window.create(term.current(), x, y, w,h,visible)
  local scene = {oterm=oterm,x=x,y=y,window = window, bg=colors.black,w=w,h=h,buttons = {}, pixels = {}, sprites = {}, inputs = {},
  drawText = function (self, x,y,color,colorb,text)
    term.setCursorPos(x,y)
    term.setTextColor(color)
    term.setBackgroundColor(colorb)
    term.write(text)  
  end,
  clearScreen = function ()
    term.clear()
  end,
  setBackgroundColor = function (color)
    term.setBackgroundColor(color)
  end,  
  setTextColor = function(color)
    term.setTextColor(color)
  end,
  drawBT = function(self,name,x,xe,y,ye,color,colorb,text)
    term.setBackgroundColor(colorb)
    term.setTextColor(color)
    for i=x,xe do
      for g=y,ye do
        term.setCursorPos(i,g)
        term.write(" ")
      end
    end
    textline = (y + ye) / 2
    textline = string.format("%.1f", textline)
    textline = tonumber(textline)
    lines = {}
    for word in string.gmatch(text,"[^\n]+") do
       table.insert(lines,word)
    end
    if (#lines > 1) then
      for w=1,#lines do
        term.setCursorPos(x,y+w)
        term.write(lines[w])
      end
    else
      term.setCursorPos(x,textline)
      term.write(text)
    end
    table.insert(self.buttons,name..";"..x..";"..xe..";"..y..";"..ye)  
  end,
  isButton = function(self,x,y)
    for i=1,#self.buttons do
      local parts = {}
      for word in string.gmatch(self.buttons[i],"[^;]+") do
        table.insert(parts,word)
      end
      name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
      if (bx-1 < x and x < bxe + 1 ) then
        if (by-1 < y and bye+1 > y) then
          return name
        end
      end
    end
    return self.buttons[1]
  end,
  fill  = function(self, x,x2,y,y2,color)
    term.setBackgroundColor(color)
    for i=x,x2 do
      for g=y,y2 do
        term.setCursorPos(i,g)
        self.pixels[x..y] = color
        term.write(" ")
      end
    end
  end,
  drawRect = function(self,x,x2,y,y2,color)
  term.setBackgroundColor(color)
  for i=x,x2 do
    term.setCursorPos(i,y)
    self.pixels[x..y] = color
    term.write(" ")
  end
  for i=y,y2 do
    term.setCursorPos(x2,i)
    self.pixels[x..y] = color
    term.write(" ")
  end
  paintutils.drawLine(x2,y2,x,y2,color)
  paintutils.drawLine(x,y2,x,y,color)
end,
  fillScreen  = function(self,color)
    term.setBackgroundColor(color)
    term.clear()
    self.pixels = {}
  end,
  drawImage  = function(x,y,name)
    image = paintutils.loadImage(name)
    paintutils.drawImage(image,x,y)
  end,
  getSize  = function(self)
    local sizet = {}
    sizet.x = self.w
    sizet.y = self.h
    return sizet
  end,
  drawInput  = function(self,name,x,x2,y,y2,limit)
    term.setBackgroundColor(colors.gray)
    term.setTextColor(colors.white)
    for i=x,x2 do
      for g=y,y2 do
        term.setCursorPos(i,g)
        term.write(" ")
      end
    end
    table.insert(self.inputs,name..";"..x..";"..x2..";"..y..";"..y2..";"..limit)
  end,
  isInput = function(self,x,y)
    for i=1,#self.inputs do
      local parts = {}
      for word in string.gmatch(self.inputs[i],"[^;]+") do
        table.insert(parts,word)
      end
      name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
      if (bx-1 < x and x < bxe + 1 ) then
        if (by-1 < y and bye+1 > y) then
          return name
        end 
      end
    end
    return false
  end,
  getInput  = function(self,x,y)
    for i=1,#self.inputs do
      local parts = {}
      for word in string.gmatch(self.inputs[i],"[^;]+") do
        table.insert(parts,word)
      end
      name,bx,bxe,by,bye,limit = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5]),tonumber(parts[6])
      if (bx-1 < x and x < bxe + 1 ) then
        if (by-1 < y and bye+1 > y) then
          term.setCursorPos(bx,by)
          local text = limitRead(limit)
          return text
        end
      end
    end
    return false
  end,
  lggSetDefBG  = function(self,color)
    self.bg = color
  end,
  drawSprite  = function(self,name,x,y,iname)
    image = paintutils.loadImage(iname)
    paintutils.drawImage(image,x,y)
    table.insert(self.sprites,name..";"..x..";"..y..";"..iname)
  end,
  changeImage = function(self,name,iname)
    for h=1,#self.sprites do
      local parts = {}
      for word in string.gmatch(self.sprites[h],"[^;]+") do
        table.insert(parts,word)
      end
      if (parts[1] == name) then
        self.sprites[h] = parts[1]..";"..parts[2]..";"..parts[3]..";"..iname
      end
    end
  end,
  moveSprite = function(self,name,x,y,fill)
    for h=1,#self.sprites do
      local parts = {}
      term.setBackgroundColor(colors.black)
      for word in string.gmatch(self.sprites[h],"[^;]+") do
        table.insert(parts,word)
      end
      if (parts[1] == name) then
      local iname = nil
      local name,ox,oy,iname = parts[1],tonumber(parts[2]),tonumber(parts[3]),parts[4]
      image = paintutils.loadImage(iname)
      term.setCursorPos(10,1)
      term.setBackgroundColor(colors.black)
      if (fill) then
      for i=ox,ox+getWidth(image) do
        for g=oy,oy+getHeight(image) do
          if (pixels[i..g] ~= nil) then
            term.setCursorPos(i,g)
            term.setBackgroundColor(pixels[i..g])
            term.write(" ")
          else
            term.setCursorPos(i,g)
            term.setBackgroundColor(bg)
            term.write(" ")
          end
        end
      end
      end
      paintutils.drawImage(image,x,y)
      table.remove(self.sprites,h)
      table.insert(self.sprites,name..";"..x..";"..y..";"..iname)    
      else
      end
    end
    return false
  end,
  getSpriteColider = function(self,name)
    for h=1,#self.sprites do
      local parts = {}
      term.setBackgroundColor(colors.black)
      for word in string.gmatch(self.sprites[h],"[^;]+") do
        table.insert(parts,word)
      end
      if (parts[1] == name) then
      local iname = nil
      local name,ox,oy,iname = parts[1],tonumber(parts[2]),tonumber(parts[3]),parts[4]
      image = paintutils.loadImage(iname)
      local sizet = {}
      sizet.x = ox
      sizet.y = oy
      sizet.x2 = ox + getWidth(image)
      sizet.y2 = oy + getHeight(image)
      return sizet
      else
      end
    end
    return false
  end,
  isColiding  = function(self,name, name2)
    for h=1,#self.sprites do
      local parts = {}
      term.setBackgroundColor(colors.black)
      for word in string.gmatch(self.sprites[h],"[^;]+") do
        table.insert(parts,word)
      end
      if (parts[1] == name) then
        local iname = nil
        local nameo,ox,oy,iname = parts[1],tonumber(parts[2]),tonumber(parts[3]),parts[4]
        image = paintutils.loadImage(iname)
        local sizet = {}
        sizet.x = ox
        sizet.y = oy
        sizet.x2 = ox + getWidth(image)
        sizet.y2 = oy + getHeight(image)
        local allCord = {}
        for a=sizet.x,sizet.x2 do
          for b=sizet.y,sizet.y2 do
            table.insert(allCord,a..";"..b)
          end
        end
        for g=1,#self.sprites do
          local parts2 = {}
          for word2 in string.gmatch(self.sprites[g],"[^;]+") do
            table.insert(parts2,word2)
          end
          local nameo2,ox2,oy2,iname2 = parts2[1],tonumber(parts2[2]),tonumber(parts2[3]),parts2[4]
          image2 = paintutils.loadImage(iname2)
          ox22 = ox2 + getWidth(image2)
          oy22 = oy2 + getHeight(image2)
          if (nameo2 == name2) then
            local allCord2 = {}
            for a=ox2,ox22 do
              for b=oy2,oy22 do
               table.insert(allCord2,a..";"..b)
            end
              end
              for i=1,#allCord do
                for g=1,#allCord2 do
                  if (allCord[i] == allCord2[g]) then
                     return true
                  end
                end
              end
          end
      end
      end
    end
    return false
  end,
  draw = function(self)
    self.window.setVisible(true)
    self.window.restoreCursor()
    self.window.redraw()
    term.redirect(self.window)
  end,
  focus = function(self)
    self.window.restoreCursor()
    term.redirect(self.window)
  end,
  unfocus = function(self)
    if (tname == "term") then
      term.redirect(self.oterm)
    else
      term.redirect(m)
    end
  end,
  hide = function(self)
    self.window.setVisible(false)
    if (tname == "term") then
      term.redirect(self.oterm)
    else
      term.redirect(m)
    end
    paintutils.drawFilledBox(self.x, self.y, self.w, self.h, self.bg)
   
  end,
  getPos = function()
    return self.window.getPosition()
  end,
  rePos  = function(self,x,y,h2,w2)
    if (h2 and w2) then
      self.window.reposition(x,y,h2,w2)
    else
      self.window.reposition(x,y)
    end
  end
  }
  if (visible) then
    term.redirect(window)
  end
  return scene
end
function exit()
  term.native()
end
function drawText(x,y,color,colorb,text)
  term.setCursorPos(x,y)
  term.setTextColor(color)
  term.setBackgroundColor(colorb)
  term.write(text)
end
function clearScreen()
  term.clear()
end
function setBackgroundColor(color)
  term.setBackgroundColor(color)
end
function setTextColor(color)
  term.setTextColor(color)
end
function drawBT(name,x,xe,y,ye,color,colorb,text)
  term.setBackgroundColor(colorb)
  term.setTextColor(color)
  for i=x,xe do
    for g=y,ye do
      term.setCursorPos(i,g)
      term.write(" ")
    end
  end
  textline = (y + ye) / 2
  textline = string.format("%.1f", textline)
  textline = tonumber(textline)
  lines = {}
  for word in string.gmatch(text,"[^\n]+") do
     table.insert(lines,word)
  end
  if (#lines > 1) then
    for w=1,#lines do
      term.setCursorPos(x,y+w)
      term.write(lines[w])
    end
  else
    term.setCursorPos(x,textline)
    term.write(text)
  end
  table.insert(buttons,name..";"..x..";"..xe..";"..y..";"..ye)  
end
function isButton(x,y)
  for i=1,#buttons do
    local parts = {}
    for word in string.gmatch(buttons[i],"[^;]+") do
      table.insert(parts,word)
    end
    name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
    if (bx-1 < x and x < bxe + 1 ) then
      if (by-1 < y and bye+1 > y) then
        return name
      end
    end
  end
  return false
end
function clearBTNS()
  buttons = {}
end
function fill(x,x2,y,y2,color)
  term.setBackgroundColor(color)
  for i=x,x2 do
    for g=y,y2 do
      term.setCursorPos(i,g)
      pixels[x..y] = color
      term.write(" ")
    end
  end
end
function drawRect(x,x2,y,y2,color)
  term.setBackgroundColor(color)
  for i=x,x2 do
    term.setCursorPos(i,y)
    pixels[x..y] = color
    term.write(" ")
  end
  for i=y,y2 do
    term.setCursorPos(x2,i)
    pixels[x..y] = color
    term.write(" ")
  end
  paintutils.drawLine(x2,y2,x,y2,color)
  paintutils.drawLine(x,y2,x,y,color)
end
function fillScreen(color)
  term.setBackgroundColor(color)
  term.clear()
  pixels = {}
end
function drawImage(x,y,name)
  image = paintutils.loadImage(name)
  paintutils.drawImage(image,x,y)
end
function getSize()
  local sizet = {}
  sizet.x = sx
  sizet.y = sy
  return sizet
end
function drawInput(name,x,x2,y,y2,limit)
  term.setBackgroundColor(colors.gray)
  term.setTextColor(colors.white)
  for i=x,x2 do
    for g=y,y2 do
      term.setCursorPos(i,g)
      term.write(" ")
    end
  end
  table.insert(inputs,name..";"..x..";"..x2..";"..y..";"..y2..";"..limit)
end
function isInput(x,y)
  for i=1,#inputs do
    local parts = {}
    for word in string.gmatch(inputs[i],"[^;]+") do
      table.insert(parts,word)
    end
    name,bx,bxe,by,bye = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5])
    if (bx-1 < x and x < bxe + 1 ) then
      if (by-1 < y and bye+1 > y) then
        return name
      end 
    end
  end
  return false
end	
function getInput(x,y,safe)
  for i=1,#inputs do
    local parts = {}
    for word in string.gmatch(inputs[i],"[^;]+") do
      table.insert(parts,word)
    end
    name,bx,bxe,by,bye,limit = parts[1],tonumber(parts[2]),tonumber(parts[3]),tonumber(parts[4]),tonumber(parts[5]),tonumber(parts[6])
    if (bx-1 < x and x < bxe + 1 ) then
      if (by-1 < y and bye+1 > y) then
        term.setCursorPos(bx,by)
        local text = limitRead(limit, safe)
        return text
      end
    end
  end
  return false
end
function lggSetDefBG(color)
  bg = color
end
function drawSprite(name,x,y,iname)
  image = paintutils.loadImage(iname)
  paintutils.drawImage(image,x,y)
  table.insert(sprites,name..";"..x..";"..y..";"..iname)
end
function moveSprite(name,x,y)
  for h=1,#sprites do
    local parts = {}
    term.setBackgroundColor(colors.black)
    for word in string.gmatch(sprites[h],"[^;]+") do
      table.insert(parts,word)
    end
    if (parts[1] == name) then
    local iname = nil
    local name,ox,oy,iname = parts[1],tonumber(parts[2]),tonumber(parts[3]),parts[4]
    image = paintutils.loadImage(iname)
    term.setCursorPos(10,1)
    term.setBackgroundColor(colors.black)
    for i=ox,ox+getWidth(image) do
      for g=oy,oy+getHeight(image) do
        if (pixels[i..g] ~= nil) then
          term.setCursorPos(i,g)
          term.setBackgroundColor(pixels[i..g])
          term.write(" ")
        else
          term.setCursorPos(i,g)
          term.setBackgroundColor(bg)
          term.write(" ")
        end
      end
    end
    paintutils.drawImage(image,x,y)
    table.remove(sprites,h)
    table.insert(sprites,name..";"..x..";"..y..";"..iname)    
    else
    end
  end
  return false
end
function getSpriteColider(name)
  for h=1,#sprites do
    local parts = {}
    term.setBackgroundColor(colors.black)
    for word in string.gmatch(sprites[h],"[^;]+") do
      table.insert(parts,word)
    end
    if (parts[1] == name) then
    local iname = nil
    local name,ox,oy,iname = parts[1],tonumber(parts[2]),tonumber(parts[3]),parts[4]
    image = paintutils.loadImage(iname)
    local sizet = {}
    sizet.x = ox
    sizet.y = oy
    sizet.x2 = ox + getWidth(image)
    sizet.y2 = oy + getHeight(image)
    return sizet
    else
    end
  end
  return false
end
function isColiding(name, name2)
  for h=1,#sprites do
    local parts = {}
    term.setBackgroundColor(colors.black)
    for word in string.gmatch(sprites[h],"[^;]+") do
      table.insert(parts,word)
    end
    if (parts[1] == name) then
      local iname = nil
      local nameo,ox,oy,iname = parts[1],tonumber(parts[2]),tonumber(parts[3]),parts[4]
      image = paintutils.loadImage(iname)
      local sizet = {}
      sizet.x = ox
      sizet.y = oy
      sizet.x2 = ox + getWidth(image)
      sizet.y2 = oy + getHeight(image)
      local allCord = {}
      for a=sizet.x,sizet.x2 do
        for b=sizet.y,sizet.y2 do
          table.insert(allCord,a..";"..b)
        end
      end
      for g=1,#sprites do
        local parts2 = {}
        for word2 in string.gmatch(sprites[g],"[^;]+") do
          table.insert(parts2,word2)
        end
        local nameo2,ox2,oy2,iname2 = parts2[1],tonumber(parts2[2]),tonumber(parts2[3]),parts2[4]
        image2 = paintutils.loadImage(iname2)
        ox22 = ox2 + getWidth(image2)
        oy22 = oy2 + getHeight(image2)
        if (nameo2 == name2) then
      		local allCord2 = {}
      		for a=ox2,ox22 do
        		for b=oy2,oy22 do
         		table.insert(allCord2,a..";"..b)
        	end
            end
            for i=1,#allCord do
              for g=1,#allCord2 do
                if (allCord[i] == allCord2[g]) then
                   return true
                end
              end
            end
        end
    end
    end
  end
  return false
end


















-- FUNC
function limitRead(limX, safe, rChar)
        term.setBackgroundColor(colors.gray)
        term.setTextColor(colors.white)
        term.setCursorBlink(true)
        local origX, origY = term.getCursorPos()
        local returnString = ""
        while true do
                local xPos, yPos = term.getCursorPos()
                local event, p1, p2 = os.pullEvent()
                if event == "char" then
                        if safe and p1 == "-" or safe and p1 == "." or safe and p1 == "," then
                        else
                        returnString = returnString..p1
                        if not rChar then
                                if not limX then
                                        write(p1)
                                else
                                        if string.len(returnString) >= limX then
                                                term.setCursorPos(origX, origY)
                                                write(string.sub(returnString, (string.len(returnString)-limX)+1))
                                        elseif string.len(returnString) < limX then
                                                write(p1)
                                        end
                                end
                        else
                                if not limX then
                                        write(rChar)
                                else
                                        if string.len(returnString) >= limX then
                                                term.setCursorPos(origX, origY)
                                                write(string.rep(rChar, limX))
                                        elseif string.len(returnString) < limX then
                                                write(rChar)
                                        end
                                end
                        end
                end
                elseif event == "key" and p1 == keys.backspace and string.len(returnString) > 0 then --backspace
                        returnString = string.sub(returnString, 1, (string.len(returnString))-1)
                        term.setCursorPos(xPos-1,yPos)
                        write(" ")
                        term.setCursorPos(origX, origY)
                        if string.len(returnString) >= limX then
                                if not rChar then
                                        write(string.sub(returnString, (string.len(returnString)-limX)+1))
                                else
                                        write(string.rep(rChar,limX))
                                end
                        else
                                if not rChar then
                                        write(returnString)
                                else
                                        write(string.rep(rChar, string.len(returnString)))
                                end
                        end
                elseif event == "key" and p1 == keys.enter then --enter
                        break
                end
        end
        term.setCursorBlink(false)
        return returnString
end
function getHeight( image )
  --# init the image start and end variables, these are what track where the start and end are
  local imgStart = #image --# we need to start at the end so we can apply math.min
  local imgEnd = 0 --# we need to start at the start so we can apply math.max
  --# loop through the table
  for index,imageLine in ipairs(image) do
        --# create a variable to hold if the line has a pixel
        local isLine = false
        --# loop through the pixels in the line
        for i,pixel in ipairs(imageLine) do
          --# if the pixel is drawable
          if pixel ~= 0 then
                --# record that there is a pixel, and exit the loop, no need to check anymore, we know there is at least 1
                isLine = true
                break
          end
        end
        --# if the line has pixels, check if its the start or end
        if isLine then
          imgStart = math.min(imgStart,index)
          imgEnd = math.max(imgEnd,index)
        end
  end
  --# return the height of the image, which is the end plus the start, plus 1 because tables start at index 1 not 0
  return imgEnd - imgStart + 1
end
function getWidth(img)
  --# the max width
  local maxWidth = 0
  --# loop through the image
  for i,line in pairs(img) do
        --# the variable to hold where the line starts
        local lineStart = #line --# start it at the end so we can apply math.min
        --# the variable to hold where the line ends
        local lineEnd = 0 --# start at the start so we can apply math.max
        --# loop the line
        for index,v in pairs(line) do
          --# if its a pixel
          if v ~= 0 then
                --# check if its the start or the end of the line
                lineStart = math.min(lineStart,index)
                lineEnd = math.max(lineEnd,index)
          end
        end
        --# the length of the line is the end minus the start positions, +1 because tables start at index 1 not 0
        local length = lineEnd - lineStart + 1
        --# check if its the max length
        maxWidth = math.max(maxWidth, length)
  end
  --# return the max length
  return maxWidth
end
return {getVersion = getVersion, getSize = getSize, fill = fill, fillScreen = fillScreen, createScene = createScene, setup = setup, exit = exit, drawBT = drawBT, drawText = drawText, drawInput = drawInput, drawSprite = drawSprite, drawImage = drawImage, setBackgroundColor = setBackgroundColor, setTextColor = setTextColor, clear = clear, isButton = isButton, isInput = isInput, moveSprite = moveSprite, isColiding = isColiding, lggSetDefBG = lggSetDefBG, getSpriteColider = getSpriteColider, clearBTNS = clearBTNS, getInput = getInput}
-- End of File: lg

-- File: libraries/api
--local axios = require('../libraries/axios')
local json = require('../libraries/json')
local api = axios:new('https://stack.kiefe.ru/api')

local function transfer(id,pin,receiver,amount,comment)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		-- Ğ’Ñ‹Ğ¿Ğ¾Ğ»ÑĞ½ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ€ĞµĞ´ÑÑ‚Ğ²
		local transactions = api:Post('v1/card/transactions',
			{ receiver = receiver, amount = amount, message = comment },
			{ Authorization = 'Bearer ' .. token })

		if transactions then

			-- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
			if transactions.code == 200 then
				return transactions.response.message
			else
				return transactions.code, transactions.response.message
			end
		end
	else
	  return false
	end
end

local function auth(id,pin)
    id = tonumber(id)
	pin = tonumber(pin)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		-- Ğ’Ñ‹Ğ¿Ğ¾Ğ»ÑĞ½ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ€ĞµĞ´ÑÑ‚Ğ²
		local transactions = api:Get('v1/card',
			{ Authorization = 'Bearer ' .. token })

		if transactions then

			-- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
			if transactions.code == 200 then
				return transactions
			else
				return false
			end
		end
	else
	  return false
	end
end	

local function getToken(id,pin)
	   id = tonumber(id)
	pin = tonumber(pin)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		return token
	else
	  return false
	end
end

local function getHistory(id,pin)
    id = tonumber(id)
	pin = tonumber(pin)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		-- Ğ’Ñ‹Ğ¿Ğ¾Ğ»ÑĞ½ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ€ĞµĞ´ÑÑ‚Ğ²
		local transactions = api:Get('v1/card/history?length=20',
			{ Authorization = 'Bearer ' .. token })

		if transactions then

			-- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
			if transactions.code == 200 then
				return transactions
			else
				return false
			end
		end
	else
	  return false
	end
end	

return { auth = auth, transfer = transfer, getHistory = getHistory}
-- End of File: libraries/api

-- File: libraries/audio.lua
local dfpwm = require("cc.audio.dfpwm")
local speaker = peripheral.find("speaker")

local function play(path)
    if not speaker then return end
    local decoder = dfpwm.make_decoder()
    for chunk in io.lines(path, 16 * 1024) do
        local buffer = decoder(chunk)

        while not speaker.playAudio(buffer) do
            os.pullEvent("speaker_audio_empty")
        end
    end
end

local function playUrl(url)
    local response, err = http.get { url = url, binary = true }
    if not response then error(err, 0) end
    if not speaker then return end
    local decoder = dfpwm.make_decoder()
    while true do
        local chunk = response.read(16 * 1024)
        if not chunk then break end
        local buffer = decoder(chunk)
        while not links.speaker.playAudio(buffer,300) do
            os.pullEvent("speaker_audio_empty")
        end
    end
end

local function playChunk(cache)
    if not speaker then return end
    local decoder = require("cc.audio.dfpwm").make_decoder()
    for _, chunk in pairs(cache) do
        local buffer = decoder(chunk)
        while not speaker.playAudio(buffer,300) do
            os.pullEvent("speaker_audio_empty")
        end
    end
end

return { play = play, playUrl = playUrl, playChunk = playChunk }
-- End of File: libraries/audio.lua

-- File: libraries/axios.lua
local json = require('/libraries.json')

local Axios = {}

-- Function to merge two tables
local function mergeTables(t1, t2)
    local result = {}
    for k, v in pairs(t1) do
        result[k] = v
    end
    for k, v in pairs(t2) do
        result[k] = v
    end
    return result
end

function Axios:new(address)
    local private = {
        address = address,
        defaultHeaders = {["content-type"] = "application/json"}
    }

    local public = setmetatable({}, { __index = private })

    function public:Get(api, headers)
        headers = mergeTables(public.defaultHeaders, headers or {})
        local request = http.get(('%s/%s'):format(public.address, api or ''), headers)
        if request then
            local response = json.parse(request.readAll())
            request.close()
            return { request = request, response = response['data'], code = response['statusCode'] }
        end
        return nil
    end

    function public:Post(api, body, headers)
        headers = mergeTables(public.defaultHeaders, headers or {})
        local request, err = http.post(('%s/%s'):format(public.address, api or ''), json.stringify(body), headers)
        if request then
            local response = json.parse(request.readAll())
            request.close()
            return { request = request, response = response['data'], code = response['statusCode'] }
        end
        return nil
    end

    function public:Check(api, headers)
        headers = mergeTables(public.defaultHeaders, headers or {})
        return http.checkURL(('%s/%s'):format(public.address, api or ''), headers)
    end

    return public
end

return Axios

-- End of File: libraries/axios.lua

-- File: libraries/cache_audio.lua

-- Define the class
local SoundCacher = {}

-- Constructor for the class
function SoundCacher:new(address)
    local obj = {
        address = address,
        caches = {},
        links = {}  -- Empty links table to be filled dynamically
    }

    -- Function to add links to the class
    function obj:addAudio(name)
        table.insert(self.links, {
            url = ('%s%s.dfpwm'):format(self.address, name),
            name = name
        })
    end

    setmetatable(obj, self)
    self.__index = self
    return obj
end

-- Function to start caching sounds
function SoundCacher:startCache()
    os.sleep(0.2)

    for _, link in pairs(self.links) do
        local response, err = http.get { url = link.url, binary = true }
        local index_chunk = 1
        while true do
            local chunk = response.read(16 * 1024)
            if not chunk then break end
            self.caches[link.name] = self.caches[link.name] or {}
            self.caches[link.name][index_chunk] = chunk
            index_chunk = index_chunk + 1
        end
    end
end

-- Function to get cached sound by name
function SoundCacher:getCache(name)
    return self.caches[name]
end

return SoundCacher
-- End of File: libraries/cache_audio.lua

-- File: libraries/json.lua
--[[ json.lua

A compact pure-Lua JSON library.
The main functions are: json.stringify, json.parse.

## json.stringify:

This expects the following to be true of any tables being encoded:
 * They only have string or number keys. Number keys must be represented as
   strings in json; this is part of the json spec.
 * They are not recursive. Such a structure cannot be specified in json.

A Lua table is considered to be an array if and only if its set of keys is a
consecutive sequence of positive integers starting at 1. Arrays are encoded like
so: `[2, 3, false, "hi"]`. Any other type of Lua table is encoded as a json
object, encoded like so: `{"key1": 2, "key2": false}`.

Because the Lua nil value cannot be a key, and as a table value is considerd
equivalent to a missing key, there is no way to express the json "null" value in
a Lua table. The only way this will output "null" is if your entire input obj is
nil itself.

An empty Lua table, {}, could be considered either a json object or array -
it's an ambiguous edge case. We choose to treat this as an object as it is the
more general type.

To be clear, none of the above considerations is a limitation of this code.
Rather, it is what we get when we completely observe the json specification for
as arbitrary a Lua object as json is capable of expressing.

## json.parse:

This function parses json, with the exception that it does not pay attention to
\u-escaped unicode code points in strings.

It is difficult for Lua to return null as a value. In order to prevent the loss
of keys with a null value in a json string, this function uses the one-off
table value json.null (which is just an empty table) to indicate null values.
This way you can check if a value is null with the conditional
`val == json.null`.

If you have control over the data and are using Lua, I would recommend just
avoiding null values in your data to begin with.

--]]


local json = {}


-- Internal functions.

local function kind_of(obj)
  if type(obj) ~= 'table' then return type(obj) end
  local i = 1
  for _ in pairs(obj) do
    if obj[i] ~= nil then i = i + 1 else return 'table' end
  end
  if i == 1 then return 'table' else return 'array' end
end

local function escape_str(s)
  local in_char  = {'\\', '"', '/', '\b', '\f', '\n', '\r', '\t'}
  local out_char = {'\\', '"', '/',  'b',  'f',  'n',  'r',  't'}
  for i, c in ipairs(in_char) do
    s = s:gsub(c, '\\' .. out_char[i])
  end
  return s
end

-- Returns pos, did_find; there are two cases:
-- 1. Delimiter found: pos = pos after leading space + delim; did_find = true.
-- 2. Delimiter not found: pos = pos after leading space;     did_find = false.
-- This throws an error if err_if_missing is true and the delim is not found.
local function skip_delim(str, pos, delim, err_if_missing)
  pos = pos + #str:match('^%s*', pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error('Expected ' .. delim .. ' near position ' .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

-- Expects the given pos to be the first character after the opening quote.
-- Returns val, pos; the returned pos is after the closing quote character.
local function parse_str_val(str, pos, val)
  val = val or ''
  local early_end_error = 'End of input found while parsing string.'
  if pos > #str then error(early_end_error) end
  local c = str:sub(pos, pos)
  if c == '"'  then return val, pos + 1 end
  if c ~= '\\' then return parse_str_val(str, pos + 1, val .. c) end
  -- We must have a \ character.
  local esc_map = {b = '\b', f = '\f', n = '\n', r = '\r', t = '\t'}
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then error(early_end_error) end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

-- Returns val, pos; the returned pos is after the number's final character.
local function parse_num_val(str, pos)
  local num_str = str:match('^-?%d+%.?%d*[eE]?[+-]?%d*', pos)
  local val = tonumber(num_str)
  if not val then error('Error parsing number at position ' .. pos .. '.') end
  return val, pos + #num_str
end


-- Public values and functions.

function json.stringify(obj, as_key)
  local s = {}  -- We'll build the string as an array of strings to be concatenated.
  local kind = kind_of(obj)  -- This is 'array' if it's an array or type(obj) otherwise.
  if kind == 'array' then
    if as_key then error('Can\'t encode array as key.') end
    s[#s + 1] = '['
    for i, val in ipairs(obj) do
      if i > 1 then s[#s + 1] = ', ' end
      s[#s + 1] = json.stringify(val)
    end
    s[#s + 1] = ']'
  elseif kind == 'table' then
    if as_key then error('Can\'t encode table as key.') end
    s[#s + 1] = '{'
    for k, v in pairs(obj) do
      if #s > 1 then s[#s + 1] = ', ' end
      s[#s + 1] = json.stringify(k, true)
      s[#s + 1] = ':'
      s[#s + 1] = json.stringify(v)
    end
    s[#s + 1] = '}'
  elseif kind == 'string' then
    return '"' .. escape_str(obj) .. '"'
  elseif kind == 'number' then
    if as_key then return '"' .. tostring(obj) .. '"' end
    return tostring(obj)
  elseif kind == 'boolean' then
    return tostring(obj)
  elseif kind == 'nil' then
    return 'null'
  else
    error('Unjsonifiable type: ' .. kind .. '.')
  end
  return table.concat(s)
end

json.null = {}  -- This is a one-off table to represent the null value.

function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then error('Reached unexpected end of input.') end
  local pos = pos + #str:match('^%s*', pos)  -- Skip whitespace.
  local first = str:sub(pos, pos)
  if first == '{' then  -- Parse an object.
    local obj, key, delim_found = {}, true, true
    pos = pos + 1
    while true do
      key, pos = json.parse(str, pos, '}')
      if key == nil then return obj, pos end
      if not delim_found then error('Comma missing between object items.') end
      pos = skip_delim(str, pos, ':', true)  -- true -> error if missing.
      obj[key], pos = json.parse(str, pos)
      pos, delim_found = skip_delim(str, pos, ',')
    end
  elseif first == '[' then  -- Parse an array.
    local arr, val, delim_found = {}, true, true
    pos = pos + 1
    while true do
      val, pos = json.parse(str, pos, ']')
      if val == nil then return arr, pos end
      if not delim_found then error('Comma missing between array items.') end
      arr[#arr + 1] = val
      pos, delim_found = skip_delim(str, pos, ',')
    end
  elseif first == '"' then  -- Parse a string.
    return parse_str_val(str, pos + 1)
  elseif first == '-' or first:match('%d') then  -- Parse a number.
    return parse_num_val(str, pos)
  elseif first == end_delim then  -- End of an object or array.
    return nil, pos + 1
  else  -- Parse true, false, or null.
    local literals = {['true'] = true, ['false'] = false, ['null'] = json.null}
    for lit_str, lit_val in pairs(literals) do
      local lit_end = pos + #lit_str - 1
      if str:sub(pos, lit_end) == lit_str then return lit_val, lit_end + 1 end
    end
    local pos_info_str = 'position ' .. pos .. ': ' .. str:sub(pos, pos + 10)
    error('Invalid json syntax starting at ' .. pos_info_str)
  end
end

return json

-- End of File: libraries/json.lua

-- File: libraries/rsa.lua
--
-- RSA Encryption/Decryption Library
-- By 1lann
--
-- Refer to license: http://pastebin.com/9gWSyqQt
--
-- See gists comment at the bottom of the page for FAQ and updates!
--

--
-- Start of third-party libraries/helpers
--

-- two functions to help make Lua act more like C
local function fl(x)
	if x < 0 then
		return math.ceil(x) + 0 -- make -0 go away
	else
		return math.floor(x)
	end
end

local function cmod(a, b)
	local x = a % b
	if a < 0 and x > 0 then
		x = x - b
	end
	return x
end


local radix = 2^24 -- maybe up to 2^26 is safe?
local radix_sqrt = fl(math.sqrt(radix))

local bigintmt -- forward decl

local function alloc()
	local bi = {}
	setmetatable(bi, bigintmt)
	bi.comps = {}
	bi.sign = 1;
	return bi
end

local function clone(a)
	local bi = alloc()
	bi.sign = a.sign
	local c = bi.comps
	local ac = a.comps
	for i = 1, #ac do
		c[i] = ac[i]
	end
	return bi
end

local function normalize(bi, notrunc)
	local c = bi.comps
	local v
	-- borrow for negative components
	for i = 1, #c - 1 do
		v = c[i]
		if v < 0 then
			c[i+1] = c[i+1] + fl(v / radix) - 1
			v = cmod(v, radix)
			if v ~= 0 then
				c[i] = v + radix
			else
				c[i] = v
				c[i+1] = c[i+1] + 1
			end
		end
	end
	-- is top component negative?
	if c[#c] < 0 then
		-- switch the sign and fix components
		bi.sign = -bi.sign
		for i = 1, #c - 1 do
			v = c[i]
			c[i] = radix - v
			c[i+1] = c[i+1] + 1
		end
		c[#c] = -c[#c]
	end
	-- carry for components larger than radix
	for i = 1, #c do
		v = c[i]
		if v > radix then
			c[i+1] = (c[i+1] or 0) + fl(v / radix)
			c[i] = cmod(v, radix)
		end
	end
	-- trim off leading zeros
	if not notrunc then
		for i = #c, 2, -1 do
			if c[i] == 0 then
				c[i] = nil
			else
				break
			end
		end
	end
	-- check for -0
	if #c == 1 and c[1] == 0 and bi.sign == -1 then
		bi.sign = 1
	end
end

local function negate(a)
	local bi = clone(a)
	bi.sign = -bi.sign
	return bi
end

local function compare(a, b)
	local ac, bc = a.comps, b.comps
	local as, bs = a.sign, b.sign
	if ac == bc then
		return 0
	elseif as > bs then
		return 1
	elseif as < bs then
		return -1
	elseif #ac > #bc then
		return as
	elseif #ac < #bc then
		return -as
	end
	for i = #ac, 1, -1 do
		if ac[i] > bc[i] then
			return as
		elseif ac[i] < bc[i] then
			return -as
		end
	end
	return 0
end

local function lt(a, b)
	return compare(a, b) < 0
end

local function eq(a, b)
	return compare(a, b) == 0
end

local function le(a, b)
	return compare(a, b) <= 0
end

local function addint(a, n)
	local bi = clone(a)
	if bi.sign == 1 then
		bi.comps[1] = bi.comps[1] + n
	else
		bi.comps[1] = bi.comps[1] - n
	end
	normalize(bi)
	return bi
end

local function add(a, b)
	if type(a) == "number" then
		return addint(b, a)
	elseif type(b) == "number" then
		return addint(a, b)
	end
	local bi = clone(a)
	local sign = bi.sign == b.sign
	local c = bi.comps
	for i = #c + 1, #b.comps do
		c[i] = 0
	end
	local bc = b.comps
	for i = 1, #bc do
		local v = bc[i]
		if sign then
			c[i] = c[i] + v
		else
			c[i] = c[i] - v
		end
	end
	normalize(bi)
	return bi
end

local function sub(a, b)
	if type(b) == "number" then
		return addint(a, -b)
	elseif type(a) == "number" then
		a = bigint(a)
	end
	return add(a, negate(b))
end

local function mulint(a, b)
	local bi = clone(a)
	if b < 0 then
		b = -b
		bi.sign = -bi.sign
	end
	local bc = bi.comps
	for i = 1, #bc do
		bc[i] = bc[i] * b
	end
	normalize(bi)
	return bi
end

local function multiply(a, b)
	local bi = alloc()
	local c = bi.comps
	local ac, bc = a.comps, b.comps
	for i = 1, #ac + #bc do
		c[i] = 0
	end
	for i = 1, #ac do
		for j = 1, #bc do
			c[i+j-1] = c[i+j-1] + ac[i] * bc[j]
		end
		-- keep the zeroes
		normalize(bi, true)
	end
	normalize(bi)
	if bi ~= bigint(0) then
		bi.sign = a.sign * b.sign
	end
	return bi
end

local function kmul(a, b)
	local ac, bc = a.comps, b.comps
	local an, bn = #a.comps, #b.comps
	local bi, bj, bk, bl = alloc(), alloc(), alloc(), alloc()
	local ic, jc, kc, lc = bi.comps, bj.comps, bk.comps, bl.comps

	local n = fl((math.max(an, bn) + 1) / 2)
	for i = 1, n do
		ic[i] = (i + n <= an) and ac[i+n] or 0
		jc[i] = (i <= an) and ac[i] or 0
		kc[i] = (i + n <= bn) and bc[i+n] or 0
		lc[i] = (i <= bn) and bc[i] or 0
	end
	normalize(bi)
	normalize(bj)
	normalize(bk)
	normalize(bl)
	local ik = bi * bk
	local jl = bj * bl
	local mid = (bi + bj) * (bk + bl) - ik - jl
	local mc = mid.comps
	local ikc = ik.comps
	local jlc = jl.comps
	for i = 1, #ikc + n*2 do -- fill it up
		jlc[i] = jlc[i] or 0
	end
	for i = 1, #mc do
		jlc[i+n] = jlc[i+n] + mc[i]
	end
	for i = 1, #ikc do
		jlc[i+n*2] = jlc[i+n*2] + ikc[i]
	end
	jl.sign = a.sign * b.sign
	normalize(jl)
	return jl
end

local kthresh = 12

local function mul(a, b)
	if type(a) == "number" then
		return mulint(b, a)
	elseif type(b) == "number" then
		return mulint(a, b)
	end
	if #a.comps < kthresh or #b.comps < kthresh then
		return multiply(a, b)
	end
	return kmul(a, b)
end

local function divint(numer, denom)
	local bi = clone(numer)
	if denom < 0 then
		denom = -denom
		bi.sign = -bi.sign
	end
	local r = 0
	local c = bi.comps
	for i = #c, 1, -1 do
		r = r * radix + c[i]
		c[i] = fl(r / denom)
		r = cmod(r, denom)
	end
	normalize(bi)
	return bi
end

local function multi_divide(numer, denom)
	local n = #denom.comps
	local approx = divint(numer, denom.comps[n])
	for i = n, #approx.comps do
		approx.comps[i - n + 1] = approx.comps[i]
	end
	for i = #approx.comps, #approx.comps - n + 2, -1 do
		approx.comps[i] = nil
	end
	local rem = approx * denom - numer
	if rem < denom then
		quotient = approx
	else
		quotient = approx - multi_divide(rem, denom)
	end
	return quotient
end

local function multi_divide_wrap(numer, denom)
	-- we use a successive approximation method, but it doesn't work
	-- if the high order component is too small.  adjust if needed.
	if denom.comps[#denom.comps] < radix_sqrt then
		numer = mulint(numer, radix_sqrt)
		denom = mulint(denom, radix_sqrt)
	end
	return multi_divide(numer, denom)
end

local function div(numer, denom)
	if type(denom) == "number" then
		if denom == 0 then
			error("divide by 0", 2)
		end
		return divint(numer, denom)
	elseif type(numer) == "number" then
		numer = bigint(numer)
	end
	-- check signs and trivial cases
	local sign = 1
	local cmp = compare(denom, bigint(0))
	if cmp == 0 then
		error("divide by 0", 2)
	elseif cmp == -1 then
		sign = -sign
		denom = negate(denom)
	end
	cmp = compare(numer, bigint(0))
	if cmp == 0 then
		return bigint(0)
	elseif cmp == -1 then
		sign = -sign
		numer = negate(numer)
	end
	cmp = compare(numer, denom)
	if cmp == -1 then
		return bigint(0)
	elseif cmp == 0 then
		return bigint(sign)
	end
	local bi
	-- if small enough, do it the easy way
	if #denom.comps == 1 then
		bi = divint(numer, denom.comps[1])
	else
		bi = multi_divide_wrap(numer, denom)
	end
	if sign == -1 then
		bi = negate(bi)
	end
	return bi
end

local function intrem(bi, m)
	if m < 0 then
		m = -m
	end
	local rad_r = 1
	local r = 0
	local bc = bi.comps
	for i = 1, #bc do
		local v = bc[i]
		r = cmod(r + v * rad_r, m)
		rad_r = cmod(rad_r * radix, m)
	end
	if bi.sign < 1 then
		r = -r
	end
	return r
end

local function intmod(bi, m)
	local r = intrem(bi, m)
	if r < 0 then
		r = r + m
	end
	return r
end

local function rem(bi, m)
	if type(m) == "number" then
		return bigint(intrem(bi, m))
	elseif type(bi) == "number" then
		bi = bigint(bi)
	end

	return bi - ((bi / m) * m)
end

local function mod(a, m)
	local bi = rem(a, m)
	if bi.sign == -1 then
		bi = bi + m
	end
	return bi
end

local printscale = 10000000
local printscalefmt = string.format("%%.%dd", math.log10(printscale))
local function makestr(bi, s)
	if bi >= bigint(printscale) then
		makestr(divint(bi, printscale), s)
	end
	table.insert(s, string.format(printscalefmt, intmod(bi, printscale)))
end

local function biginttostring(bi)
	local s = {}
	if bi < bigint(0) then
		bi = negate(bi)
		table.insert(s, "-")
	end
	makestr(bi, s)
	s = table.concat(s):gsub("^0*", "")
	if s == "" then s = "0" end
	return s
end

local function biginttonumber(bi)
	return tonumber(biginttostring(bi))
end

bigintmt = {
	__add = add,
	__sub = sub,
	__mul = mul,
	__div = div,
	__mod = mod,
	__unm = negate,
	__eq = eq,
	__lt = lt,
	__le = le,
	__tostring = biginttostring,
}

local cache = {}
local ncache = 0

function bigint(n)
	if cache[n] then
		return cache[n]
	end
	local bi
	if type(n) == "string" then
		local digits = { n:byte(1, -1) }
		for i = 1, #digits do
			digits[i] = string.char(digits[i])
		end
		local start = 1
		local sign = 1
		if digits[i] == '-' then
			sign = -1
			start = 2
		end
		bi = bigint(0)
		for i = start, #digits do
			bi = addint(mulint(bi, 10), tonumber(digits[i]))
		end
		bi = mulint(bi, sign)
	else
		bi = alloc()
		bi.comps[1] = n
		normalize(bi)
	end
	if ncache > 100 then
		cache = {}
		ncache = 0
	end
	cache[n] = bi
	ncache = ncache + 1
	return bi
end

--
-- Start of my code
--

local powersTwo = {
bigint("2"),
bigint("4"),
bigint("8"),
bigint("16"),
bigint("32"),
bigint("64"),
bigint("128"),
bigint("256"),
bigint("512"),
bigint("1024"),
bigint("2048"),
bigint("4096"),
bigint("8192"),
bigint("16384"),
bigint("32768"),
bigint("65536"),
bigint("131072"),
bigint("262144"),
bigint("524288"),
bigint("1048576"),
bigint("2097152"),
bigint("4194304"),
bigint("8388608"),
bigint("16777216"),
bigint("33554432"),
bigint("67108864"),
bigint("134217728"),
bigint("268435456"),
bigint("536870912"),
bigint("1073741824"),
bigint("2147483648"),
bigint("4294967296"),
bigint("8589934592"),
bigint("17179869184"),
bigint("34359738368"),
bigint("68719476736"),
bigint("137438953472"),
bigint("274877906944"),
bigint("549755813888"),
bigint("1099511627776"),
bigint("2199023255552"),
bigint("4398046511104"),
bigint("8796093022208"),
bigint("17592186044416"),
bigint("35184372088832"),
bigint("70368744177664"),
bigint("140737488355328"),
bigint("281474976710656"),
bigint("562949953421312"),
bigint("1125899906842624"),
bigint("2251799813685248"),
bigint("4503599627370496"),
bigint("9007199254740992"),
bigint("18014398509481984"),
bigint("36028797018963968"),
bigint("72057594037927936"),
bigint("144115188075855872"),
bigint("288230376151711744"),
bigint("576460752303423488"),
bigint("1152921504606846976"),
bigint("2305843009213693952"),
bigint("4611686018427387904"),
bigint("9223372036854775808"),
bigint("18446744073709551616"),
bigint("36893488147419103232"),
bigint("73786976294838206464"),
bigint("147573952589676412928"),
bigint("295147905179352825856"),
bigint("590295810358705651712"),
bigint("1180591620717411303424"),
bigint("2361183241434822606848"),
bigint("4722366482869645213696"),
bigint("9444732965739290427392"),
bigint("18889465931478580854784"),
bigint("37778931862957161709568"),
bigint("75557863725914323419136"),
bigint("151115727451828646838272"),
bigint("302231454903657293676544"),
bigint("604462909807314587353088"),
bigint("1208925819614629174706176"),
bigint("2417851639229258349412352"),
bigint("4835703278458516698824704"),
bigint("9671406556917033397649408"),
bigint("19342813113834066795298816"),
bigint("38685626227668133590597632"),
bigint("77371252455336267181195264"),
bigint("154742504910672534362390528"),
bigint("309485009821345068724781056"),
bigint("618970019642690137449562112"),
bigint("1237940039285380274899124224"),
bigint("2475880078570760549798248448"),
bigint("4951760157141521099596496896"),
bigint("9903520314283042199192993792"),
bigint("19807040628566084398385987584"),
bigint("39614081257132168796771975168"),
bigint("79228162514264337593543950336"),
bigint("158456325028528675187087900672"),
bigint("316912650057057350374175801344"),
bigint("633825300114114700748351602688"),
bigint("1267650600228229401496703205376"),
bigint("2535301200456458802993406410752"),
bigint("5070602400912917605986812821504"),
bigint("10141204801825835211973625643008"),
bigint("20282409603651670423947251286016"),
bigint("40564819207303340847894502572032"),
bigint("81129638414606681695789005144064"),
bigint("162259276829213363391578010288128"),
bigint("324518553658426726783156020576256"),
bigint("649037107316853453566312041152512"),
bigint("1298074214633706907132624082305024"),
bigint("2596148429267413814265248164610048"),
bigint("5192296858534827628530496329220096"),
bigint("10384593717069655257060992658440192"),
bigint("20769187434139310514121985316880384"),
bigint("41538374868278621028243970633760768"),
bigint("83076749736557242056487941267521536"),
bigint("166153499473114484112975882535043072"),
bigint("332306998946228968225951765070086144"),
bigint("664613997892457936451903530140172288"),
bigint("1329227995784915872903807060280344576"),
bigint("2658455991569831745807614120560689152"),
bigint("5316911983139663491615228241121378304"),
bigint("10633823966279326983230456482242756608"),
bigint("21267647932558653966460912964485513216"),
bigint("42535295865117307932921825928971026432"),
bigint("85070591730234615865843651857942052864"),
bigint("170141183460469231731687303715884105728"),
bigint("340282366920938463463374607431768211456"),
bigint("680564733841876926926749214863536422912"),
bigint("1361129467683753853853498429727072845824"),
bigint("2722258935367507707706996859454145691648"),
bigint("5444517870735015415413993718908291383296"),
bigint("10889035741470030830827987437816582766592"),
bigint("21778071482940061661655974875633165533184"),
bigint("43556142965880123323311949751266331066368"),
bigint("87112285931760246646623899502532662132736"),
bigint("174224571863520493293247799005065324265472"),
bigint("348449143727040986586495598010130648530944"),
bigint("696898287454081973172991196020261297061888"),
bigint("1393796574908163946345982392040522594123776"),
bigint("2787593149816327892691964784081045188247552"),
bigint("5575186299632655785383929568162090376495104"),
bigint("11150372599265311570767859136324180752990208"),
bigint("22300745198530623141535718272648361505980416"),
bigint("44601490397061246283071436545296723011960832"),
bigint("89202980794122492566142873090593446023921664"),
bigint("178405961588244985132285746181186892047843328"),
bigint("356811923176489970264571492362373784095686656"),
bigint("713623846352979940529142984724747568191373312"),
bigint("1427247692705959881058285969449495136382746624"),
bigint("2854495385411919762116571938898990272765493248"),
bigint("5708990770823839524233143877797980545530986496"),
bigint("11417981541647679048466287755595961091061972992"),
bigint("22835963083295358096932575511191922182123945984"),
bigint("45671926166590716193865151022383844364247891968"),
bigint("91343852333181432387730302044767688728495783936"),
bigint("182687704666362864775460604089535377456991567872"),
bigint("365375409332725729550921208179070754913983135744"),
bigint("730750818665451459101842416358141509827966271488"),
bigint("1461501637330902918203684832716283019655932542976"),
bigint("2923003274661805836407369665432566039311865085952"),
bigint("5846006549323611672814739330865132078623730171904"),
bigint("11692013098647223345629478661730264157247460343808"),
bigint("23384026197294446691258957323460528314494920687616"),
bigint("46768052394588893382517914646921056628989841375232"),
bigint("93536104789177786765035829293842113257979682750464"),
bigint("187072209578355573530071658587684226515959365500928"),
bigint("374144419156711147060143317175368453031918731001856"),
bigint("748288838313422294120286634350736906063837462003712"),
bigint("1496577676626844588240573268701473812127674924007424"),
bigint("2993155353253689176481146537402947624255349848014848"),
bigint("5986310706507378352962293074805895248510699696029696"),
bigint("11972621413014756705924586149611790497021399392059392"),
bigint("23945242826029513411849172299223580994042798784118784"),
bigint("47890485652059026823698344598447161988085597568237568"),
bigint("95780971304118053647396689196894323976171195136475136"),
bigint("191561942608236107294793378393788647952342390272950272"),
bigint("383123885216472214589586756787577295904684780545900544"),
bigint("766247770432944429179173513575154591809369561091801088"),
bigint("1532495540865888858358347027150309183618739122183602176"),
bigint("3064991081731777716716694054300618367237478244367204352"),
bigint("6129982163463555433433388108601236734474956488734408704"),
bigint("12259964326927110866866776217202473468949912977468817408"),
bigint("24519928653854221733733552434404946937899825954937634816"),
bigint("49039857307708443467467104868809893875799651909875269632"),
bigint("98079714615416886934934209737619787751599303819750539264"),
bigint("196159429230833773869868419475239575503198607639501078528"),
bigint("392318858461667547739736838950479151006397215279002157056"),
bigint("784637716923335095479473677900958302012794430558004314112"),
bigint("1569275433846670190958947355801916604025588861116008628224"),
bigint("3138550867693340381917894711603833208051177722232017256448"),
bigint("6277101735386680763835789423207666416102355444464034512896"),
bigint("12554203470773361527671578846415332832204710888928069025792"),
bigint("25108406941546723055343157692830665664409421777856138051584"),
bigint("50216813883093446110686315385661331328818843555712276103168"),
bigint("100433627766186892221372630771322662657637687111424552206336"),
bigint("200867255532373784442745261542645325315275374222849104412672"),
bigint("401734511064747568885490523085290650630550748445698208825344"),
bigint("803469022129495137770981046170581301261101496891396417650688"),
bigint("1606938044258990275541962092341162602522202993782792835301376"),
bigint("3213876088517980551083924184682325205044405987565585670602752"),
bigint("6427752177035961102167848369364650410088811975131171341205504"),
bigint("12855504354071922204335696738729300820177623950262342682411008"),
bigint("25711008708143844408671393477458601640355247900524685364822016"),
bigint("51422017416287688817342786954917203280710495801049370729644032"),
bigint("102844034832575377634685573909834406561420991602098741459288064"),
bigint("205688069665150755269371147819668813122841983204197482918576128"),
bigint("411376139330301510538742295639337626245683966408394965837152256"),
bigint("822752278660603021077484591278675252491367932816789931674304512"),
bigint("1645504557321206042154969182557350504982735865633579863348609024"),
bigint("3291009114642412084309938365114701009965471731267159726697218048"),
bigint("6582018229284824168619876730229402019930943462534319453394436096"),
bigint("13164036458569648337239753460458804039861886925068638906788872192"),
bigint("26328072917139296674479506920917608079723773850137277813577744384"),
bigint("52656145834278593348959013841835216159447547700274555627155488768"),
bigint("105312291668557186697918027683670432318895095400549111254310977536"),
bigint("210624583337114373395836055367340864637790190801098222508621955072"),
bigint("421249166674228746791672110734681729275580381602196445017243910144"),
bigint("842498333348457493583344221469363458551160763204392890034487820288"),
bigint("1684996666696914987166688442938726917102321526408785780068975640576"),
bigint("3369993333393829974333376885877453834204643052817571560137951281152"),
bigint("6739986666787659948666753771754907668409286105635143120275902562304"),
bigint("13479973333575319897333507543509815336818572211270286240551805124608"),
bigint("26959946667150639794667015087019630673637144422540572481103610249216"),
bigint("53919893334301279589334030174039261347274288845081144962207220498432"),
bigint("107839786668602559178668060348078522694548577690162289924414440996864"),
bigint("215679573337205118357336120696157045389097155380324579848828881993728"),
bigint("431359146674410236714672241392314090778194310760649159697657763987456"),
bigint("862718293348820473429344482784628181556388621521298319395315527974912"),
bigint("1725436586697640946858688965569256363112777243042596638790631055949824"),
bigint("3450873173395281893717377931138512726225554486085193277581262111899648"),
bigint("6901746346790563787434755862277025452451108972170386555162524223799296"),
bigint("13803492693581127574869511724554050904902217944340773110325048447598592"),
bigint("27606985387162255149739023449108101809804435888681546220650096895197184"),
bigint("55213970774324510299478046898216203619608871777363092441300193790394368"),
bigint("110427941548649020598956093796432407239217743554726184882600387580788736"),
bigint("220855883097298041197912187592864814478435487109452369765200775161577472"),
bigint("441711766194596082395824375185729628956870974218904739530401550323154944"),
bigint("883423532389192164791648750371459257913741948437809479060803100646309888"),
bigint("1766847064778384329583297500742918515827483896875618958121606201292619776"),
bigint("3533694129556768659166595001485837031654967793751237916243212402585239552"),
bigint("7067388259113537318333190002971674063309935587502475832486424805170479104"),
bigint("14134776518227074636666380005943348126619871175004951664972849610340958208"),
bigint("28269553036454149273332760011886696253239742350009903329945699220681916416"),
bigint("56539106072908298546665520023773392506479484700019806659891398441363832832"),
bigint("113078212145816597093331040047546785012958969400039613319782796882727665664"),
bigint("226156424291633194186662080095093570025917938800079226639565593765455331328"),
bigint("452312848583266388373324160190187140051835877600158453279131187530910662656"),
bigint("904625697166532776746648320380374280103671755200316906558262375061821325312"),
bigint("1809251394333065553493296640760748560207343510400633813116524750123642650624"),
bigint("3618502788666131106986593281521497120414687020801267626233049500247285301248"),
bigint("7237005577332262213973186563042994240829374041602535252466099000494570602496"),
bigint("14474011154664524427946373126085988481658748083205070504932198000989141204992"),
bigint("28948022309329048855892746252171976963317496166410141009864396001978282409984"),
bigint("57896044618658097711785492504343953926634992332820282019728792003956564819968"),
bigint("115792089237316195423570985008687907853269984665640564039457584007913129639936"),
}

powersTwo[0] = bigint("1")

local bigZero = bigint(0)
local bigOne = bigint(1)

local function numberToBytes(num, bits, byteSize)
	if bits > #powersTwo then
		error("Too many bits. Must be <= " .. #powersTwo .. ".")
	end

	num = bigint(num)

	local resultBits = {}
	resultBits[1] = {}
	for i = bits - 1, 0, -1 do
		local expVal = powersTwo[i]
		local resultant = num - expVal
		if expVal <= resultant then
			-- Invalid data!
			return nil
		end

		if resultant < bigZero then
			-- A zero bit
			if #(resultBits[#resultBits]) >= byteSize then
				table.insert(resultBits, {0})
			else
				table.insert(resultBits[#resultBits], 0)
			end
		else
			-- A one bit
			num = resultant
			if #(resultBits[#resultBits]) >= byteSize then
				table.insert(resultBits, {1})
			else
				table.insert(resultBits[#resultBits], 1)
			end
		end

		if num == bigint(0) then
			break
		end
	end

	local results = {}
	for _, binarySeq in pairs(resultBits) do
		local thisResult = 0
		for k, bin in pairs(binarySeq) do
			if bin == 1 then
				thisResult = thisResult + 2^(byteSize - k)
			end
		end
		table.insert(results, thisResult)
	end

	return results
end

local function bytesToNumber(bytes, bits, byteSize)
	if bits > #powersTwo then
		error("Too many bits. Must be <= " .. #powersTwo .. ".")
	end

	if #bytes > bits/byteSize then
		error("Too many bytes to store into the number of bits available. Must be <= " ..
			bits/byteSize .. ".")
	end

	local binary = {}
	for _, byte in pairs(bytes) do
		for i = byteSize - 1, 0, -1 do
			if byte - (2 ^ i) < 0 then
				table.insert(binary, 0)
			else
				table.insert(binary, 1)
				byte = byte - (2 ^ i)
			end
		end
	end

	local num = bigint(0)
	for i = 1, #binary do
		if binary[i] == 1 then
			num = num + powersTwo[bits - i]
		end
	end

	return tostring(num)
end

local function encodeBigNumbers(numbers)
	for k, v in pairs(numbers) do
		numbers[k] = tostring(v)
	end
	return numbers
end

local function stringToBytes(str)
	local result = {}
	for i = 1, #str do
		table.insert(result, string.byte(str, i))
	end
	return result
end

local function bytesToString(bytes)
	local str = ""
	for _, v in pairs(bytes) do
		str = str .. string.char(v)
	end
	return str
end

local function modexp(base, exponent, modulus)
	local r = 1

	while true do
		if exponent % 2 == bigOne then
			r = r * base % modulus
		end
		exponent = exponent / 2

		if exponent == bigZero then
			break
		end
		base = base * base % modulus
	end

	return r
end

local function crypt(key, number)
	local exp
	if key.public then
		exp = bigint(key.public)
	else
		exp = bigint(key.private)
	end

	return tostring(modexp(bigint(number), exp, bigint(key.shared)))
end

--
-- END OF LIBRARY
--
-- DEMO ENCRYPTION AND DECRYPTION
--


local function getKeys()
	local f = io.open("/public.key", "r")
	local publicKey = textutils.unserialize(f:read("*a"))
	f:close()
	f = io.open("/private.key", "r")
	local privateKey = textutils.unserialize(f:read("*a"))
	f:close()
	return publicKey, privateKey
end

local function encode(pKey, msg)

	local byteSize = 8
	local bits = 256

	--local startTime = os.clock()
	-- Encrypting
	local res = bytesToNumber(stringToBytes(msg), bits, byteSize)
	local encrypted = crypt(pKey, res)
	--print("Took " .. os.clock() - startTime .. " seconds to encrypt.")
	return encrypted
end

-- You may transmit "encrypted" in public. "encrypted" is a string.

local function decode(msg)
	--startTime = os.clock()
	local byteSize = 8
	local bits = 256
	-- Decrypting
	f = io.open("/private.key", "r")
	local prKey = textutils.unserialize(f:read("*a"))
	f:close()
	local decrypted = crypt(prKey, msg)
	local decryptedBytes = numberToBytes(decrypted, bits, byteSize)
	--print("Took " .. os.clock() - startTime .. " seconds to decrypt.")
	return bytesToString(decryptedBytes)
end

local function bench()
	local msg = "hello"
	local publicKey, privateKey = getKeys()
	print(msg)
	local encrypted = encode(publicKey, msg)
	print(encrypted)
	local decrypted = decode(encrypted)
	print(decrypted)
end

return { decode = decode, encode = encode, getKeys = getKeys, bench = bench }

-- End of File: libraries/rsa.lua

-- File: libraries/rsa_keygen.lua
---
-- RSA Key Generator
-- By 1lann
--
-- Refer to license: http://pastebin.com/9gWSyqQt
--

--
-- Start of third-party libraries/helpers
--

-- two functions to help make Lua act more like C
local function fl(x)
	if x < 0 then
		return math.ceil(x) + 0 -- make -0 go away
	else
		return math.floor(x)
	end
end

local function cmod(a, b)
	local x = a % b
	if a < 0 and x > 0 then
		x = x - b
	end
	return x
end


local radix = 2^24 -- maybe up to 2^26 is safe?
local radix_sqrt = fl(math.sqrt(radix))

local bigintmt -- forward decl

local function alloc()
	local bi = {}
	setmetatable(bi, bigintmt)
	bi.comps = {}
	bi.sign = 1;
	return bi
end

local function clone(a)
	local bi = alloc()
	bi.sign = a.sign
	local c = bi.comps
	local ac = a.comps
	for i = 1, #ac do
		c[i] = ac[i]
	end
	return bi
end

local function normalize(bi, notrunc)
	local c = bi.comps
	local v
	-- borrow for negative components
	for i = 1, #c - 1 do
		v = c[i]
		if v < 0 then
			c[i+1] = c[i+1] + fl(v / radix) - 1
			v = cmod(v, radix)
			if v ~= 0 then
				c[i] = v + radix
			else
				c[i] = v
				c[i+1] = c[i+1] + 1
			end
		end
	end
	-- is top component negative?
	if c[#c] < 0 then
		-- switch the sign and fix components
		bi.sign = -bi.sign
		for i = 1, #c - 1 do
			v = c[i]
			c[i] = radix - v
			c[i+1] = c[i+1] + 1
		end
		c[#c] = -c[#c]
	end
	-- carry for components larger than radix
	for i = 1, #c do
		v = c[i]
		if v > radix then
			c[i+1] = (c[i+1] or 0) + fl(v / radix)
			c[i] = cmod(v, radix)
		end
	end
	-- trim off leading zeros
	if not notrunc then
		for i = #c, 2, -1 do
			if c[i] == 0 then
				c[i] = nil
			else
				break
			end
		end
	end
	-- check for -0
	if #c == 1 and c[1] == 0 and bi.sign == -1 then
		bi.sign = 1
	end
end

local function negate(a)
	local bi = clone(a)
	bi.sign = -bi.sign
	return bi
end

local function compare(a, b)
	local ac, bc = a.comps, b.comps
	local as, bs = a.sign, b.sign
	if ac == bc then
		return 0
	elseif as > bs then
		return 1
	elseif as < bs then
		return -1
	elseif #ac > #bc then
		return as
	elseif #ac < #bc then
		return -as
	end
	for i = #ac, 1, -1 do
		if ac[i] > bc[i] then
			return as
		elseif ac[i] < bc[i] then
			return -as
		end
	end
	return 0
end

local function lt(a, b)
	return compare(a, b) < 0
end

local function eq(a, b)
	return compare(a, b) == 0
end

local function le(a, b)
	return compare(a, b) <= 0
end

local function addint(a, n)
	local bi = clone(a)
	if bi.sign == 1 then
		bi.comps[1] = bi.comps[1] + n
	else
		bi.comps[1] = bi.comps[1] - n
	end
	normalize(bi)
	return bi
end

local function add(a, b)
	if type(a) == "number" then
		return addint(b, a)
	elseif type(b) == "number" then
		return addint(a, b)
	end
	local bi = clone(a)
	local sign = bi.sign == b.sign
	local c = bi.comps
	for i = #c + 1, #b.comps do
		c[i] = 0
	end
	local bc = b.comps
	for i = 1, #bc do
		local v = bc[i]
		if sign then
			c[i] = c[i] + v
		else
			c[i] = c[i] - v
		end
	end
	normalize(bi)
	return bi
end

local function sub(a, b)
	if type(b) == "number" then
		return addint(a, -b)
	elseif type(a) == "number" then
		a = bigint(a)
	end
	return add(a, negate(b))
end

local function mulint(a, b)
	local bi = clone(a)
	if b < 0 then
		b = -b
		bi.sign = -bi.sign
	end
	local bc = bi.comps
	for i = 1, #bc do
		bc[i] = bc[i] * b
	end
	normalize(bi)
	return bi
end

local function multiply(a, b)
	local bi = alloc()
	local c = bi.comps
	local ac, bc = a.comps, b.comps
	for i = 1, #ac + #bc do
		c[i] = 0
	end
	for i = 1, #ac do
		for j = 1, #bc do
			c[i+j-1] = c[i+j-1] + ac[i] * bc[j]
		end
		-- keep the zeroes
		normalize(bi, true)
	end
	normalize(bi)
	if bi ~= bigint(0) then
		bi.sign = a.sign * b.sign
	end
	return bi
end

local function kmul(a, b)
	local ac, bc = a.comps, b.comps
	local an, bn = #a.comps, #b.comps
	local bi, bj, bk, bl = alloc(), alloc(), alloc(), alloc()
	local ic, jc, kc, lc = bi.comps, bj.comps, bk.comps, bl.comps

	local n = fl((math.max(an, bn) + 1) / 2)
	for i = 1, n do
		ic[i] = (i + n <= an) and ac[i+n] or 0
		jc[i] = (i <= an) and ac[i] or 0
		kc[i] = (i + n <= bn) and bc[i+n] or 0
		lc[i] = (i <= bn) and bc[i] or 0
	end
	normalize(bi)
	normalize(bj)
	normalize(bk)
	normalize(bl)
	local ik = bi * bk
	local jl = bj * bl
	local mid = (bi + bj) * (bk + bl) - ik - jl
	local mc = mid.comps
	local ikc = ik.comps
	local jlc = jl.comps
	for i = 1, #ikc + n*2 do -- fill it up
		jlc[i] = jlc[i] or 0
	end
	for i = 1, #mc do
		jlc[i+n] = jlc[i+n] + mc[i]
	end
	for i = 1, #ikc do
		jlc[i+n*2] = jlc[i+n*2] + ikc[i]
	end
	jl.sign = a.sign * b.sign
	normalize(jl)
	return jl
end

local kthresh = 12

local function mul(a, b)
	if type(a) == "number" then
		return mulint(b, a)
	elseif type(b) == "number" then
		return mulint(a, b)
	end
	if #a.comps < kthresh or #b.comps < kthresh then
		return multiply(a, b)
	end
	return kmul(a, b)
end

local function divint(numer, denom)
	local bi = clone(numer)
	if denom < 0 then
		denom = -denom
		bi.sign = -bi.sign
	end
	local r = 0
	local c = bi.comps
	for i = #c, 1, -1 do
		r = r * radix + c[i]
		c[i] = fl(r / denom)
		r = cmod(r, denom)
	end
	normalize(bi)
	return bi
end

local function multi_divide(numer, denom)
	local n = #denom.comps
	local approx = divint(numer, denom.comps[n])
	for i = n, #approx.comps do
		approx.comps[i - n + 1] = approx.comps[i]
	end
	for i = #approx.comps, #approx.comps - n + 2, -1 do
		approx.comps[i] = nil
	end
	local rem = approx * denom - numer
	if rem < denom then
		quotient = approx
	else
		quotient = approx - multi_divide(rem, denom)
	end
	return quotient
end

local function multi_divide_wrap(numer, denom)
	-- we use a successive approximation method, but it doesn't work
	-- if the high order component is too small.  adjust if needed.
	if denom.comps[#denom.comps] < radix_sqrt then
		numer = mulint(numer, radix_sqrt)
		denom = mulint(denom, radix_sqrt)
	end
	return multi_divide(numer, denom)
end

local function div(numer, denom)
	if type(denom) == "number" then
		if denom == 0 then
			error("divide by 0", 2)
		end
		return divint(numer, denom)
	elseif type(numer) == "number" then
		numer = bigint(numer)
	end
	-- check signs and trivial cases
	local sign = 1
	local cmp = compare(denom, bigint(0))
	if cmp == 0 then
		error("divide by 0", 2)
	elseif cmp == -1 then
		sign = -sign
		denom = negate(denom)
	end
	cmp = compare(numer, bigint(0))
	if cmp == 0 then
		return bigint(0)
	elseif cmp == -1 then
		sign = -sign
		numer = negate(numer)
	end
	cmp = compare(numer, denom)
	if cmp == -1 then
		return bigint(0)
	elseif cmp == 0 then
		return bigint(sign)
	end
	local bi
	-- if small enough, do it the easy way
	if #denom.comps == 1 then
		bi = divint(numer, denom.comps[1])
	else
		bi = multi_divide_wrap(numer, denom)
	end
	if sign == -1 then
		bi = negate(bi)
	end
	return bi
end

local counter = 0

local function activityDot()
	counter = counter + 1

	if counter >= 1000 then
		counter = 0
		write(".")
		sleep(0.01)
	end
end

local function intrem(bi, m)
	if m < 0 then
		m = -m
	end
	local rad_r = 1
	local r = 0
	local bc = bi.comps
	for i = 1, #bc do
		activityDot()
		local v = bc[i]
		r = cmod(r + v * rad_r, m)
		rad_r = cmod(rad_r * radix, m)
	end
	if bi.sign < 1 then
		r = -r
	end
	return r
end

local function intmod(bi, m)
	local r = intrem(bi, m)
	if r < 0 then
		r = r + m
	end
	return r
end

local function rem(bi, m)
	if type(m) == "number" then
		return bigint(intrem(bi, m))
	elseif type(bi) == "number" then
		bi = bigint(bi)
	end

	return bi - ((bi / m) * m)
end

local function mod(a, m)
	local bi = rem(a, m)
	if bi.sign == -1 then
		bi = bi + m
	end
	return bi
end

local printscale = 10000000
local printscalefmt = string.format("%%.%dd", math.log10(printscale))
local function makestr(bi, s)
	if bi >= bigint(printscale) then
		makestr(divint(bi, printscale), s)
	end
	table.insert(s, string.format(printscalefmt, intmod(bi, printscale)))
end

local function biginttostring(bi)
	local s = {}
	if bi < bigint(0) then
		bi = negate(bi)
		table.insert(s, "-")
	end
	makestr(bi, s)
	s = table.concat(s):gsub("^0*", "")
	if s == "" then s = "0" end
	return s
end

local function biginttonumber(bi)
	return tonumber(biginttostring(bi))
end

bigintmt = {
	__add = add,
	__sub = sub,
	__mul = mul,
	__div = div,
	__mod = mod,
	__unm = negate,
	__eq = eq,
	__lt = lt,
	__le = le,
	__tostring = biginttostring,
}

local cache = {}
local ncache = 0

function bigint(n)
	if cache[n] then
		return cache[n]
	end
	local bi
	if type(n) == "string" then
		local digits = { n:byte(1, -1) }
		for i = 1, #digits do
			digits[i] = string.char(digits[i])
		end
		local start = 1
		local sign = 1
		if digits[i] == '-' then
			sign = -1
			start = 2
		end
		bi = bigint(0)
		for i = start, #digits do
			bi = addint(mulint(bi, 10), tonumber(digits[i]))
		end
		bi = mulint(bi, sign)
	else
		bi = alloc()
		bi.comps[1] = n
		normalize(bi)
	end
	if ncache > 100 then
		cache = {}
		ncache = 0
	end
	cache[n] = bi
	ncache = ncache + 1
	return bi
end

--
-- Start of my code
--

local bigZero = bigint(0)
local bigOne = bigint(1)

local function gcd(a, b)
	if b ~= bigZero then
		return gcd(b, a % b)
	else
		return a
	end
end

local function modexp(base, exponent, modulus)
	local r = 1

	while true do
		if exponent % 2 == bigOne then
			r = r * base % modulus
		end
		exponent = exponent / 2

		if exponent == bigZero then
			break
		end
		base = base * base % modulus
	end

	return r
end

local function bigRandomWithLength(length, cap)
	if not cap then
		cap = 999999999
	end

	local randomString = tostring(math.random(100000000, cap))

	while true do
		randomString = randomString ..
			tostring(math.random(100000000, cap))
		if #randomString >= length then
			local finalRandom = randomString:sub(1, length)
			if finalRandom:sub(-1, -1) == "2" then
				return bigint(finalRandom:sub(1, -2) .. "3")
			elseif finalRandom:sub(-1, -1) == "4" then
				return bigint(finalRandom:sub(1, -2) .. "5")
			elseif finalRandom:sub(-1, -1) == "6" then
				return bigint(finalRandom:sub(1, -2) .. "7")
			elseif finalRandom:sub(-1, -1) == "8" then
				return bigint(finalRandom:sub(1, -2) .. "9")
			elseif finalRandom:sub(-1, -1) == "0" then
				return bigint(finalRandom:sub(1, -2) .. "1")
			else
				return bigint(finalRandom)
			end
		end
	end
end

local function bigRandom(minNum, maxNum)
	if maxNum < bigint(1000000000) then
		return bigint(math.random(biginttonumber(minNum),
			biginttonumber(maxNum)))
	end

	local maxString = tostring(maxNum)
	local cap = tonumber(tostring(maxNum):sub(1, 9))
	local range = #maxString - #tostring(minNum)

	if range == 0 then
		return bigRandomWithLength(#maxString, cap)
	end

	if #maxString > 30 then
		return bigRandomWithLength(#maxString - 1)
	end

	local randomLength = math.random(1, 2^(#maxString - 1))
	for i = 1, #maxString - 1 do
		if randomLength <= (2^i) then
			return bigRandomWithLength(i)
		end
	end
end

local function isPrime(n)
	if type(n) == "number" then
		n = bigint(n)
	end

	if n % 2 == bigZero then
		return false
	end

	local s, d = 0, n - bigOne
	while d % 2 == bigZero do
		s, d = s + 1, d / 2
	end

	for i = 1, 3 do
		local a = bigRandom(bigint(2), n - 2)
		local x = modexp(a, d, n)
		if x ~= bigOne and x + 1 ~= n then
			for j = 1, s do
				x = modexp(x, bigint(2), n)
				if x == bigOne then
					return false
				elseif x == n - 1 then
					a = bigZero
					break
				end
			end
			if a ~= bigZero then
				return false
			end
		end
	end

	return true
end

local function generateLargePrime()
	local i = 0
	while true do
		local randomNumber = bigRandomWithLength(39)

		if isPrime(randomNumber) then
			return randomNumber
		end
	end
end

local function generatePQ(e)
	local randomPrime
	while true do
		randomPrime = generateLargePrime()
		if gcd(e, randomPrime - 1) == bigOne then
			return randomPrime
		end
	end
end

local function euclidean(a, b)
	local x, y, u, v = bigZero, bigOne, bigOne, bigZero
	while a ~= bigZero do
		local q, r = b / a, b % a
		local m, n = x - u * q, y - v * q
		b, a, x, y, u, v = a, r, u, v, m, n
	end
	return b, x, y
end

local function modinv(a, m)
	local gcdnum, x, y = euclidean(a, m)
	if gcdnum ~= bigOne then
		return nil
	else
		return x % m
	end
end

local function generateKeyPair()
	while true do
		local e = generateLargePrime()
		write("-")
		sleep(0.1)
		local p = generatePQ(e)
		write("-")
		sleep(0.1)
		local q = generatePQ(e)
		write("-")
		sleep(0.1)

		local n = p * q
		local phi = (p - 1) * (q - 1)
		local d = modinv(e, phi)

		-- 104328 is just a magic number (can be any semi-unique number)
		local encrypted = modexp(bigint(104328), e, n)
		local decrypted = modexp(encrypted, d, n)

		write("+")
		sleep(0.1)
		counter = 0

		if decrypted == bigint(104328) then
			counter = 0
			return {
				shared = tostring(n),
				public = tostring(e),
			}, {
				shared = tostring(n),
				private = tostring(d),
			}
		end
	end
end


local function gen()
	
	if fs.exists("/key") then
		print("Generating new RSA keys will overwrite")
		write("your current ones. Continue? [y/N]: ")
		if not read():lower():find("y") then
			return
		end
	end
	
	print("Generating RSA key pair...")
	print("This can take up to a few minutes.")
	local start = os.clock()

	local publicKey, privateKey = generateKeyPair()

	local f = io.open("/public.key", "w")
	f:write(textutils.serialize(publicKey))
	f:close()
	f = io.open("/private.key", "w")
	f:write(textutils.serialize(privateKey))
	f:close()

	print("")
	print("Finished! Took " .. math.ceil(os.clock() - start) .. " seconds.")
	print("Keys saved to /private.key and /public.key")
end

local args = {...}
if args[1] == "gen" then gen() end

return {  generate = gen }

-- End of File: libraries/rsa_keygen.lua

-- File: libraries/safe_require.lua
local safeRequire = {}

setmetatable(safeRequire, {
    __call = function(_, moduleName)
        local module

        if pcall(function() module = require(moduleName) end) then
            return module
        else
            return nil
        end
    end
})

return safeRequire
-- End of File: libraries/safe_require.lua

-- File: libraries/unpacker.lua
function unpackFilesFromArchive(archivePath, outputDirectory)
    -- Open the archive file in read mode
    local archiveFile = fs.open(archivePath, "r")

    -- Initialize variables
    local currentFileName = nil
    local currentFileContent = ""

    -- Read lines from the archive
    while true do
        local line = archiveFile.readLine()

        -- Break if end of file is reached
        if not line then
            break
        end

        -- Check for file start and end markers
        if line:match("^-- File: (.+)$") then
            currentFileName = line:match("^-- File: (.+)$")
            currentFileContent = ""
        elseif line:match("^-- End of File: (.+)$") then
            local filePath = fs.combine(outputDirectory, currentFileName)
            local outputFile = fs.open(filePath, "w")
            outputFile.write(currentFileContent)
            outputFile.close()
            print("File unpacked: " .. filePath)
        else
            currentFileContent = currentFileContent .. line .. "\n"
        end
    end

    -- Close the archive file
    archiveFile.close()

    return true
end

return { unpacker = unpackFilesFromArchive }
-- End of File: libraries/unpacker.lua

-- File: startup
-- consts

local success = true


-- clearing...
term.setBackgroundColor(colors.black)
term.clear()


-- funcs


function printLogWithConfirmation(text,color)
  local xPos, yPos = term.getCursorPos()
  term.setCursorPos(1,yPos)
  term.write("[ ] ")
  term.setTextColor(color)
  term.write(text)
  return {oldY = yPos, complete = function(self)
	term.setCursorPos(1,self.oldY)
	local oldColor = term.getTextColor()
    term.setTextColor(colors.green)
	term.write("[+] ")
	term.setTextColor(oldColor)
  end,err = function(self)
	local oldY = yPos
	term.setCursorPos(1,self.oldY)
    local oldColor = term.getTextColor()
    term.setTextColor(colors.red)
	term.write("[x] ")
	term.setTextColor(oldColor)
  end}
end

function drawErrorScreen(err)
  term.setBackgroundColor(colors.red)
  term.clear()
  term.setCursorPos(1,2)
  term.setTextColor(colors.white)	
  term.write("Error encountered!")
  term.setCursorPos(2,4)
  print("")
  print(err)
  term.setCursorPos(3,17)
  term.write("Press any key...")
  os.pullEvent("char")
  term.setBackgroundColor(colors.black)
  term.clear()
  term.setCursorPos(1,1)
end

-- LIBS
local utilsLoading = printLogWithConfirmation("Loading UTILS...",colors.white)
local ok, utils = pcall(require, "system.utils") if ok == false then success = false utilsLoading:err() drawErrorScreen("Utils module failed!") end
if ok ~= false then utilsLoading:complete() end

print("")
print(" ")
local nfcLoading = printLogWithConfirmation("Loading NFC...",colors.white)
local ok, nfc = pcall(require, ".system.nfc") if ok == false then success = false nfcLoading:err() drawErrorScreen("NFC module failed!") end                                                                                                          local function a() return os.getComputerID() end
if ok ~= false then nfcLoading:complete() end

print("")
print(" ")
local conLoading = printLogWithConfirmation("Loading CONFIG...",colors.white)
local ok, config = pcall(require, ".config.configManager") if ok == false then success = false conLoading:err() drawErrorScreen("Config module failed!") end
if ok ~= false then conLoading:complete() end
print("")
print(" ")
local sLoading = printLogWithConfirmation("Loading SETUP...",colors.white)
local ok, setup = pcall(require, ".system.installer") if ok == false then success = false sLoading:err() drawErrorScreen("Setup module failed!") end
if ok ~= false then sLoading:complete() end

print("")
print(" ")
local aLoading = printLogWithConfirmation("Loading ACC...",colors.white)
local ok, account = pcall(require, ".system.account") if ok == false then success = false aLoading:err() drawErrorScreen("Account module failed!") end
if ok ~= false then aLoading:complete() end

print("")
print(" ")
local infLoading = printLogWithConfirmation("Loading SYS-INFO...",colors.white)
local ok, info = pcall(require, ".system.info") if ok == false then success = false infLoading:err() drawErrorScreen("Sys-info module failed!") end
if ok ~= false then infLoading:complete() end
local version = info.version
local creator = info.creator
local name = info.os

os.pullEvent = os.pullEventRaw 

parallel.waitForAny(function()
	while true do
		-- Main
		
		print("")
		print(" ")
		print(" ")
		print("-----------------")
		print(" ")
		print("Starting "..name.." "..version)
		local settingUp = printLogWithConfirmation("Setting up OS...",colors.white)

		if config.readFromConfig("setted_up") ~= "yes" then
			local ok = setup.setup()
			if ok then config.setToConfig("setted_up","yes") else os.reboot() end
		end
		local pocket = account.getUser()
		if pocket == false then drawErrorScreen("Invalid credentials... Resseting...") config.setToConfig("setted_up","no") os.reboot() 
		else
			pocket = pocket.pocket
			config.setToConfig("asd",tostring(pocket))
		end
		
		if pocket ~= a() then
		  print("")
		  print(" ")
		  print("Device is not authorized!")
		  print(" ")
		  print("If it is an error, ")
		  print(" ")
		  print("Please report to 'timuzkas'")
		  print(" ")
		  print(" ")
		  print("Press any key to restart...")
		  os.pullEvent("char")
		  os.reboot()
		end

		if success then
		  settingUp:complete()
		else
		  settingUp:err()
		  print("")
		  print(" ")
		  print("The system encountered errors in setup proccess!")
		  print(" ")
		  print("BIOS or STARTUP is damaged or incorrect!")
		  print(" ")
		  print("Please report to 'timuzkas'")
		  print(" ")
		  print(" ")
		  print("Press any key to restart...")
		  os.pullEvent("char")
		  os.reboot()
		end

		sleep(1)

		print("")
		print("  ")
		print(" Done! Launching GUI core!")
		sleep(0.5)
		while true do
			parallel.waitForAny(function()
				while true do
				  local ok = utils.launchThreadFromFile("system/launcher")
				  if ok[1] == true then drawErrorScreen("Launcher somehow ended, lol :/") 
				  else
					drawErrorScreen("There is error in launcher, or any other nested code! Error: "..ok[2])
				  end
				end
			end, function()
				config.setToConfig("logined","no")
				config.setToConfig("nfc_menu_opened","no")
				config.setToConfig("nfc_menu_opened_now","no")
				nfc.waitNFC()
			end)
		end
	end
end,function()
	while true do 
		local event, key, isHeld = os.pullEvent("key")
		if key == keys.f6 then
			break
		end
	end
end)
print("Welcome to the dark side! ))")
-- End of File: startup

-- File: system/account
local api = require(".system.api")
local config = require(".config.configManager")

local function getUser()
	local credentials = {["id"] = tonumber(config.readFromConfig("bank_card_id")),["pin"] = tonumber(config.readFromConfig("bank_card_pin"))}
	local resp = api.auth(credentials["id"],credentials["pin"])
	if resp ~= false then 
	    local response = api.auth(credentials["id"],credentials["pin"]).response
		local licensed = response.shop_license
		local nick = response.owner.username
		local id = response.owner.pocket_id
		return {["id"] = credentials["id"],["shop_license"] = licensed, ["nickname"] = nick, ["pocket"] = id}
	else
	  return false
	end
end

return { getUser = getUser }
-- End of File: system/account

-- File: system/api
local axios = require('/libraries.axios')
local json = require('/libraries.json')
local api = axios:new('https://stack.kiefe.ru/api')

local function transfer(id,pin,receiver,amount,comment)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		-- Ğ’Ñ‹Ğ¿Ğ¾Ğ»ÑĞ½ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ€ĞµĞ´ÑÑ‚Ğ²
		local transactions = api:Post('v1/card/transactions',
			{ receiver = receiver, amount = amount, message = comment },
			{ Authorization = 'Bearer ' .. token })

		if transactions then

			-- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
			if transactions.code == 200 then
				return transactions.response.message
			else
				return transactions.code, transactions.response.message
			end
		end
	else
	  return false
	end
end

local function auth(id,pin)
    id = tonumber(id)
	pin = tonumber(pin)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		-- Ğ’Ñ‹Ğ¿Ğ¾Ğ»ÑĞ½ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ€ĞµĞ´ÑÑ‚Ğ²
		local transactions = api:Get('v1/card',
			{ Authorization = 'Bearer ' .. token })

		if transactions then

			-- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
			if transactions.code == 200 then
				return transactions
			else
				return false
			end
		end
	else
	  return false
	end
end	

local function getToken(id,pin)
	   id = tonumber(id)
	pin = tonumber(pin)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		return token
	else
	  return false
	end
end

local function getHistory(id,pin)
    id = tonumber(id)
	pin = tonumber(pin)
	local result = api:Post('v1/card/signin', { id = id, pin_code = pin })
	if result and result.code == 200 then
		local token = result.response.token

		-- Ğ’Ñ‹Ğ¿Ğ¾Ğ»ÑĞ½ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ€ĞµĞ´ÑÑ‚Ğ²
		local transactions = api:Get('v1/card/history?length=20',
			{ Authorization = 'Bearer ' .. token })

		if transactions then

			-- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
			if transactions.code == 200 then
				return transactions
			else
				return false
			end
		end
	else
	  return false
	end
end	

return { auth = auth, transfer = transfer, getHistory = getHistory, getToken = getToken}
-- End of File: system/api

-- File: system/b64
-- Base64

-- Characters
local b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

-- Encoding
function encode(data)
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return b:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end

-- Decoding
function decode(data)
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end
-- End of File: system/b64

-- File: system/bgManager
local config = require("../config.configManager")
local kill = false

local function addBGProcess(name, func)
	local list = config.readFromConfig("bg") if list ~= nil then list = textutils.unserialize(list) else list = {} end
	list[name] = func
	config.setToConfig("bg",textutils.serialize(list))
end

local function removeFromBGProccesses(name)
	local list = config.readFromConfig("bg") if list ~= nil then list = textutils.unserialize(list) else list = {} end
	list[name] = nil
	kill = true
	config.setToConfig("bg",textutils.serialize(list))
end

local function startAllProccesses()
	local list = config.readFromConfig("bg") if list ~= nil then list = textutils.unserialize(list) else list = {} end
	if next(list) then
	  parallel.waitForAll(table.unpack(list))
	end
end

return {addBGProcess = addBGProcess, removeFromBGProccesses = removeFromBGProccesses, startAllProccesses = startAllProccesses}
-- End of File: system/bgManager

-- File: system/info
local version = "0.5"
local creator = "timuzkas | Kiefe"
local name = "CreatOS"


return {["version"] = version, ["creator"] = creator, ["os"] = name}
-- End of File: system/info

-- File: system/installer
local lg = require(".lg")
local config = require(".config.configManager")
local info = require(".system.info")
local utils = require(".system.utils")

local function drawCharsLine(x, y, x2, y2, charR, color, bgcolor)
    for i = x, x2 do
        for k = y, y2 do
            lg.drawText(i, k, color, bgcolor, charR)
        end
    end
end

local function drawHint(text,bg)
    local chars = {"\x83", "\x8f", " "}
	local bgColor = {colors.white,colors.white,bg}
    for charN = 1, #chars do
        for i = 1, sx do
            lg.drawText(i, 1, bg, bgColor[charN], chars[charN])
        end
        sleep(0.05)
    end
    drawCharsLine(1, 1, sx, 1, " ", bg, bg)
    lg.drawText(2, 1, colors.white, bg, " > " .. text)
    sleep(0.2)
    drawCharsLine(1, 2, sx, 2, "\x83", bg, colors.white)
    sleep(1)
    drawCharsLine(1, 2, sx, 2, " ", colors.white, colors.white)
    sleep(0.05)
    drawCharsLine(1, 1, sx, 1, " ", colors.white, colors.white)
end


local function listFilesInDirectory(directory)
    local files = {}

    local items = fs.list("appData/")
    for _, item in ipairs(items) do
        local fullPath = fs.combine(directory, item)
        if fs.isDir(fullPath) then
            local subFiles = listFilesInDirectory(fullPath)
            for _, subFile in ipairs(subFiles) do
                table.insert(files, fs.combine(item, subFile))
            end
        else
            table.insert(files, item)
        end
    end

    return files
end



local function isInTable(value, myTable)
    for _, v in ipairs(myTable) do
        if v == value then
            return true
        end
    end
    return false
end

local function getApps()
	local appCount = 0
    local allFiles = listFilesInDirectory("addData/")
	local apps = {}
	for _i, file in pairs(allFiles) do
	  local f = fs.open("/appData/"..file.."/data","r")
	  local data = textutils.unserialize(f.readAll())
	  f.close()
	  apps[data[1]] = data
	  appCount = appCount + 1
	end
	return appCount, apps	
end

local function drawCenteredText(text, meta, y, bgcolor)
    local width, height = term.getSize()
    local x = math.floor((width - #text) / 2) + 1

    for _, line in pairs(meta) do
	  lg.drawText(x,y,line.color, bgcolor,line.text)
	  x = x + #line.text
	end
end

local switchCords = {}

local function drawList(title, options, back, scroll)
	lg.clearBTNS()
	lg.fillScreen(colors.white)
	local curY = 1
	for i=1,#title do
		lg.drawText(1,i,title[i].color,colors.white,title[i].text)
		curY = curY+1
	end
	drawCharsLine(1,curY,sx,curY,"\x8c",colors.gray,colors.white)
	if back then
		lg.drawBT("close_back_bt",sx-4,sx,curY,curY,colors.white,colors.gray,"Back")
	end
	lg.drawText(sx-2,sy,colors.lightGray,colors.white,scroll.."/"..#options)
	curY = curY+1
	for i=1,#options do
		if i >= scroll and i <= scroll+4 then
			local option = options[i]
			if option.type == "switch" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
				lg.drawText(2,curY,colors.black,colors.white,option.toggletext)
				lg.drawBT("t:"..option.target,sx-3,sx-1,curY,curY,colors.lightGray,colors.white,"  ")
				lg.fill(sx-3,sx-1,curY,curY,colors.lightGray)
				if config.readFromConfig(option.target) == "yes" then
					lg.fill(sx-1,sx-1,curY,curY,colors.lime)
				elseif config.readFromConfig(option.target) == "no" or config.readFromConfig(option.target) == nil then
					lg.fill(sx-3,sx-3,curY,curY,colors.gray)
				end
				switchCords[option.target] = curY
				curY = curY+1
			elseif option.type == "button" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
				if option.confirmbutton then
					lg.drawBT("confirm",3,3+string.len(option.buttontext),curY,curY,colors.white,option.buttoncolor,option.buttontext)
					option["target"] = "confirm"
				else
					lg.drawBT("b:"..option.target,3,3+string.len(option.buttontext),curY,curY,colors.white,option.buttoncolor,option.buttontext)
				end
				switchCords[option.target] = curY
				curY = curY+1
			elseif option.type == "input" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
				lg.drawInput("i:"..option.target,3,3+option.inputlimit,curY,curY,option.inputlimit)
				switchCords[option.target] = curY
				curY = curY+1
			elseif option.type == "text" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
				if option.textline_s ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline_s)
					curY = curY+1
				end
			end
			drawCharsLine(1,curY,sx,curY,"\x8c",colors.gray,colors.white)
			curY = curY+1
		end
	end
end


local function drawMenu(title,options,back)
	lg.clearBTNS()
	lg.fillScreen(colors.white)
	local scroll = 1
	drawList(title,options,back,scroll)
	local composedOutput = {}
	while true do
		local event, direction, x, y = os.pullEvent()
		if event == "mouse_click" then
			local bt  = lg.isButton(x,y)
			if bt ~= nil and bt ~= false then
				if bt == "close_back_bt" then
				  return false
				elseif string.find(bt,"t:") then
					local target = string.sub(bt, 3)
					local value = config.readFromConfig(target)
					lg.fill(sx-3,sx-1,switchCords[target],switchCords[target],colors.lightGray)
					--lg.drawText(1,1,colors.white,colors.black,value)
					if value == "yes" then
					  config.setToConfig(target,"no")
					  lg.fill(sx-3,sx-3,switchCords[target],switchCords[target],colors.gray)
					elseif value == "no" then
					  config.setToConfig(target,"yes")
					  lg.fill(sx-1,sx-1,switchCords[target],switchCords[target],colors.lime)
					elseif value == nil then
					  config.setToConfig(target,"no")
					  lg.fill(sx-3,sx-3,switchCords[target],switchCords[target],colors.gray)
					end
				elseif string.find(bt,"b:") then
					local target = string.sub(bt, 3)
					return target
				elseif bt == "confirm" then
				composedOutput["isComposed"] = true
				  return composedOutput
				end
			end
			local bt = lg.isInput(x,y)
			if bt ~= nil and bt ~= false then
				if string.find(bt,"i:") then
					local target = string.sub(bt, 3)	
					local receivedOutput = lg.getInput(x,y)
					composedOutput[target] = receivedOutput
				end
			end
		elseif event == "mouse_scroll" then
			if direction > 0 and scroll < #options then scroll = scroll + 1 elseif direction < 0 and scroll > 1 then scroll = scroll - 1 end
			drawList(title,options,back,scroll)
		end
	end
end

-- {["type"] = "switch",["text"] = ">	Login with pin",["toggletext"] = "Toggle: ",["target"] = "pin_toggle"},
		-- {["type"] = "input",["text"] = ">	Test input:",["inputlimit"] = 10, ["target"] = "test_input"},
		-- {["type"] = "button",["text"] = ">	Confirm",["buttontext"] = "Confirm",["buttoncolor"] = colors.green,["confirmbutton"] = true}},
local function setup()
	lg.setup("term")
	lg.fillScreen(colors.white)
	local sx,sy = term.getSize()
	while true do
		local result = drawMenu(
			{{["color"] = colors.green, ["text"] = "    CreatOS | Installer"},{["color"] = colors.black, ["text"] = " "},{["color"] = colors.black, ["text"] = "> Enter CREDS"},{["color"] = colors.black, ["text"] = " "}},
			{{["type"] = "input",["text"] = ">	Card ID:",["inputlimit"] = 5, ["target"] = "card_id"},
			{["type"] = "input",["text"] = ">	Card PIN:",["inputlimit"] = 4, ["target"] = "card_pin"},
			{["type"] = "button",["text"] = ">	Confirm",["buttontext"] = "Confirm",["buttoncolor"] = colors.green,["confirmbutton"] = true}},
		false)
		if result.isComposed then
			local id = result["card_id"]
			local psw = result["card_pin"]
			config.setToConfig("bank_card_id",id)
			config.setToConfig("bank_card_pin",psw)
		end
		result = drawMenu(
			{{["color"] = colors.green, ["text"] = "    CreatOS | Installer"},{["color"] = colors.black, ["text"] = " "},{["color"] = colors.black, ["text"] = "> Enter PIN"},{["color"] = colors.black, ["text"] = " "}},
			{{["type"] = "text",["text"] = "REMEMBER YOU PIN!  ",["textline"] = " You can disable it ...",["textline_s"] = "in setting."},
			{["type"] = "input",["text"] = ">	Device PIN:",["inputlimit"] = 4, ["target"] = "pin"},
			{["type"] = "button",["text"] = ">	Confirm",["buttontext"] = "Confirm",["buttoncolor"] = colors.green,["confirmbutton"] = true}},
		false)
		if result.isComposed then
			local pin = result["pin"]
			config.setToConfig("pin",pin)
		end
		result = drawMenu(
			{{["color"] = colors.green, ["text"] = "    CreatOS | Installer"},{["color"] = colors.black, ["text"] = " "},{["color"] = colors.black, ["text"] = "> EULA | TOS"},{["color"] = colors.black, ["text"] = " "}},
			{{["type"] = "text",["text"] = "By click this button,  ",["textline"] = " you confirm that you ...",["textline_s"] = " accept the TOS."},
			{["type"] = "button",["text"] = ">	Confirm",["buttontext"] = "Confirm",["buttoncolor"] = colors.green,["confirmbutton"] = true}},
		false)
		return true
	end
end
return { setup = setup }
-- End of File: system/installer

-- File: system/launcher
local lg = require(".lg")
os.loadAPI("bigfont")

local ok, utils = pcall(require, ".system.utils")
--local api = require("api")
local ok, config = pcall(require, ".config.configManager")
local ok, nfc = pcall(require, ".system.nfc")
lg.setup("term")
local sx = lg.getSize().x
local sy = lg.getSize().y
local iconColors = {colors.lime,colors.pink,colors.lightBlue,colors.yellow}
local darkerIconColors = {colors.green,colors.red,colors.blue,colors.orange}
local openedApp = false
local drawClock = true
local nick = "timuzkas"
local nfcEnabled = true
local processes = 0

local installPrompt  = false


local function nfcM()
	if config.readFromConfig("nfc_menu_opened") == "yes" then return true else return false end
end

local function drawLoading(x,y,c,cbg)
  local sym_table = {{c,cbg,"\x81"},{c,cbg,"\x82"},{c,cbg,"\x88"},{cbg,c,"\x9f"},{c,cbg,"\x90"},{c,cbg,"\x84"}}
  while true do
    for _,sym in pairs(sym_table) do
      local symbolColor = sym[1]
      local symbolBackgroundColor = sym[2]
      local symbolChar = sym[3]
      lg.drawText(x,y,symbolColor,symbolBackgroundColor,symbolChar)
      sleep(0.1)
    end
  end
end

function fileContainsString(filePath, targetString)
    local file = fs.open(filePath, "r")
    
    if not file then
        return false
    end
    local content = file.readAll()	
    file.close()
    
    if string.find(content, targetString) then
        return true
    else
        return false
    end
end

local function removeEntriesWithValue(myTable, valueToRemove)
    local i = 1
	local tTable = myTable
    while i <= #tTable do
        if tTable[i] == valueToRemove then
            table.remove(tTable, i)
        else
            i = i + 1
        end
    end
	return tTable
end

function drawCenteredText(meta, y, bgcolor)
    local width, height = term.getSize()
    local x = math.floor((width - #meta[1].text) / 2) + 1	

    for _, line in pairs(meta) do
	  lg.drawText(x,y,line.color, bgcolor,line.text)
	  x = x + #line.text
	end
end

function drawHomePage(page)
  lg.fillScreen(colors.white)
  local page = config.readFromConfig("page"..page) if page ~= nil then page = textutils.unserialize(page) end
  local fav = config.readFromConfig("fav") if fav ~= nil then fav = textutils.unserialize(fav) end
  utils.drawCharsLine(3,7,sx-2,7,"\x8c",colors.blue,colors.white)	
  --local answer, errorMSG = api.getHistory(tonumber(card),tonumber(psw))
  --lg.drawText(6,8,colors.lightBlue,colors.	while true do
  parallel.waitForAll(function()
	  for i=1,4 do
		lg.fill(1,sx,sy+1-i,sy,colors.lightGray)
		--utils.drawCharsLine(1,sy+1-i,sx,sy+1-i,"\x83",colors.lightGray,colors.white)
		sleep(0.01)
	  end
	  utils.drawCharsLine(1,sy-3,sx,sy-3,"\x83",colors.gray,colors.lightGray)
  end, function()
	for i=1,1 do
	  lg.fill(1,sx,1,i,colors.gray)
	  sleep(0.03)
	end
	utils.drawCharsLine(1,2,sx,2,"\x83",colors.lightGray,colors.white)
  end)
  if fav == nil or #fav == 0 or #fav < 1 or fav == {} then
    lg.drawBT("add_fav",2,6,sy-2,sy,colors.white,colors.white,"+")
	lg.drawText(4,sy-1,colors.black,colors.white,"+")
	utils.drawCharsLine(2,sy,6,sy,"\x8f",colors.white,colors.lightGray)
  else
    local x = 2
	local i = 1
	lg.drawBT("add_fav",1,4,sy-4,sy-4,colors.white,colors.blue,"EDIT")
	while true do
		local appName = fav[i]
		local f = fs.open("/appData/"..appName.."/data","r")
	    local data = textutils.unserialize(f.readAll())
	    f.close()
		local dColor = math.random( #iconColors )
		lg.drawBT(appName,x,x+4,sy-2,sy-1,iconColors[dColor],iconColors[dColor],"app")
		utils.drawCharsLine(x,sy,x+4,sy,"\x8f",darkerIconColors[dColor],colors.lightGray)
		local fName = utils.getFormatedName(data[1])
		lg.drawText(x,sy-2,colors.white,iconColors[dColor],string.sub(fName[1], 1, 4))
		if fName[2]  ~= nil then
			lg.drawText(x,sy-1,colors.white,iconColors[dColor],string.sub(fName[2], 1, 4))
		end
		x = x + 6
		i = i + 1
		if x >= sx or i > #fav then break end
	end
  end
  lg.drawBT("add_widget",2,sx-9,sy-9,sy-6,colors.lightGray, colors.lightGray," ")
  lg.drawBT("all_apps",sx-7,sx-1,sy-9,sy-6,colors.lightGray, colors.lightGray," ")
  lg.drawText(3,sy-8,colors.white,colors.lightGray,"Add widget...")
  lg.drawText(sx-6,sy-8,colors.white,colors.lightGray,"All")
  lg.drawText(sx-6,sy-7,colors.white,colors.lightGray,"Apps")
end


lg.fillScreen(colors.white)
drawCenteredText({{text = "Creat",color = colors.green},{text = "OS",color = colors.gray}},6,colors.white)                                      
parallel.waitForAny(function() drawLoading(sx/2,8,colors.lime,colors.white) end, function() sleep(1) end)
if config.readFromConfig("pin_toggle") ~= "yes" then
	local pin = config.readFromConfig("pin")
	local result = utils.login(true)
	while true do
		if result == pin then
		  utils.drawHint("Welcome!",colors.green)
		  break
		else
		  utils.drawHint("Wrong PIN!",colors.red)
		end
		local result = utils.login(false)
	end
end
config.setToConfig("logined","yes")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           if utils.ver() == false then os.reboot() end
lg.clearBTNS()
drawHomePage(1)
parallel.waitForAll(function()
	while true do
	  local _, bt, x, y = os.pullEvent("mouse_click")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if utils.ver() == false then os.reboot() end
	  local bt = lg.isButton(x,y)
	  if nfcM() == false and installPrompt == false then
		  if bt ~= nil and bt ~= false then
				if bt == "add_fav" then
					lg.clearBTNS()
					drawClock = false
					local app = utils.selectApp(true)
					if app ~= false then
						if string.sub(app, 1, 2) == "d:" then
						  appName = string.sub(app, 3)
						  local fav = config.readFromConfig("fav") if fav ~= nil then fav = textutils.unserialize(fav) else fav = {} end
						  fav = removeEntriesWithValue(fav,appName)
						  config.setToConfig("fav",textutils.serialize(fav))
						else
							local fav = config.readFromConfig("fav") if fav ~= nil then fav = textutils.unserialize(fav) else fav = {} end
							table.insert(fav,app)
							-- for _, app in pairs(fav) do print(app.." | ") end sleep(2)
							config.setToConfig("fav",textutils.serialize(fav))
						end
					end
					openedApp = false
				elseif bt == "all_apps" then
					drawClock = false
					local app = utils.selectApp(false)
					if app ~= false then
						if string.sub(app, 1, 2) == "d:" then
							installPrompt = true
							openedApp = true
							local answer = utils.userPrompt("Delete app","Do you want to delete: ",app,"Yes","No")
							if answer == "1" then
								  appName = string.sub(app, 3)
								  local fav = config.readFromConfig("fav") if fav ~= nil then fav = textutils.unserialize(fav) else fav = {} end
								  fav = removeEntriesWithValue(fav,appName)
								  config.setToConfig("fav",textutils.serialize(fav))
								  fs.delete("appData/"..appName)
							end
						else
							openedApp = true
							utils.launchThreadFromFile("appData/"..app.."/app", true)	
						end
					end
				else
				  openedApp = true
				  drawClock = false
				  print("appData/"..bt.."/app")
				  utils.launchThreadFromFile("appData/"..bt.."/app", true)	
				end
				lg.clearBTNS()
				drawHomePage(1)
				if installPrompt == true then
					utils.drawHint("Uninstalled!",colors.red)
					installPrompt = false
				end
				if nfcM() == false then
					openedApp = false
					drawClock = true
				end
		  end
		end
	end
end, function()
	if not openedApp then
	    while true do
			sleep(3)
			local screenWidth, screenHeight = term.getSize()
			local scrollSpeed = 0.1 -- Adjust the scroll speed as needed
			local pauseTime = 2	 -- Pause time at the end of each line
			local textLines = {
				"Welcome, "..nick,
				"BG Processes: "..tostring(processes),
				"ID: "..os.getComputerID().." | NFC: "..tostring(nfcEnabled),
			}
			
			
			for _, line in ipairs(textLines) do
				if not openedApp then
					sleep(1)
					local posX = screenWidth

					for i = screenWidth, -#line, -1 do
						if openedApp then break end
						lg.fill(1,sx,1,1,colors.gray)
						lg.drawText(posX,1,colors.white,colors.gray,line)
						os.sleep(scrollSpeed)
						posX = posX - 1
					end
				else
				end
				os.sleep(pauseTime)
			end
			
		end
	end
end,function()
  while true do
	  if drawClock then
		  local time = os.time()
		  local fTime = textutils.formatTime(time, false)
		  term.setTextColor(colors.lightBlue)
		  term.setBackgroundColor(colors.white)
		  bigfont.writeOn(term,1,fTime,4,4)
		  sleep(0.95)
	  else
		sleep(1)
	  end
  end
end, function()
	while true do
		if nfcM() == true then
			openedApp =  true
			drawClock = false
			config.setToConfig("nfc_menu_opened_now","yes")
			repeat 
			  sleep(0.5)
			until nfcM() == false
			openedApp =  false
			drawClock = true
			drawHomePage(1)
		elseif nfcM() == false then
		  config.setToConfig("nfc_menu_opened_now","no")
		end
		sleep(0.5)
	end
end,function()
	while true do
		local _, files = os.pullEvent("file_transfer")
		openedApp = true
		for _, file in ipairs(files.getFiles()) do
		  local handle = fs.open("/userData/"..file.getName(), "wb")
		  handle.write(file.readAll())

		  handle.close()
		  file.close()
		  if string.find(file.getName(),".app") then
		    installPrompt  = true
			lg.clearBTNS()
			local answer = utils.userPrompt("Install an app","Install: ",file.getName(),"Yes","No")
			if answer == "1" then
				drawClock = false
				openedApp = true
				if fileContainsString("/userData/"..file.getName(),"local desc = '") and config.readFromConfig("sideloading_blocked") ~= "yes" then
					shell.run("/userData/"..file.getName()) 
				else
					lg.fillScreen(colors.black)
					config.setToConfig("sideloading_blocked","yes")
					print("")
					print("You tried to fake .app ??")
					print("--")
					print("Now you can't use any .app files on your device!")
					print(" ")
					print(" ")
					print("Contact bank support for unblocking ")
					print("Press any key...")
					os.pullEvent("key")
				 end
			end
			installPrompt  = false
		  end
		end
		utils.drawHint("Transfered files!",colors.green)
		drawHomePage(1)	
		openedApp = false
		drawClock = true
	end
end, function ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if utils.ver() == false then os.reboot() end end)

lg.exit()
-- End of File: system/launcher

-- File: system/nfc
local rsa = require(".libraries/rsa")
local api = require("/system/api")
local lg = require(".lg")
lg.setup("term")
local config = require("/config.configManager")
local function ddrawCenteredText(text, meta, y, bgcolor)
    local width, height = term.getSize()
    local x = math.floor((width - #text) / 2) + 1	

    for _, line in pairs(meta) do
	  lg.drawText(x,y,line.color, bgcolor,line.text)
	  x = x + #line.text
	end
end

-- Base64

-- Characters
local b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

-- Encoding
function encode(data)
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return b:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end

-- Decoding
function decode(data)
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end


local function startNFC()
	local modem = peripheral.wrap("back")
	modem.closeAll()
	sleep(0.5)
	if modem then
		modem.open(8574)
		return true
	else
		return false
	end
end

local function get(sC,rC,rmsg,sD)
	local event, modemSide, senderChannel, replyChannel, msg, senderDistance = nil, nil, nil, nil, nil, nil
	repeat 
		event, modemSide, senderChannel, replyChannel, msg, senderDistance = os.pullEvent("modem_message")
	until senderChannel == sC and replyChannel == rC and msg == rmsg and senderDistance <= sD
	return msg
end

local function getn(sC,rC,sD)
	local event, modemSide, senderChannel, replyChannel, msg, senderDistance = nil, nil, nil, nil, nil, nil
	repeat 
		event, modemSide, senderChannel, replyChannel, msg, senderDistance = os.pullEvent("modem_message")
		-- print(sC.." | "..senderChannel)
		-- print(rC.." | "..replyChannel)
		-- print(msg)
		-- print(sD.." | "..senderDistance)
	until senderChannel == sC and replyChannel == rC and senderDistance <= sD
	return msg
end

local gotAnswer = false
local message = ""

local function waitNFC()
	local modem = peripheral.wrap("back")
	repeat
		sleep(1)
	until config.readFromConfig("logined") == "yes"
	while true do
		startNFC()
		gotAnswer = false
		balance  = 0
		config.setToConfig("nfc_menu_opened","no")
		while true do
			if config.readFromConfig("nfc_toggle") == "yes" then
				modem.transmit(8547, 8574, encode("nfc_search"))
				parallel.waitForAny(function() 
					modem.open(8574)
					local event, modemSide, senderChannel, replyChannel, msg, senderDistance = os.pullEvent("modem_message")
					if senderChannel == 8574 and replyChannel == 8547 and senderDistance < 3 then
						balance = tonumber(decode(msg))
						gotAnswer = true
					end 
				end, function() sleep(2) end)
				if gotAnswer then break end
			end
			sleep(0.5)
		end
		config.setToConfig("nfc_menu_opened","yes")
		repeat
			sleep(0.2)
		until config.readFromConfig("nfc_menu_opened_now") == "yes"
		sleep(0.2)
		config.setToConfig("nfc_menu_opened","yes")
		lg.fillScreen(colors.white)
		ddrawCenteredText("NFC PAYMENT",{{text = "NFC ",color = colors.green},{text = "PAYMENT",color = colors.gray}},6,colors.white)
		lg.drawText(2,9,colors.green,colors.white,"Do you want to pay: ")
		lg.drawText(3,10,colors.gray,colors.white,balance.." $ to NFC terminal?")
		lg.clearBTNS()
		lg.drawBT("confirm", 3, 2+string.len("Confirm"),12,12,colors.white,colors.green,"Confirm")
		lg.drawBT("cancel", 3+string.len("Confirm")+2, 2+3+string.len("Confirm")+string.len("Cancel"),12,12,colors.white,colors.red,"Cancel")
		local rChannel = math.random(1,1500)
		local sChannel = math.random(1501,2000)
		local publicKey = nil
		modem.open(rChannel)
		modem.open(sChannel)
		while true do
			local _, bt, x, y = os.pullEvent("mouse_click")
			local bt = lg.isButton(x,y)
			if bt ~= nil and bt ~= false then 
				if bt == "confirm" then
					lg.clearBTNS()
					lg.fill(1,sx,12,12,colors.white)

					modem.transmit(8547, rChannel, textutils.serialize({"pkey",sChannel}))
					lg.fill(1,sx,12,12,colors.white)
					lg.drawText(2,12,colors.gray,colors.white,"Openning session...")
					local msg = decode(getn(rChannel,sChannel,3))
					publicKey = textutils.unserialize(msg)
					lg.fill(1,sx,12,12,colors.white)
					lg.drawText(2,12,colors.gray,colors.white,"Sending your credentials...")
					local card_id = tonumber(config.readFromConfig("bank_card_id"))
					local pin = tonumber(config.readFromConfig("bank_card_pin"))
					local token = api.getToken(card_id, pin)
					for i = 1, #token, 32 do
						local chunk = string.sub(token, i, i + 32 - 1)
						local encoded_chunk = rsa.encode(publicKey, chunk)
						modem.transmit(sChannel, rChannel, encoded_chunk)
						local msg = decode(get(rChannel,sChannel,encode("next"),3))
						lg.fill(1,sx,12,12,colors.white)
						lg.drawText(2,12,colors.gray,colors.white,"Sending fragment: "..i)
					end
					modem.transmit(sChannel, rChannel, encode("end"))
					lg.fill(1,sx,12,12,colors.white)
					lg.drawText(2,12,colors.green,colors.white,"Continue on a terminal!")
					sleep(5)
				else
					config.setToConfig("nfc_menu_opened","no")
					gotAnswer = false
				end
				config.setToConfig("nfc_menu_opened","no")
				sleep(0.2)
				config.setToConfig("nfc_menu_opened_now","no")
				break
			end
		end
	end
end


return { waitNFC = waitNFC, startNFC = startNFC }
-- End of File: system/nfc

-- File: system/updater
local lg = require(".lg")
local config = require(".config.configManager")
local info = require(".system.info")
local unpacker = require(".libraries.unpacker")
lg.setup("term")
lg.fillScreen(colors.white)
local sx,sy = term.getSize()

local function drawCharsLine(x, y, x2, y2, charR, color, bgcolor)
    for i = x, x2 do
        for k = y, y2 do
            lg.drawText(i, k, color, bgcolor, charR)
        end
    end
end

local function drawHint(text,bg)
    local chars = {"\x83", "\x8f", " "}
	local bgColor = {colors.white,colors.white,bg}
    for charN = 1, #chars do
        for i = 1, sx do
            lg.drawText(i, 1, bg, bgColor[charN], chars[charN])
        end
        sleep(0.05)
    end
    drawCharsLine(1, 1, sx, 1, " ", bg, bg)
    lg.drawText(2, 1, colors.white, bg, " > " .. text)
    sleep(0.2)
    drawCharsLine(1, 2, sx, 2, "\x83", bg, colors.white)
    sleep(1)
    drawCharsLine(1, 2, sx, 2, " ", colors.white, colors.white)
    sleep(0.05)
    drawCharsLine(1, 1, sx, 1, " ", colors.white, colors.white)
end

function fileContainsString(filePath, targetString)
    local file = fs.open(filePath, "r")
    
    if not file then
        return false
    end
    local content = file.readAll()	
    file.close()
    
    if string.find(content, targetString) then
        return true
    else
        return false
    end
end

local function rremoveEntriesWithValue(myTable, valueToRemove)
    local i = 1
	local tTable = myTable
    while i <= #tTable do
        if tTable[i] == valueToRemove then
            table.remove(tTable, i)
        else
            i = i + 1
        end
    end
	return tTable
end


local function listFilesInDirectory(directory)
    local files = {}

    local items = fs.list("appData/")
    for _, item in ipairs(items) do
        local fullPath = fs.combine(directory, item)
        if fs.isDir(fullPath) then
            local subFiles = listFilesInDirectory(fullPath)
            for _, subFile in ipairs(subFiles) do
                table.insert(files, fs.combine(item, subFile))
            end
        else
            table.insert(files, item)
        end
    end

    return files
end



local function isInTable(value, myTable)
    for _, v in ipairs(myTable) do
        if v == value then
            return true
        end
    end
    return false
end

local function getApps()
	local appCount = 0
    local allFiles = listFilesInDirectory("addData/")
	local apps = {}
	for _i, file in pairs(allFiles) do
	  local f = fs.open("/appData/"..file.."/data","r")
	  local data = textutils.unserialize(f.readAll())
	  f.close()
	  apps[data[1]] = data
	  appCount = appCount + 1
	end
	return appCount, apps	
end

local function drawCenteredText(text, meta, y, bgcolor)
    local width, height = term.getSize()
    local x = math.floor((width - #text) / 2) + 1

    for _, line in pairs(meta) do
	  lg.drawText(x,y,line.color, bgcolor,line.text)
	  x = x + #line.text
	end
end

local switchCords = {}

local function drawList(title, options, back, scroll)
	lg.clearBTNS()
	lg.fillScreen(colors.white)
	local curY = 1
	for i=1,#title do
		lg.drawText(1,i,title[i].color,colors.white,title[i].text)
		curY = curY+1
	end
	drawCharsLine(1,curY,sx,curY,"\x8c",colors.gray,colors.white)
	if back then
		lg.drawBT("close_back_bt",sx-4,sx,curY,curY,colors.white,colors.gray,"Back")
	end
	curY = curY+1
	for i=1,#options do
		if i >= scroll and i <= scroll+4 then
			local option = options[i]
			if option.type == "switch" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
				lg.drawText(2,curY,colors.black,colors.white,option.toggletext)
				lg.drawBT("t:"..option.target,sx-3,sx-1,curY,curY,colors.lightGray,colors.white,"  ")
				lg.fill(sx-3,sx-1,curY,curY,colors.lightGray)
				if config.readFromConfig(option.target) == "yes" then
					lg.fill(sx-1,sx-1,curY,curY,colors.lime)
				elseif config.readFromConfig(option.target) == "no" or config.readFromConfig(option.target) == nil then
					lg.fill(sx-3,sx-3,curY,curY,colors.gray)
				end
				switchCords[option.target] = curY
				curY = curY+1
			elseif option.type == "button" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
				if option.confirmbutton then
					lg.drawBT("confirm",3,3+string.len(option.buttontext),curY,curY,colors.white,option.buttoncolor,option.buttontext)
					option["target"] = "confirm"
				else
					lg.drawBT("b:"..option.target,3,3+string.len(option.buttontext),curY,curY,colors.white,option.buttoncolor,option.buttontext)
				end
				switchCords[option.target] = curY
				curY = curY+1
			elseif option.type == "input" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
				lg.drawInput("i:"..option.target,3,3+option.inputlimit,curY,curY,option.inputlimit)
				switchCords[option.target] = curY
				curY = curY+1
			elseif option.type == "text" then
				lg.drawText(1,curY,colors.black,colors.white,option.text)
				curY = curY+1
				if option.textline ~= nil then
					lg.drawText(1,curY,colors.black,colors.white,option.textline)
					curY = curY+1
				end
			end
			drawCharsLine(1,curY,sx,curY,"\x8c",colors.gray,colors.white)
			curY = curY+1
		end
	end
	lg.drawText(sx-2,sy,colors.lightGray,colors.white,scroll.."/"..#options)
end


local function drawMenu(title,options,back)
	lg.clearBTNS()
	lg.fillScreen(colors.white)
	local scroll = 1
	drawList(title,options,back,scroll)
	local composedOutput = {}
	while true do
		local event, direction, x, y = os.pullEvent()
		if event == "mouse_click" then
			local bt  = lg.isButton(x,y)
			if bt ~= nil and bt ~= false then
				if bt == "close_back_bt" then
				  return false
				elseif string.find(bt,"t:") then
					local target = string.sub(bt, 3)
					local value = config.readFromConfig(target)
					lg.fill(sx-3,sx-1,switchCords[target],switchCords[target],colors.lightGray)
					--lg.drawText(1,1,colors.white,colors.black,value)
					if value == "yes" then
					  config.setToConfig(target,"no")
					  lg.fill(sx-3,sx-3,switchCords[target],switchCords[target],colors.gray)
					elseif value == "no" then
					  config.setToConfig(target,"yes")
					  lg.fill(sx-1,sx-1,switchCords[target],switchCords[target],colors.lime)
					elseif value == nil then
					  config.setToConfig(target,"no")
					  lg.fill(sx-3,sx-3,switchCords[target],switchCords[target],colors.gray)
					end
				elseif string.find(bt,"b:") then
					local target = string.sub(bt, 3)
					return target
				elseif bt == "confirm" then
				composedOutput["isComposed"] = true
				  return composedOutput
				end
			end
			local bt = lg.isInput(x,y)
			if bt ~= nil and bt ~= false then
				if string.find(bt,"i:") then
					local target = string.sub(bt, 3)	
					local receivedOutput = lg.getInput(x,y)
					composedOutput[target] = receivedOutput
				end
			end
		elseif event == "mouse_scroll" then
			if direction > 0 and scroll < #options then scroll = scroll + 1 elseif direction < 0 and scroll > 1 then scroll = scroll - 1 end
			drawList(title,options,back,scroll)
		end
	end
end

-- {["type"] = "switch",["text"] = ">	Login with pin",["toggletext"] = "Toggle: ",["target"] = "pin_toggle"},
		-- {["type"] = "input",["text"] = ">	Test input:",["inputlimit"] = 10, ["target"] = "test_input"},
		-- {["type"] = "button",["text"] = ">	Confirm",["buttontext"] = "Confirm",["buttoncolor"] = colors.green,["confirmbutton"] = true}},

local response, err = http.get { url = "https://gist.githubusercontent.com/Timasbro/9dfd7bd19bb69dc5752af938058e5239/raw/fed484392be189246a35ecb5020b43fb907c3be0/version"}
if not response then error(err, 0) end

local currentVersion = response.readAll()

while true do
	local result = ""
	if info.version ~= currentVersion then
		result = drawMenu(
			{{["color"] = colors.green, ["text"] = "    CreatOS | Updater"},{["color"] = colors.black, ["text"] = " "},{["color"] = colors.black, ["text"] = "> Main page"},{["color"] = colors.black, ["text"] = " "}},
			{{["type"] = "text",["text"] = "> Current version: ",["textline"] = info.version},
			{["type"] = "text",["text"] = "> Latest version: ",["textline"] = currentVersion},
			{["type"] = "button",["text"] = "> Update: ",["buttontext"] = "Update",["buttoncolor"] = colors.green,["target"] = "upd"}},
		false)
		if result == "upd" then
			lg.fillScreen(colors.white)
			drawCharsLine(1,sx,3,3,"\x8c",colors.gray,colors.white)
			lg.drawText(2,2,colors.black,colors.white,"Updater")
			term.setCursorPos(2,5)
			print("downloadinf update...")
			local response, err = http.get { url = ""}
			if not response then error(err, 0) end
			local f = fs.open("/upd/upd","w")
			f.write(response.readAll())
			f.close()
			print("installing...")
			unpacker.unpacker("upd/upd","/")
			print("done!")
			sleep(1)
			os.reboot()
		end
	else
		result = drawMenu(
			{{["color"] = colors.green, ["text"] = "    CreatOS | Updater"},{["color"] = colors.black, ["text"] = " "},{["color"] = colors.black, ["text"] = "> Main page"},{["color"] = colors.black, ["text"] = " "}},
			{{["type"] = "text",["text"] = "> Current version: ",["textline"] = info.version},
			{["type"] = "text",["text"] = "> Latest version: ",["textline"] = currentVersion},
			{["type"] = "text",["text"] = "> All up to date! ",["textline"] = "No need to update."}},
		false)
	end
end
-- End of File: system/updater

-- File: system/utils
local lg = require(".lg")
local config = require(".config.configManager")
lg.setup("term")

local sx = lg.getSize().x
local sy = lg.getSize().y

function checkIfError(myString, pathVariable)
    if type(myString) == "function" then return false end
    local prefix = pathVariable .. ":"
    return string.sub(myString, 1, #prefix) == prefix
end

local function nfcM()
	if config.readFromConfig("nfc_menu_opened") == "yes" then return true else return false end
end

local function ver()
	if tonumber(config.readFromConfig("asd")) == os.getComputerID() then
		return true
	end
	return false
end

function detectSwipeUp()
    local startX, startY = term.getSize() -- Bottom of the screen
    local sizeX, sizeY = term.getSize()
	local endY = 1  -- Top of the screen
    local isMouseDown = false

    while true do
        local event, button, x, y = os.pullEvent()

        if event == "mouse_click" and button == 1 then
            isMouseDown = true
			if y > sizeY-2 then
				startY = y
			end
        elseif event == "mouse_up" and button == 1 then
			isMouseDown = false
        elseif event == "mouse_drag" and button == 1 and isMouseDown then
            -- Check if the drag is from bottom to top
            if (startY-y) > (startY/3) then
			  break
			end
        end
    end
end

local function launchThreadFromFile(path, canBeClosed)
  if ver() == false then return {false,"not verified"} end
  if canBeClosed then 
    parallel.waitForAny(function()
		local ok, errMSG = pcall(loadfile(path, nil, _ENV))
		if ok ~= true then return {false, errMSG} else return {true} end
	end,function()
	  detectSwipeUp()
	  return { true }
	end, function()
		while true do
			if nfcM() == true then return {true} else
			sleep(0.5) end
		end
	end)
  else
	local ok, errMSG = pcall(loadfile(path, nil, _ENV))
	if ok ~= true then return {false, errMSG} else return {true} end    
  end
end	

local function drawCenteredText(text, meta, y, bgcolor)
    local width, height = term.getSize()
    local x = math.floor((width - #text) / 2) + 1

    for _, line in pairs(meta) do
	  lg.drawText(x,y,line.color, bgcolor,line.text)
	  x = x + #line.text
	end
end

local function drawButton(x,y,txt,c) 
  lg.drawBT(txt,x,x+2,y,y,colors.white,c," "..txt)
  
end

local function fillSpace(text)
    if #text < 10 then
        local spacesToAdd = 10 - #text
        return text .. string.rep(" ", spacesToAdd)
    else
        return text
    end
end

local function login(redraw)
  if redraw then
	  for i=1,sy-5 do
		lg.fill(1,sx,sy-1-i,sy-1,colors.white)
		for x=1,sx do lg.drawText(x,(sy-1)-i,colors.lime,colors.white,"-") end
		sleep(0.01)
	  end
  end
  lg.fill(4,sx-3,9,9,colors.white)
  drawCenteredText("Login with PIN",{{text = "Login with",color = colors.gray},{text = " PIN",color = colors.green}},7,colors.white)
  local offset = 0
  local bts = {8+offset,12+offset,16+offset}
  local y = 10
  local sender = ""
  local btName = 1
  while true do
    for i=1,#bts do
	  drawButton(bts[i],y,tostring(btName),colors.lightGray)
	  btName = btName + 1
	end
	if y >= 10+4 then break end
	y = y + 2
  end
  drawButton(12+offset,16,"0",colors.lightGray)
  drawButton(8+offset,16,"<",colors.red)
  drawButton(16+offset,16,"OK",colors.green)
  while true do
    local _, bt, x, y = os.pullEvent("mouse_click")
	local bt = lg.isButton(x,y)
	if bt ~= nil and bt ~= false then
	  if bt == "cancel" then
	    return false
	  elseif bt == "<" then
	    if string.len(sender) > 0 then
			sender = string.sub(sender, 1, -2)
		end
		lg.fill(4,sx-3,9,9,colors.white)
		lg.drawText(4,9,colors.black,colors.white,fillSpace(sender))
		drawCenteredText(sender,{{text = sender,color = colors.gray}},9,colors.white)
	  elseif bt == "OK" then
	    return sender
	  else
	    if string.len(sender) < 10 then
			sender = sender..bt
			lg.fill(4,sx-3,9,9,colors.white)
			drawCenteredText(sender,{{text = sender,color = colors.gray}},9,colors.white)
		end
	  end
	end
  end
end

local function drawCharsLine(x, y, x2, y2, charR, color, bgcolor)
    for i = x, x2 do
        for k = y, y2 do
            lg.drawText(i, k, color, bgcolor, charR)
        end
    end
end

local function listFilesInDirectory(directory)
    local files = {}

    local items = fs.list("appData/")
    for _, item in ipairs(items) do
        local fullPath = fs.combine(directory, item)
        if fs.isDir(fullPath) then
            local subFiles = listFilesInDirectory(fullPath)
            for _, subFile in ipairs(subFiles) do
                table.insert(files, fs.combine(item, subFile))
            end
        else
            table.insert(files, item)
        end
    end

    return files
end

local function isInTable(value, myTable)
    for _, v in ipairs(myTable) do
        if v == value then
            return true
        end
    end
    return false
end

local function getAllApps()
    local allFiles = listFilesInDirectory("addData/")
	local apps = {}
	for _i, file in pairs(allFiles) do
	  local f = fs.open("/appData/"..file.."/data","r")
	  local data = textutils.unserialize(f.readAll())
	  f.close()
	  apps[data[1]] = data
	end
	return apps
end

local function getFormatedName(inputString)
    inputString = inputString:gsub("[AEIOUaeiou]", "")
    local fragments = {}
    
    -- Split the string into 4-character fragments
    for i = 1, #inputString, 4 do
        local fragment = string.sub(inputString, i, i + 3)
        
        -- Remove vowels from the fragment
        
        table.insert(fragments, fragment)
    end
    
    return fragments
end


local function drawAppsList(apps, scroll, selector)
	lg.clearBTNS()
	lg.fill(1,sx,6,sy-1,colors.white)
	local i = 1
	local fav = config.readFromConfig("fav") if fav ~= nil then fav = textutils.unserialize(fav) end
	local y = 6
	for name, app in pairs(apps) do
	  if i >= scroll and i <= scroll+2 then
		  lg.drawText(2,y,colors.black,colors.white,"> "..name)
		  lg.drawText(3,y+1,colors.gray,colors.white,"\xb7"..app[2])
		  if selector == true then
			  if fav ~= nil and fav~= {} and isInTable(name,fav) then
				lg.drawBT("d:"..name,2,string.len("Delete")+1,y+2,y+2,colors.white,colors.red,"Delete")
			  else
				lg.drawBT(name,2,string.len("Select")+1,y+2,y+2,colors.white,colors.green,"Select")
			  end
		  else
			lg.drawBT(name,2,string.len("Open")+1,y+2,y+2,colors.white,colors.green,"Open")
			lg.drawBT("d:"..name,2+string.len("Delete")+2,2+string.len("Delete")+2+string.len("Delete"),y+2,y+2,colors.white,colors.red,"Delete")
		  end
		  drawCharsLine(2,y+3,sx-1,y+3,"\x8c",colors.gray,colors.white)
		  y = y + 4
	  end
	  i = i + 1
	end
end

local function selectApp(selector)
    lg.clearBTNS()
    drawCharsLine(1,sy,sx,sy,"\x83",colors.white,colors.gray)
	local scroll = 1
	for i=1,sy-5 do
		lg.fill(1,sx,sy-1-i,sy-1,colors.white)
		for x=1,sx do lg.drawText(x,(sy-1)-i,colors.lime,colors.white,"-") end
		sleep(0.001)
	end
	local apps = getAllApps()
	local i = 1
	drawAppsList(apps,scroll,selector)
	lg.drawBT("close",1,sx,sy,sy,colors.white,colors.gray,"V         CLOSE          V")
	while true do
		local e, bt, x, y = os.pullEvent()
		if e == "mouse_click" then
			local bt = lg.isButton(x,y)
			if bt == "close" then return false
			elseif bt ~= nil and bt ~= false then
			  return bt
			end
		elseif e == "mouse_scroll" then
			if bt > 0 then scroll = scroll + 1 elseif bt < 0 and scroll > 1 then scroll = scroll - 1 end
			drawAppsList(apps,scroll,selector)
		end
	end
end

local function drawHint(text,bg)
    local chars = {"\x83", "\x8f", " "}
	local bgColor = {colors.white,colors.white,bg}
    for charN = 1, #chars do
        for i = 1, sx do
            lg.drawText(i, 1, bg, bgColor[charN], chars[charN])
        end
        sleep(0.05)
    end
    drawCharsLine(1, 1, sx, 1, " ", bg, bg)
    lg.drawText(2, 1, colors.white, bg, " > " .. text)
    sleep(0.2)
    drawCharsLine(1, 2, sx, 2, "\x83", bg, colors.white)
    sleep(1)
    drawCharsLine(1, 2, sx, 2, " ", colors.white, colors.white)
    sleep(0.05)
    drawCharsLine(1, 1, sx, 1, " ", colors.white, colors.white)
end

local function userPrompt(title,text,text2,option1,option2)
	lg.fill(2,sx-1,(sy/2)-2,(sy/2)+2,colors.white)
	lg.fill(2,sx-1,(sy/2)+3,(sy/2)+3,colors.lightGray)
	lg.fill(sx-1,sx-1,(sy/2)-2,(sy/2)+3,colors.lightGray)
	lg.drawText(3,(sy/2)-2,colors.gray,colors.white,title)
	lg.drawText(4,sy/2,colors.black,colors.white,text)
	lg.drawText(4,sy/2+1,colors.black,colors.white,text2)
	drawCharsLine(2,(sy/2)+3,sx-1,(sy/2)+3,"\x8f",colors.lightGray,colors.gray)
	drawCharsLine(2,(sy/2)-3,sx-1,(sy/2)-3,"\x8f",colors.white,colors.gray)
	drawCharsLine(sx-1,(sy/2)-2,sx-1,(sy/2)+3,"\x95",colors.lightGray,colors.gray)
	drawCharsLine(2,(sy/2)-2,2,(sy/2)+3,"\x95",colors.gray,colors.white)
	drawCharsLine(2,(sy/2)+3,2,(sy/2)+3,"\x8a",colors.lightGray,colors.gray)
	drawCharsLine(sx-1,(sy/2)+3,sx-1,(sy/2)+3,"\x85",colors.lightGray,colors.gray)
	lg.drawBT("1",3,3+string.len(option1),(sy/2)+3,(sy/2)+3,colors.white,colors.blue,option1)
	lg.drawBT("2",3+string.len(option1)+2,3+string.len(option1)+2+string.len(option2),(sy/2)+3,(sy/2)+3,colors.white,colors.blue,option2)	
	while true do
		local _, bt, x, y = os.pullEvent("mouse_click")
		local bt = lg.isButton(x,y)
		if bt ~= nil and bt ~= false then
			return lg.isButton(x,y)
		end
	end
end

return { ver = ver, userPrompt = userPrompt, getFormatedName= getFormatedName, launchThreadFromFile = launchThreadFromFile, login = login, drawHint = drawHint, drawCharsLine = drawCharsLine, getAllApps = getAllApps, selectApp = selectApp}
-- End of File: system/utils

-- File: userData/123/123/test.lua
123

-- End of File: userData/123/123/test.lua

-- File: userData/123/test.lua
123

-- End of File: userData/123/test.lua

-- File: userData/Files.app
local a="local disk,size='ï¿½ï¿½2ï¿½ï¿½:hï¿½ï¿½_ï¿½ï¿½ï¿½â°½ï¿½ï¿½Ù¼ï¿½lï¿½ï¿½\\nï¿½7*ï¿½ï¿½!+aï¿½Aï¿½`ï¿½{9ï¿½_+ï¿½qBNï¿½A*ï¿½ï¿½kï¿½I=ï¿½yï¿½mï¿½ ï¿½0ï¿½ï¿½Znï¿½ï¿½+ï¿½7=vÑ‘ï¿½N4Tï¿½È¬ï¿½Ù±ï¿½{rï¿½qï¿½ï¿½ï¿½+=7ï¿½ï¿½ï¿½ï¿½ï¿½ZLuï¿½Kï¿½@ï¿½ï¿½ï¿½$yï¿½ï¿½ï¿½ï¿½iï¿½;ï¿½2eï¿½bï¿½ï¿½gï¿½ï¿½-@ï¿½\\000 !X\\\\ï¿½ã³‚ï¿½ï¿½ï¿½vï¿½ï¿½ï¿½2\"ï¿½]ï¿½W41ï¿½ï¿½1rï¿½nï¿½ï¿½ï¿½Yï¿½W]ï¿½ï¿½ï¿½ï¿½ï¿½Ñ¤zï¿½JDZRà¸¤ï¿½\\rï¿½HFï¿½U0ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½$Ø³|ï¿½ï¿½ï¿½9Kï¿½&ï¿½ï¿½ï¿½ï¿½Z2Î«ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½2=wï¿½EnFï¿½Xjï¿½ï¿½]o\\nR\\000!Ö¶0ï¿½Ö–ï¿½ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½}ï¿½ukï¿½ï¿½-ï¿½83ï¿½rï¿½qï¿½ï¿½ï¿½ld!ï¿½18ï¿½ï¿½ï¿½ï¿½\\r:ï¿½ï¿½<r\\'|ï¿½4/ï¿½u=ï¿½ï¿½ï¿½ï¿½ï¿½zG8Pï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½pÚ³ï¿½ï¿½\\rï¿½ï¿½Vï¿½Iï¿½ï¿½ï¿½ï¿½ÏuÄ¬{ï¿½0N5ï¿½ï¿½ï¿½ï¿½dï¿½ï¿½ï¿½ï¿½j_ï¿½ï¿½ï¿½4ï¿½ï¿½v)ï¿½SÈ·ï¿½ï¿½Jï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½2ï¿½KDWï¿½iï¿½ï¿½ï¿½Mï¿½}ï¿½ï¿½ï¿½ï¿½fï¿½Ş‹ï¿½ï¿½ï¿½ï¿½[\\nwnï¿½aï¿½Lï¿½ï¿½ï¿½Û½Mï¿½IE\\r$JFï¿½ï¿½;	ï¿½iï¿½*ï¿½ï¿½\\'zï¿½lï¿½	ï¿½ï¿½vá©œï¿½=%v4ï¿½_ï¿½=ï¿½v,ï¿½,?`xï¿½ï¿½>ï¿½ï¿½Nï¿½dêš31ï¿½Tsï¿½uï¿½Fï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½v=ï¿½ï¿½Dï¿½Sï¿½)ï¿½Cï¿½Bï¿½lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½U6ï¿½8aï¿½\\000ï¿½\\rï¿½2#6ï¿½1ï¿½H5ï¿½ï¿½aÚ†ï¿½Iï¿½rlcï¿½Zï¿½h&ï¿½ï¿½J9ï¿½Õ¤@.Cï¿½ï¿½7:ï¿½%ï¿½ï¿½<=l*(ï¿½ï¿½ï¿½#ï¿½ï¿½EILï¿½Ihï¿½ï¿½ï¿½1ï¿½)\\nAï¿½jAÖ²ï¿½(ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½Ó”ï¿½!Ç¾ï¿½nï¿½fï¿½8Lï¿½_ï¿½pï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½a1ï¿½]ï¿½ (ï¿½ï¿½ï¿½ï¿½ï¿½%xjï¿½_ï¿½tï¿½Xï¿½evJGC~ã¬µï¿½ï¿½<Tï¿½c9!ï¿½ÏŒï¿½D4cï¿½6_ï¿½HÎ¢ï¿½ï¿½koYï¿½iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@H\\000}ï¿½47Wï¿½ï¿½ï¿½ï¿½)H\\000ï¿½8wï¿½03oï¿½ï¿½mï¿½]ï¿½ï¿½Ì«mï¿½ï¿½ï¿½(Bï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½\\000ï¿½Yï¿½\\rï¿½x~Qï¿½Ó”ï¿½+Pvv~$lM;Uï¿½8ï¿½iï¿½<Nï¿½ï¿½*Rï¿½ï¿½ï¿½ó—¡^oï¿½ï¿½Lwjvï¿½Nï¿½ï¿½ï¿½$5 7cb	r4ï¿½P:ï¿½P*ï¿½W\"ï¿½ï¿½Ëï¿½ï¿½ï¿½Lï¿½qï¿½ï¿½QG]fï¿½ï¿½ï¿½LÉï¿½tï¿½ï¿½ï¿½ï¿½ï¿½UZ%ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½3eï¿½-NÆ‰]ï¿½ï¿½\\n\\r\\rï¿½d5ï¿½èª«ï¿½ï¿½ï¿½ï¿½ï¿½6	5ï¿½ï¿½Yï¿½ï¿½ï¿½ï¿½ï¿½\\000ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½4ï¿½ï¿½Û¤&pH-~ï¿½ï¿½Hİ§ï¿½\\000ï¿½b.ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½}ï¿½ï¿½bï¿½ï¿½WN!ï¿½ï¿½ï¿½?ï¿½Ş¬ï¿½lï¿½ï¿½ï¿½ï¿½[ï¿½rï¿½ï¿½Aï¿½ï¿½~yï¿½Ôš(R~ï¿½Dï¿½ï¿½|ï¿½Ijï¿½<?ï¿½ï¿½ï¿½Ü–%ï¿½ï¿½5ï¿½	ï¿½_ß¡ï¿½.(ddï¿½>gá¸›ï¿½ï¿½SXï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½ï¿½<~-5}ï¿½ï¿½ï¿½ï¿½ï¿½13?oï¿½vy8	ï¿½ï¿½=\\000ï¿½	ï¿½wï¿½ï¿½	Ë™y&Ëdï¿½fï¿½ï¿½ì«ˆKï¿½ï¿½,7ï¿½ï¿½Iï¿½Uxï¿½sï¿½ï¿½ï¿½ï¿½à½®^ï¿½ï¿½In_\\rxï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$}ï¿½8ï¿½ ï¿½Vï¿½YßšÆ¾ï¿½ï¿½sVï¿½ï¿½:ØªT\\000ï¿½|?ï¿½ï¿½ï¿½6Vï¿½{ï¿½ï¿½Å„ï¿½ï¿½ï¿½Â¬ï¿½ï¿½Mrï¿½ï¿½xï¿½	ï¿½ï¿½ï¿½ï¿½ ï¿½Pï¿½g>ï¿½ï¿½Jï¿½ï¿½(Drï¿½o\\nÂ…ï¿½ï¿½ERBqJQï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ä½{Ñï¿½ï¿½CÆŸï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç·\\nï¿½Ó¥Wï¿½ï¿½ï¿½jï¿½ï¿½ï¿½^eï¿½ï¿½JuIï¿½ï¿½Ãªï¿½ï¿½[ï¿½ï¿½ï¿½yï¿½ï¿½Ù…ï¿½Pï¿½@2ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½%ï¿½\"eT}H-Sï¿½?ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½%ï¿½\\'Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½c}ï¿½ï¿½ï¿½!ï¿½18EÊï¿½k#ï¿½iï¿½ï¿½[ï¿½ï¿½ï¿½à´²yï¿½ï¿½ï¿½3ï¿½ï¿½ï¿½ï¿½Ñ™ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½Æ<ÅŒbFÙ‡ï¿½\\n3ï¿½>ï¿½%ï¿½pì‘—ï¿½ï¿½/=ï¿½cï¿½1Eï¿½Ëï¿½owï¿½Eï¿½ï¿½ï¿½ï¿½Rï¿½Riï¿½ï¿½a6/\\nï¿½RLï¿½ï¿½cq,ï¿½iï¿½hï¿½ï¿½ï¿½eï¿½ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Qï¿½_i_ï¿½yï¿½Äˆï¿½0D	ï¿½\\r.ï¿½!ï¿½..Q8[ï¿½:Ru\\\\ï¿½ï¿½aOfï¿½ï¿½Gjzï¿½ï¿½:ï¿½D,Sï¿½<Uï¿½Eï¿½\\rTWï¿½ï¿½ï¿½ï¿½\\nï¿½ï¿½MQï¿½g3,Ò“ï¿½ï¿½ï¿½Wbï¿½ï¿½ï¿½mï¿½~ï¿½ï¿½ï¿½I\\\\ï¿½Xï¿½TÅ¥ï¿½ï¿½?EV<9ï¿½ï¿½ï¿½ï¿½;ï¿½ï¿½OIï¿½6ï¿½ï¿½Í‘Yï¿½ï¿½\\'ï¿½Ú„ï¿½;ï¿½Ng\\r	\"#ï¿½Vï¿½ï¿½ï¿½Wï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½Cï¿½84Aï¿½N	Dï¿½fej9ï¿½-ï¿½ï¿½<J\\000ï¿½9-z\\nï¿½Oï¿½ï¿½>lï¿½ï¿½ocï¿½ï¿½ï¿½S â˜¤ï¿½ï¿½KHï¿½=,ï¿½ï¿½ï¿½G<ï¿½,ï¿½d	ï¿½`ï¿½ï¿½/<]ï¿½Vï¿½B\\rï¿½ï¿½ï¿½ï¿½20ï¿½hï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½Lï¿½ğœ’º4ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^Ú´DFï¿½\\000Cï¿½ï¿½ï¿½;4=ï¿½ï¿½ï¿½ï¿½Aï¿½D{ï¿½Hï¿½ï¿½/ï¿½+ï¿½ï¿½uuï¿½nï¿½?mï¿½ï¿½ï¿½P1?Nqï¿½ï¿½rm\\\\ï¿½ï¿½Gï¿½ï¿½ï¿½5ï¿½,\\000VŞ‘ï¿½QE ï¿½ï¿½eï¿½ï¿½\\000ï¿½ï¿½#Dï¿½ï¿½ï¿½kï¿½0ï¿½ï¿½ï¿½ï¿½EDï¿½ï¿½ï¿½$bï¿½ï¿½ï¿½ï¿½+8Ş¿ ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½IJ:[>ï¿½ï¿½ï¿½tï¿½ï¿½Ò·wEï¿½Avï¿½@_<gï¿½Nï¿½ï¿½a0ï¿½ï¿½:ï¿½ï¿½k\" ï¿½ï¿½ï¿½ï¿½*}N~ï¿½ï¿½?ï¿½ï¿½5odï¿½ï¿½ï¿½)1Sï¿½ï¿½ï¿½,kï¿½*ï¿½ï¿½Ù˜7zï¿½ï¿½ï¿½[2ï¿½{HZÈï¿½ï¿½{ï¿½5ï¿½]`ï¿½_aï¿½H{ï¿½Oï¿½ï¿½ï¿½xï¿½nï¿½Şœuï¿½ï¿½uGK[1*ï¿½ï¿½Cï¿½ï¿½Üˆï¿½;@kï¿½$ï¿½$ï¿½ï¿½fE/E{ï¿½ï¿½nï¿½ï¿½1ï¿½ï¿½&1ï¿½ï¿½~ï¿½ï¿½=ï¿½ï¿½Eï¿½ï¿½Mï¿½,ï¿½ï¿½ï¿½kï¿½Oï¿½kï¿½ï¿½6ï¿½Phï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½SJï¿½Dï¿½ï¿½ï¿½)*$ï¿½ï¿½ï¿½Qï¿½iï¿½ï¿½ï¿½ï¿½ Â£Òˆ\\rï¿½=ï¿½ï¿½Bï¿½$ï¿½ÎAï¿½Y<ï¿½}ï¿½gï¿½ï¿½ï¿½è¿Ş¿Ş¿ï¿½1ï¿½xï¿½ï¿½Xï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½Ï ï¿½ï¿½ï¿½\\rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½fpï¿½Pï¿½ï¿½Rsï¿½ï¿½ï¿½Rï¿½hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½s1ï¿½Slï¿½iï¿½ï¿½ï¿½\\000Iï¿½ï¿½QÛ„ï¿½ï¿½Xï¿½Eh2yï¿½(.g&Qï¿½kCf1ï¿½|G{ï¿½ï¿½V\\000Eæ»°ï¿½5ï¿½-ï¿½glï¿½~ï¿½Sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\\rï¿½ï¿½ï¿½mï¿½>lï¿½@ï¿½ï¿½\\000ï¿½4ï¿½ï¿½I;lï¿½rM,ï¿½Yï¿½L4ï¿½&u4ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½wU{ï¿½ï¿½ï¿½uï¿½xyS?ï¿½ï¿½uØˆ~ï¿½Fï¿½{cï¿½ï¿½ï¿½ï¿½O(ï¿½ï¿½\\'Ïï¿½ï¿½ï¿½0tï¿½9+Hï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½rï¿½Jï¿½9cbï¿½ï¿½ï¿½ï¿½.1ï¿½ï¿½ï¿½`ï¿½Iï¿½ï¿½-ï¿½foï¿½4ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½+	\\rAï¿½#5ï¿½Rfï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ú“ï¿½ï¿½?Cå³€7ï¿½Lï¿½/ï¿½g7aCCï¿½ï¿½ï¿½ï¿½ï¿½~Hï¿½ï¿½É’ï¿½ï¿½ï¿½ï¿½Wgï¿½W]ï¿½ï¿½r\\rï¿½l&8ï¿½ß‘rï¿½ï¿½yï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½]+Dnï¿½nKTï¿½Ë¾bU2Hï¿½1Üšï¿½fï¿½=ï¿½ï¿½ï¿½ï¿½î¤ï¿½;CSï¿½+]^_<ï¿½ï¿½ï¿½ï¿½ÜŠTF#ï¿½\\rï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½ï¿½Gï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½#? Q\\rï¿½[ï¿½&gï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½+	ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½&\\'ï¿½ï¿½ï¿½ï¿½/ï¿½`ï¿½ï¿½I9kï¿½qY?ï¿½ï¿½Gï¿½Hï¿½ï¿½ï¿½ï¿½Cï¿½Ä­D<ï¿½MÈƒï¿½Jï¿½ï¿½\"7hï¿½ï¿½$\\000ï¿½ï¿½KSï¿½ï¿½Î£ï¿½sï¿½XĞªï¿½ï¿½N!Oï¿½zÊŸï¿½Nï¿½yï¿½ï¿½Pï¿½oï¿½Íƒï¿½xZï¿½:ï¿½Î˜ï¿½f@^ï¿½ï¿½ï¿½ï¿½x#ï¿½ï¿½[)ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½Ç‡ï¿½iUï¿½ï¿½ï¿½pï¿½È¨ï¿½ï¿½Xï¿½Éµï¿½ï¿½Ì¯AĞ$ï¿½dÎ•5ï¿½9ï¿½[ï¿½\\000uï¿½Eï¿½ï¿½kï¿½ï¿½:ï¿½Pï¿½]SBï¿½Flï¿½ï¿½ï¿½V5ï¿½ï¿½ï¿½Fï¿½@ï¿½ï¿½ï¿½7Ø£ï¿½jï¿½Sï¿½Dï¿½Iï¿½J>ï¿½ï¿½ï¿½XM%1cï¿½ï¿½e#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Mï¿½kï¿½\\rï¿½ï¿½jï¿½*ï¿½ï¿½ï¿½ï¿½>Ş§ï¿½.{6ï¿½Ug:ï¿½Ëï¿½)Pï¿½Vyï¿½)ï¿½oï¿½ï¿½oï¿½kï¿½&z:ï¿½eï¿½sï¿½ï¿½\\000ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ‡Iï¿½q}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ F3ï¿½Tï¿½qï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vu\\000ï¿½ï¿½vAï¿½ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½ ,~6*ï¿½Ã±^ï¿½ï¿½ï¿½UCl=*ï¿½ï¿½&ï¿½ï¿½\\000ï¿½Ç”ï¿½h#Rï¿½ï¿½ï¿½ï¿½ï¿½<Ñ«|ï¿½ï¿½mï¿½iï¿½B&Lmï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½XUg7ï¿½ï¿½ï¿½E\\\\ï¿½<:ï¿½ï¿½O$ï¿½ï¿½0ï¿½ï¿½Ó”-3|Sï¿½ï¿½Bï¿½ï¿½ï¿½}ï¿½ï¿½ï¿½cï¿½;<ï¿½@ï¿½7&@ï¿½dï¿½ï¿½ï¿½	l\\'61ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½S\"P	ï¿½Eï¿½\\rj`ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½J_ï¿½bï¿½ï¿½1ï¿½\"ï¿½&Vreï¿½ï¿½Hï¿½ï¿½ï¿½e<}Vy~ï¿½ï¿½ï¿½ï¿½znï¿½,ï¿½ï¿½ï¿½;K\\\\ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iï¿½<ï¿½Lï¿½;ï¿½szï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½]ï¿½6ï¿½&]ï¿½ï¿½pn\\r	ï¿½áµª!ï¿½ï¿½4ï¿½@<&joÍµ*cï¿½ï¿½i6 ï¿½DcÜ²y}ï¿½#!D8Nï¿½ï¿½/ï¿½nï¿½pCï¿½ï¿½Aï¿½~ï¿½=ï¿½cï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½gï¿½-ï¿½ï¿½ï¿½=ï¿½ï¿½1ï¿½ï¿½fï¿½4N.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½2<Tï¿½\\nï¿½ï¿½ï¿½ï¿½\\\\ï¿½ï¿½Ş§Yï¿½ï¿½ï¿½U)ï¿½ï¿½ï¿½Rï¿½Groï¿½ï¿½sÙ”EI]DYß¢ï¿½É«+ï¿½ï¿½ï¿½Qï¿½6ï¿½ï¿½5ï¿½ï¿½ï¿½>5/ï¿½Aï¿½hPHï¿½ï¿½ï¿½aQawï¿½ï¿½ï¿½(Aï¿½ï¿½pqï¿½ï¿½ï¿½Ñ¹ï¿½ï¿½sï¿½ï¿½ï¿½x&Fï¿½ï¿½ï¿½m_GVï¿½iï¿½BŞ¥&ï¿½\".ï¿½&ï¿½k/ï¿½+ï¿½ï¿½ï¿½,ï¿½oï¿½Ğ„Ì± ï¿½2@ï¿½t}ï¿½gï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½)O<-Qï¿½Uï¿½ï¿½jÅ¨>ï¿½D{ï¿½ï¿½ï¿½Ô·sï¿½K_ï¿½Ñ¬+ï¿½ï¿½rï¿½ï¿½ï¿½_{)xï¿½8FTï¿½\\000ï¿½ï¿½\"ï¿½Cï¿½a]ï¿½+ï¿½ï¿½*ï¿½y.+ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½kï¿½>iG\\\\y)ï¿½ï¿½Gï¿½BO%ï¿½ï¿½!(ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Mï¿½oÑ»Cï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ueï¿½ï¿½tï¿½ï¿½Uï¿½-3ï¿½ï¿½ï¿½ï¿½eï¿½ï¿½İ•ï¿½Xï¿½:ï¿½&ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½nï¿½Wc8ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½xï¿½LQrï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ô’ ï¿½ï¿½ï¿½,:ï¿½pï¿½hï¿½ï¿½ï¿½ï¿½ï¿½/1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iEï¿½1ï¿½ï¿½ kï¿½@ï¿½ï¿½ï¿½@ï¿½Ä‚.*ï¿½ï¿½ï¿½ï¿½\\rï¿½=;ï¿½ï¿½-ï¿½ï¿½=ï¿½ï¿½\\';Rï¿½ï¿½ï¿½Tï¿½\\000JQ=hï¿½ï¿½_hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4Pq/ï¿½d\\nNï¿½ï¿½6ï¿½ï¿½ï¿½ï¿½/Oï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½d\\'ï¿½8vnXSï¿½Y1`\\nqï¿½Oï¿½TthŞï¿½ï¿½~{ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½	Sï¿½~ï¿½ï¿½EMï¿½ï¿½ï¿½:\\nï¿½ï¿½\\'ï¿½ï¿½ï¿½\\'R6ï¿½ï¿½ï¿½ï¿½ï¿½ë»§,ï¿½ï¿½+9Ç”gUï¿½Oï¿½iSï¿½Vï¿½×»pï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½OR$ï¿½~6ï¿½Rmï¿½O{ï¿½ï¿½&ï¿½ï¿½ï¿½Rï¿½7ï¿½ï¿½ï¿½Fcï¿½E4ï¿½ï¿½ï¿½ï¿½LXï¿½ï¿½ï¿½ï¿½ãœ³ï¿½/ï¿½B#ï¿½|ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vUmbgÛ¤ï¿½ï¿½2|Oï¿½ï¿½ï¿½ï¿½Y|ï¿½ï¿½Bpdï¿½ï¿½Cï¿½uï¿½ï¿½ï¿½ï¿½ï¿½A`ï¿½Ã¦ï¿½qï¿½ï¿½ï¿½`ï¿½M*ï¿½ï¿½ï¿½Å²Ş‚ï¿½ï¿½ï¿½qMï¿½Eï¿½ï¿½ï¿½ï¿½*?ï¿½Lï¿½F2kZï¿½tï¿½7V;ï¿½ï¿½ï¿½ï¿½ÂŸ6_ï¿½9uï¿½ï¿½jï¿½]ï¿½ï¿½Mï¿½ï¿½ï¿½\\'ï¿½ï¿½zG\\n[Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½.eï¿½ï¿½6Òä—¥ï¿½lSÆ½[ï¿½ï¿½lW\\\\ï¿½İ”[ï¿½ZsÓ¯İŠï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½\\rÄŒï¿½ï¿½`Sï¿½Ø¹ï¿½ï¿½@N-;Q?tï¿½Ï”MDï¿½5Gï¿½Â—ï¿½v{z;&{ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½-.ÈTï¿½LJï¿½#ï¿½\\'ï¿½gï¿½ËjFï¿½Zvï¿½hï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\"ï¿½(dï¿½ï¿½;Jfï¿½o)2ï¿½\\\\ï¿½uDï¿½ï¿½yï¿½@ï¿½ï¿½a@ï¿½#Hï¿½Iwï¿½BÆ¥e$ï¿½ï¿½>ï¿½\\000Vï¿½SyĞ‡ï¿½ï¿½{cï¿½ï¿½;Æ|GgL*.ï¿½ï¿½ï¿½sï¿½Dï¿½ï¿½Ö¶ï¿½ï¿½ï¿½İ†ï¿½OPY.ï¿½ï¿½Î¬|fï¿½ï¿½ï¿½Ö¶oï¿½ï¿½Cï¿½ï¿½ï¿½6ï¿½Xï¿½7ï¿½ï¿½ebÈ€ï¿½ï¿½eï¿½yï¿½rï¿½ï¿½)3Nï¿½ï¿½#ï¿½3*\\000Gï¿½ï¿½Iï¿½!ï¿½Bï¿½MSï¿½@\\000ï¿½Ì²ï¿½ï¿½ï¿½Í¥ï¿½rBZSï¿½[ï¿½ï¿½Zï¿½_ï¿½$7$ï¿½0x/ï¿½ï¿½\\000;1x1v\\000Â¸ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½\\nï¿½aï¿½Vï¿½q!ï¿½>%ï¿½ï¿½Vjï¿½Iï¿½sï¿½ï¿½Lï¿½ï¿½ï¿½Sï¿½Yhï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7AUï¿½Kï¿½ï¿½1ï¿½Ë‹ï¿½t!,gcï¿½]ï¿½1~ï¿½ï¿½L\\nï¿½dï¿½ï¿½ï¿½ï¿½\\\\0ï¿½fï¿½{3ï¿½$ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä–ï¿½Ö¶ï¿½:Uy5$Eï¿½w0)mï¿½ì  ï¿½ï¿½Pï¿½0ï¿½\\\\ï¿½ï¿½ï¿½Ü‘ï¿½Eï¿½+ï¿½3ï¿½Ë„ï¿½ï¿½;	ï¿½ï¿½ï¿½ï¿½4mï¿½!Oï¿½ï¿½ï¿½X!ï¿½ï¿½vï¿½ï¿½Hï¿½ï¿½ï¿½CÊ‚Oï¿½ï¿½ï¿½4\\n**ï¿½ï¿½ï¿½ï¿½~ï¿½t	Dï¿½Q\"ï¿½ï¿½24ï¿½rï¿½ï¿½\\'Kï¿½Kï¿½ï¿½ï¿½@ï¿½rï¿½|ï¿½ß›ï¿½ï¿½ï¿½ï¿½ï¿½`jï¿½vï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½ï¿½Ò³ï¿½*2(ï¿½jtï¿½ï¿½ï¿½ï¿½ï¿½J>3ï¿½gï¿½7ï¿½36ï¿½,ï¿½ï¿½duL$ï¿½Jï¿½ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½)zï¿½ï¿½\"\\'ï¿½ï¿½Z[Û½_jï¿½wNYï¿½eï¿½ï¿½Y@9ï¿½ï¿½Npï¿½ï¿½`}Zï¿½ Şº@ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½8ï¿½8xPØï¿½ï¿½Cï¿½tï¿½ï¿½ï¿½5ï¿½.ï¿½ï¿½Dï¿½ï¿½Hï¿½ï¿½ï¿½Pï¿½ï¿½_9^ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½9	ï¿½}ï¿½-ï¿½hï¿½ï¿½Ñ¾(UEï¿½Lï¿½ï¿½@TÖ±Zfï¿½Vï¿½%,ï¿½ï¿½ï¿½vï¿½_]ï¿½ï¿½ï¿½]ï¿½ï¿½K5\"ï¿½$ï¿½xï¿½tÂ˜QKX8ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½yNï¿½?ï¿½Eï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½Hï¿½*é­Ÿ>Ğ”ï¿½dï¿½aQ>Ğ¦Aï¿½ï¿½ï¿½Iï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½o^eï¿½Pï¿½O\\\\ogÄ¡0Êdï¿½uï¿½ï¿½#ï¿½vvXï¿½bï¿½ï¿½cï¿½ï°…ï¿½ï¿½ï¿½ï¿½Ñï¿½LHlAVï¿½\\000\\n&~ï¿½{ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½2ï¿½d>fBï¿½ï¿½İ¬VÊï¿½ï¿½*ï¿½gï¿½ï¿½=ï¿½ï¿½~*8ï¿½|ï¿½ï¿½ï¿½/ï¿½ï¿½vï¿½ï¿½ï¿½s!vï¿½ï¿½ï¿½cï¿½Èšï¿½~ï¿½ï¿½Uï¿½ï¿½:ï¿½Õ²c}ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½Nï¿½`Vï¿½eLSé­g/ï¿½ï¿½ ï¿½ï¿½ï¿½E1ï¿½\\\\azï¿½í‰ï¿½ï¿½gï¿½ï¿½%\\\\ï¿½Yï¿½QZï¿½ï¿½8ï¿½]ï¿½ï¿½ï¿½ï¿½Îï¿½t@!ï¿½ï¿½ï¿½?Ş%:ï¿½5QqSï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½\\'iï¿½FË¿ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½#ï¿½r.ï¿½Mï¿½ï¿½\\rï¿½ï¿½ï¿½ï¿½/$UÉ™*g>ï¿½DÎ²?Eglï¿½^ï¿½ï¿½O1uJï¿½ï¿½n3ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xjï¿½>ï¿½tï¿½ï¿½ï¿½b	ï¿½lï¿½c[9ï¿½8ï¿½-;Ó¡ï¿½ï¿½ï¿½ï¿½rï¿½VPï¿½ï¿½iï¿½:Gï¿½GVï¿½ï¿½ï¿½ï¿½e6ï¿½lvï¿½/ï¿½ï¿½L\\\\ï¿½a2ï¿½ï¿½ï¿½ï¿½ßŠKeï¿½Jï¿½ï¿½0u$@ï¿½ï¿½z*ï¿½ï¿½7mï¿½ï¿½ï¿½Qï¿½ï¿½È£ï¿½.\\\\#ï¿½dN$K`x*Anï¿½MÙ®Tw%)ï¿½s*ï¿½È²ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½`ï¿½dï¿½Ê°ï¿½ï¿½ï¿½ ï¿½z\\\\ï¿½ï¿½ï¿½ï¿½[ï¿½Sï¿½Dï¿½ï¿½ï¿½Aï¿½ï¿½1D$ï¿½6ï¿½}Iï¿½ï¿½ï¿½7yï¿½nï¿½ï¿½ï¿½6ï¿½ï¿½ï¿½$=ï¿½ï¿½+Ç°s0ï¿½ï¿½ï¿½Å¼ï¿½Z@ï¿½ï¿½cî·kï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½(+ï¿½ï¿½ï¿½Ğ3ï¿½Q\\nï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½Gï¿½\\n^ï¿½ï¿½xÊ³ï¿½pOï¿½ï¿½ï¿½}ï¿½aBï¿½XB0\"ï¿½ï¿½ï¿½Jï¿½T,$taï¿½ï¿½ï¿½Geï¿½ï¿½EbGï¿½(Pï¿½ï¿½ï¿½vï¿½JCï¿½L\\nŞ’ï¿½yï¿½ï¿½ï¿½ySï¿½QDï¿½\\\\ï¿½Yï¿½Eï¿½ï¿½å˜£İªï¿½h#ï¿½ï¿½#ï¿½tU5hï¿½ï¿½Ö¨Qï¿½×“~F6Xï¿½ï¿½ï¿½ï¿½ï¿½RÊ£Vï¿½ï¿½Cï¿½2ó‹£ï¿½4!ï¿½ï¿½yï¿½Oï¿½ï¿½ï¿½Iï¿½ï¿½Aï¿½yFï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½Ãï¿½ï¿½\\rRï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½\\000ï¿½,_#ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½^%ï¿½eï¿½Ù%Ë˜ï¿½G8Ù¶ï¿½P$Î‚M5ï¿½ï¿½{ï¿½ï¿½xï¿½ï¿½ï¿½wKï¿½ï¿½ï¿½vï¿½ï¿½ï¿½WcR\\'Lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ $ï¿½%Vï¿½ï¿½FkS?%Aï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½o\\n<ï¿½ï¿½ï¿½ï¿½uï¿½ÛŸï¿½ï¿½6@ï¿½}!ï¿½Dtï¿½ï¿½YVï¿½Â‘ï¿½<X\"fZï¿½Xï¿½+7\"ï¿½ï¿½ï¿½8ï¿½k\\\\TeÌ¼ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½ï¿½:yï¿½ï¿½MÈï¿½ï¿½5ï¿½Nyï¿½j)ï¿½Tï¿½;:ï¿½Éºï¿½ï¿½n|O!ï¿½ï¿½ï¿½eï¿½+ï¿½8ï¿½ï¿½ï¿½dtVIï¿½r=\\'ï¿½sï¿½wï¿½yï¿½ï¿½=ï¿½ï¿½×®ï¿½ï¿½/ï¿½ÒœCï¿½ï¿½ï¿½Ã>ï¿½q`tï¿½\\000ï¿½/_ï¿½ï¿½ï¿½ï¿½ï¿½rOï¿½\\nï¿½ï¿½t(^Zï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½Iï¿½ï¿½llï¿½ï¿½Cuï¿½ï¿½ï¿½;ï¿½ï¿½Hï¿½ï¿½%5ï¿½\\\\prJï¿½ï¿½ï¿½;ï¿½uï¿½Ì›4y\"ï¿½)ï¿½ï¿½ï¿½t[ï¿½ï¿½?ï¿½_(ï¿½ï¿½ï¿½w~T3ï¿½8^ï¿½Xï¿½^ï¿½6\"ï¿½i)ï¿½ï¿½Kuï¿½}]ï¿½ï¿½ Aï¿½ï¿½ï¿½<ï¿½8ï¿½pï¿½ï¿½sï¿½:Ù¥^1M*ï¿½Wï¿½ï¿½&^%ï¿½ï¿½\\'~U*]ï¿½ï¿½\\nï¿½ï¿½LmCy$ï¿½Hï¿½Pï¿½\"lï¿½1ï¿½ï¿½u/)ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½Ú—ï¿½ï¿½ï¿½ \\rï¿½ï¿½ï¿½ï¿½-Hï¿½^[6ï¿½Pï¿½=ï¿½t5ï¿½ï¿½ï¿½Â¯ï¿½0ï¿½jBÓœï¿½\\'×‘&1Hxï¿½ï¿½{H\\nï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½Lï¿½Ï¸+ï¿½ï¿½ï¿½ve-ß‹Cß½ï¿½ï¿½2,,ï¿½Zï¿½ï¿½ï¿½Ó5iï¿½ ï¿½F)ï¿½t^-3{:2Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½x:ï¿½prS4S:bï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½sUï¿½ï¿½ï¿½aï¿½ï¿½6|Xï¿½Gï¿½9ï¿½ï¿½ï¿½|\"tTá©ºRsï¡—\\rï¿½ï¿½5ï¿½ï¿½hAï¿½ï¿½,a!ï¿½ï¿½Ow.ï¿½ï¿½İºqï¿½7ï¿½ï¿½rNSRï¿½Õ¶ï¿½ï¿½ï¿½:ï¿½ï¿½\\'8 ï¿½ï¿½-tJ7ï¿½tï¿½/@ï¿½ï¿½ï¿½ï¿½6Kxï¿½ï¿½ï¿½ï¿½w@k0^uï¿½ï¿½nï¿½Qï¿½ï¿½m*D0uIï¿½ï¿½ï¿½1ï¿½6ï¿½ï¿½ï¿½hw6#f	oï¿½pï¿½ï¿½uï¿½)ï¿½ï¿½ï¿½ï¿½Z~oï¿½ï¿½Bï¿½u[:Ç¯ï¿½ocï¿½@ï¿½\\rqï¿½&O??ï¿½rï¿½ï¿½Íï¿½ï¿½Yï¿½%8ï¿½ï¿½amï¿½D=ï¿½ï¿½ï¿½$Hï¿½ï¿½ Sï¿½_ï¿½oï¿½0eï¿½5ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½\\000zï¿½kï¿½ï¿½ï¿½Ü½ï¿½ï¿½ï¿½ï¿½ï¿½N/\"ï¿½68ï¿½ï¿½BOï¿½ï¿½Sï¿½CZ_ï¿½ï¿½r|ï¿½ï¿½	\\\\ï¿½ï¿½/ï¿½#y/ï¿½ï¿½W!+ï¿½\\'\\rï¿½ï¿½fï¿½ï¿½ï¿½oï¿½V(ï¿½ï¿½Û½Kï¿½ï¿½hï¿½iï¿½lï¿½ï¿½sHï¿½]OT/ï¿½rï¿½H+$jï¿½ï¿½kh\\000ï¿½|ï¿½fï¿½@HW5!!ï¿½1ï¿½ï¿½ï¿½r-ï¿½<hï¿½ï¿½	hï¿½ï¿½ï¿½ï¿½Xï¿½ï¿½Rrï¿½ï¿½Hï¿½ï¿½ï¿½Yï¿½rï¿½ï¿½Û¼Nï¿½Õµ\\\\cï¿½ï¿½ï¿½!7Üï¿½ï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½iG$ï¿½5>ï¿½ï¿½ï¿½2ï¿½ï¿½9ï¿½ï¿½ï¿½`}ï¿½ï¿½ï¿½R×‰>*ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0Ø¿ï¿½k`ï¿½ï¿½ ï¿½Oï¿½e/ï¿½ï¿½ï¿½b\\rï¿½ï¿½9)ï¿½ï¿½jKiÇ„ï¿½ï¿½ï¿½cOï¿½,j#|ï¿½sï¿½ï¿½ï¿½TWï¿½ï¿½Ey+ï¿½Qï¿½ï¿½`ï¿½ï¿½ï¿½Åª6 @=ï¿½1ï¿½ï¿½=ï¿½ï¿½-\\nï¿½ï¿½ï¿½Pï¿½ï¿½EJï¿½hï¿½ï¿½ï¿½XjÊ¬ï¿½ï¿½ï¿½Iï¿½ï¿½-ï¿½ï¿½slï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½2Oï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½(Ìªï¿½ï¿½XKï¿½xï¿½$qí„“$ï¿½ï¿½ï¿½dï¿½ï¿½Ï©ï¿½Ê¬ï¿½hï¿½ï¿½ï¿½bï¿½G-eï¿½ï¿½ï¿½ï¿½=$Lï¿½ï¿½XRÜŒï¿½ï¿½orBï¿½pfï¿½ï¿½nï¿½{ï¿½	X\"[ï¿½lï¿½{ï¿½ï¿½bï¿½Kï¿½\\'\\000ï¿½ï¿½#!ï¿½Ó)~ï¿½<ï¿½ï¿½;ï¿½@rï¿½~ï¿½zS5ï¿½Å„ï¿½bï¿½Kï¿½ï¿½1qï¿½ï¿½ï¿½ï¿½MiUziï¿½ï¿½B~ï¿½O8Mc=ï¿½IRï¿½ï¿½ï¿½yï¿½,ï¿½Sï¿½&ï¿½3Iï¿½ï¿½fï¿½ï¿½ï¿½nf0ï¿½fiï¿½]FYtï¿½_Æºï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½Â—ï¿½ï¿½*ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½niï¿½(zï¿½*qï¿½Ê»ï¿½ï¿½Ô¶^ï¿½kBE0ï¿½=1ï¿½Qï¿½ï¿½JYY8Tï¿½ï¿½ï¿½ï¿½c8bï¿½ï¿½ï¿½ï¿½w4ï¿½4ï¿½?uï¿½2Ç¸y@ï¿½ï¿½ï¿½C%ï¿½ï¿½/ï¿½JYï¿½ï¿½ï¿½Mï¿½ï¿½;ï¿½Y+ï¿½!ï¿½I~ï¿½=Ü§.ï¿½ï¿½\"m5ï¿½ï¿½%^GQmï¿½ï¿½`clÈ†&ï¿½-iï¿½ï¿½Cï¿½*ï¿½ï¿½\\000ï¿½~!ï¿½ï¿½ï¿½ï¿½ï¿½4Oj,(ï¿½ï¿½;;ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½\\rï¿½U@ï¿½ï¿½dNï¿½	/Aï¿½ioï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½treï¿½\\rï¿½ï¿½ï¿½ï¿½;tï¿½ï¿½ê·„ï¿½ï¿½$lï¿½ï¿½<rw+ï¿½wï¿½Ğ£ï¿½ï¿½ï¿½ï¿½[lï¿½/.ï¿½?1ï¿½ï¿½ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½CWSï¿½ï¿½ï¿½wï¿½Aï¿½é¡…eï¿½ï¿½%($zï¿½Zï¿½uï¿½{ï¿½4l6ï¿½7ï¿½ï¿½,ï¿½6ï¿½ï¿½ï¿½Gï¿½3e9RÇ¿vï¿½ï¿½ Â¿ï¿½ï¿½Ñ© Vï¿½lzï¿½ADï¿½ï¿½ï¿½ï¿½ï¿½;\\r6ï¿½Yï¿½È¯ï¿½ï¿½ï¿½ï¿½ï¿½Q$ï¿½ï¿½?7O2ï¿½ï¿½ï¿½ï¿½\\r~,\\nï¿½ï¿½ï¿½ï¿½ï¿½bHï¿½ï¿½bï¿½)ï¿½y`m0ï¿½ï¿½Qï¿½ï¿½U	Dï¿½/ï¿½Mï¿½ï¿½	ï¿½ï¿½ï¿½Sbï¿½ï¿½ï¿½Æeï¿½ï¿½?ï¿½wHï¿½~ï¿½ï¿½ï¿½Vbï¿½ÈPï¿½ê¬©cï¿½ï¿½ï¿½|ï¿½eï¿½Ú…ï¿½Yï¿½ï¿½ï¿½Oï¿½uï¿½m?ï¿½ï¿½ï¿½ZCï¿½ï¿½ï¿½ï¿½ï¿½Qr8ï¿½Rï¿½^Jï¿½.	ï¿½ï¿½ï¿½ï¿½Rï¿½\\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½è¤@ò¡µˆï¿½ï¿½ï¿½n×¸\\nï¿½ï¿½ï¿½\\nï¿½/YSï¿½$ï¿½ï¿½ï¿½CMï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½	ï¿½ï¿½xï¿½6fiï¿½:ï¿½ï¿½`jï¿½ï¿½ï¿½ï¿½Nlï¿½ï¿½ï¿½Qï¿½ï¿½~uï¿½kwï¿½pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½eï¿½ï¿½,dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rï¿½}ï¿½Äºï¿½oï¿½ï¿½ï¿½86ï¿½ï¿½ï¿½p8ï¿½5ï¿½ï¿½ï¿½ï¿½Ğ;DPï¿½2ÓŠaï¿½Aï¿½ï¿½\\\\s$O7ï¿½ï¿½ï¿½ï¿½Ä¬ï¿½ï¿½iï¿½>ï¿½\\000\"ï¿½74ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½KVIï¿½xdILï¿½ï¿½ï¿½.ï¿½ï¿½=<ï¿½iï¿½ï¿½\"ï¿½~ï¿½Iï¿½vuï¿½Wï¿½*ï¿½H lï¿½ï¿½ï¿½ï¿½ï¿½Â¦Dï¿½`S`ï¿½\\nï¿½nï¿½Eï¿½/ï¿½hyï¿½ï¿½ï¿½ï¿½w[ï¿½Ãœï¿½E\\rï¿½ï¿½ï¿½cZ5rcï¿½ï¿½ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½(ï¿½Mï¿½jï¿½ï¿½Ç›l:bï¿½!Z	ï¿½,ï¿½Lï¿½Ï·[ï¿½ï¿½#ï¿½1ï¿½y5ï¿½ï¿½6	ï¿½4ï¿½bï¿½ï¿½ï¿½%ï¿½Uï¿½(m\\\\ï¿½tï¿½/`Jï¿½Û ï¿½<bï¿½Yï¿½T\\\\kï¿½ï¿½ï¿½Ecï¿½ï¿½ï¿½ï¿½+b<6	ï¿½ï¿½ï¿½ï¿½ï¿½MÉšHï¿½ï¿½:ï¿½ï¿½8ï¿½iï¿½	[ï¿½ï¿½ï¿½XVï¿½9ï¿½ï¿½ï¿½ï¿½y6(ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½LAï¿½ï¿½ï¿½\\'Ñï¿½ï¿½5OGa:ï¿½qï¿½+ï¿½|ï¿½_Kï¿½4ï¿½Qï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½Mï¿½(<E[C+a@\\'Cï¿½Rï¿½$ï¿½ï¿½)6ï¿½ï¿½ï¿½ï¿½<E}1ï¿½mÄš?f?.ï¿½fï¿½\\rï¿½\"ï¿½ï¿½pï¿½Pv7ï¿½ï¿½ï¿½{ï¿½~%ï¿½ÑCï¿½ï¿½ï¿½Z\"ï¿½y\"QAï¿½^ï¿½ï¿½ï¿½4ï¿½ï¿½î§«OGtï¿½ï¿½ï¿½qï¿½ï¿½Æ§ï¿½yï¿½ï¿½ï¿½\\rï¿½ç’—ï¿½ï¿½É¢Sï¿½rï¿½ï¿½aJw&MZï¿½qï¿½Ã¶,pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Qeï¿½ï¿½aï¿½ï¿½ï¿½bï¿½ï¿½ï¿½ï¿½ï¿½hï¿½/9ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½ï¿½dï¿½ï¿½ï¿½ï¿½5ï¿½<Cuï¿½Jï¿½ï¿½TqÂ¹ï¿½ï¿½ï¿½Ê¯>ï¿½ï¿½*$::ï¿½yï¿½\\\\ï¿½ï¿½ï¿½;iIï¿½ï¿½Ã¹Í·+G{eYï¿½4ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½r\"ï¿½ï¿½{ï¿½Y\\'ï¿½jTFï¿½Rï¿½ï¿½ï¿½\\'ï¿½!=hï¿½onï¿½ï¿½Qï¿½-Jï¿½ï¿½Zï¿½.Lï¿½jï¿½ï¿½nï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½\\'yÉ˜ï¿½ï¿½!ï¿½ï¿½D:ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½gRï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iOOï¿½ï¿½VMï¿½\"ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½9or%qWï¿½ï¿½ï¿½_;)ï¿½Yï¿½ï¿½pï¿½ï¿½Aï¿½ï¿½ï¿½iï¿½\\n;1ÄŒï¿½Ç¾ykbï¿½ï¿½Xï¿½Gï¿½ï¿½ï¿½ï¿½tiï¿½ï¿½*ï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½P9ï¿½i~buï¿½ï¿½ï¿½-Ú:ï¿½ï¿½ï¿½uï¿½w//ï¿½ï¿½\\000ï¿½ï¿½dï¿½liU >ï¿½uï¿½ï¿½ï¿½Pï¿½ï¿½bï¿½UÎ–,ï¿½B&ï¿½ï¿½I\\000\\nï¿½ï¿½sï¿½ï¿½}29$ï¿½B$ï¿½æƒˆ\\'ï¿½ï¿½ï¿½ï¿½Ğ¡ï¿½Wï¿½ï¿½}3ï¿½ï¿½ï¿½oï¿½J5ï¿½ï¿½Tqï¿½\\000ï¿½\\rï¿½Kï¿½ï¿½ï¿½ÃŒ\"ï¿½ï¿½ï¿½ï¿½cï¿½ï¿½ï¿½ï¿½+ï¿½Cqï¿½y}ï¿½Bï¿½ï¿½ï¿½Ebï¿½VÍ©Ïœï¿½Oï¿½ï¿½GT0ï¿½ï¿½ï¿½ï¿½sX+}Ë¢ï¿½ï¿½ï¿½_VCvï¿½7#@`ï¿½zï¿½İ›yï¿½aKï¿½=ï¿½ï¿½%ï¿½ZAe8#ï¿½f<Î¯=uï¿½ï¿½ï¿½Mrï¿½ï¿½dï¿½ï¿½-Nï¿½ï¿½cï¿½ï¿½^ï¿½ï¿½ï¿½`?:ï¿½3ï¿½ï¿½ï¿½Ø®[3ï¿½_ï¿½kw\"kï¿½ï¿½Fï¿½ï¿½ï¿½+,!ï¿½ï¿½ï¿½sv ï¿½ï¿½\\'ï¿½ ï¿½1!ï¿½,ï¿½ï¿½ï¿½Zï¿½ï¿½lï¿½ï¿½ï¿½<ï¿½&ï¿½!?Ô¯ï¿½%P~Û,ï¿½Nï¿½È»KTwï¿½ï¿½U,ï¿½ï¿½ï¿½ï¿½^Q4Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½jï¿½ï¿½&ï¿½ï¿½+ï¿½aï¿½CSRï¿½ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½dï¿½m}ï¿½dï¿½Eï¿½ï¿½ï¿½$)ï¿½z(ï¿½]ï¿½<|ï¿½*~ï¿½fï¿½ï¿½ï¿½Jï¿½ï¿½Rï¿½8ï¿½}{6ï¿½dï¿½zï¿½`Ä¯fMï¿½ï¿½ï¿½Õ‹ï¿½ZqHYhï¿½YE9={ï¿½Aï¿½Dï¿½nwï¿½ï¿½nCIï¿½ï¿½Pï¿½ï¿½ï¿½ï¿½,\"ï¿½xï¿½ï¿½O>B9ï¿½7ï¿½ï¿½ï¿½FÎ…ï¿½ï¿½8iï¿½ï¿½>kï¿½_ß‡5Nï¿½wï¿½B\\\\ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½fï¿½PQï¿½ï¿½ï¿½wzï¿½e_ï¿½nï¿½ï¿½ï¿½@ï¿½dÛ¢ï¿½.ï¿½>ï¿½(ï¿½ï¿½wï¿½ï¿½ï¿½Rï¿½1ï¿½ï¿½N1ï¿½pï¿½pï¿½/Jï¿½ï¿½ï¿½7ï¿½;Fï¿½ï¿½.ï¿½ï¿½ï¿½lï¿½ï¿½9ï¿½dï¿½ +ï¿½)ï¿½<ï¿½\\000ï¿½ï¿½pDmï¿½Aï¿½KE@ï¿½ï¿½m`ï¿½-ï¿½ï¿½\"ï¿½ï¿½}à¤Šï¿½%ï¿½pï¿½ï¿½ï¿½<<ï¿½]+yï¿½,@tï¿½ï¿½ï¿½ï¿½J9Nu&5nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9bHï¿½Gï¿½;Oxï¿½poAï¿½ï¿½e_oHï¿½uï¿½Rï¿½VCï¿½ ]\\'ï¿½-ï¿½\\\\Eï¿½ï¿½M9ï¿½ï¿½nï¿½vIN`ï¿½ï¿½WBï¿½Cï¿½Vï¿½!tï¿½eï¿½	ï¿½ï¿½Qï¿½Ì’/ï¿½ï¿½ï¿½_ï¿½ADtï¿½<ï¿½_ï¿½5\"ï¿½rÄ“ï¿½ï¿½y*bï¿½ï¿½x0ï¿½	ï¿½be2[2_dï¿½@ï¿½ï¿½CGï¿½ï¿½ï¿½ï¿½ï¿½\\'O__ï¿½!ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½Å©Õ¹Xï¿½kwï¿½+ï¿½ï¿½J@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½:ï¿½T\"jï¿½*,tï¿½3ï¿½P0cï¿½ï¿½ï¿½dï¿½ï¿½ï¿½3mF\\0000ï¿½pÅ©ï¿½Bï¿½:SØ‰ï¿½ï¿½ï¿½ZOï¿½ï¿½ï¿½x\\\\l)kÒ…?ï¿½ï¿½[Cï¿½%ï¿½0*Oï¿½ï¿½/cï¿½UN4ï¿½\\000ï¿½ï¿½o0ï¿½ï¿½|ï¿½ï¿½ï¿½\\rï¿½ï¿½9aï¿½ï¿½ï¿½`qï¿½qï¿½oï¿½ï¿½oÓ}6ï¿½?ï¿½7Û’+ï¿½Ô¯ï¿½J$A~:ï¿½@ctï¿½tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½ncï¿½yï¿½ï¿½ï¿½ï¿½PXcï¿½ï¿½ï¿½K%Xqï¿½5Rï¿½?O\\000ï¿½ï¿½ï¿½:kï¿½ï¿½Iï¿½:ï¿½<lï¿½gï¿½ï¿½D3ï¿½ï¿½ï¿½k7ï¿½ï¿½BRï¿½ï¿½nï¿½ï¿½ï¿½\\000ï¿½Xï¿½Bï¿½fï¿½Uï¿½gï¿½ï¿½Æy@B}K2KSï¿½1mï¿½uï¿½z	UOï¿½ï¿½z@ï¿½	ï¿½ï¿½Y\\n;;\\000ï¿½ï¿½wï¿½/ï¿½6	ï¿½ï¿½ï¿½Ø­&ï¿½nï¿½\"ï¿½%BGï¿½ï¿½ï¿½ï¿½Xï¿½Nï¿½ï¿½\\rPl_ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½ï¿½kï¿½fpï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ú¨tï¿½ï¿½ï¿½`ï¿½ï¿½<+ï¿½Qï¿½k*!ï¿½;ï¿½ï¿½N3ï¿½Wq%ï¿½ï¿½r$Dï¿½Dï¿½sï¿½{Åšï¿½ï¿½ï¿½mï¿½ï¿½nï¿½ï¿½iZï¿½(ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½5Ctï¿½ï¿½ï¿½ï¿½=ï¿½!ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½ï¿½V?Uï¿½ï¿½iQï¿½Wï¿½ï¿½*Pï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½ï¿½ï¿½ï¿½vï¿½ï¿½ï¿½6ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½cï¿½ï¿½nï¿½sï¿½Fï¿½Âmï¿½ï¿½ï¿½?ï¿½ï¿½\\'*ï¿½9Bg_ï¿½\\n~ï¿½ï¿½{Ktï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½*ï¿½[)@Vï¿½kï¿½Qï¿½sW6.İ€ï¿½:ï¿½[ï¿½/ï¿½ï¿½0\\nï¿½ï¿½:ï¿½5\\'ï¿½Vï¿½8ï¿½Rï¿½dDsï¿½\\\\\\000{:ï¿½TSï¿½ï¿½Ti@ï¿½&serï¿½ tï¿½Kï¿½ä…”w#ï¿½ï¿½ï¿½KQ/wï¿½VsQ!ï¿½mï¿½qSjï¿½z6ï¿½	ï¿½ï¿½77Fr$ï¿½ï¿½Oï¿½ï¿½ï¿½\\nIï¿½\\rï¿½ï¿½0ï¿½ï¿½4ï¿½TAï¿½PÛ›ï¿½ï¿½Ù«ï¿½ï¿½kï¿½ï¿½fï¿½qÊï¿½Qï¿½Fï¿½ï¿½bHcï¿½pï¿½ï¿½p0ï¿½Hï¿½ï¿½ï¿½ï¿½Bï¿½ZE(qSï¿½z!\"ï¿½ï¿½/\"6ï¿½Gï¿½ï¿½ï¿½bï¿½ï¿½ï¿½ï¿½Mï¿½iÊ¡ï¿½qï¿½ï¿½Zï¿½ï¿½ï¿½h`ï¿½ï¿½0`ï¿½ï¿½ï¿½ï¿½Xï¿½!<Lrï¿½$BfBï¿½hï¿½Nï¿½ï¿½ï¿½ï¿½05pï¿½ï¿½dIS*(~pDï¿½rï¿½J7dFï¿½ï¿½M)Ñ†1Zï¿½ï¿½ï¿½j|2ï¿½ï¿½ï¿½ï¿½B;|,ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½5{ï¿½Z!ï¿½ ï¿½IXï¿½\"mï¿½Cï¿½<\\'Ì˜ï¿½ ï¿½$`#ï¿½ï¿½ï¿½~ï¿½O`ï¿½ï¿½:ï¿½R6kt9<ï¿½yii2Í’	ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½TNï¿½ï¿½]fï¿½(ï¿½Ä„ï¿½/mï¿½ï¿½!ï¿½ï¿½ï¿½sÇ­Ï»ï¿½lï¿½ï¿½\\nï¿½ï¿½ï¿½Y~5%Nï¿½	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½E8ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½#ï¿½Wï¿½Yï¿½ï¿½[c[ï¿½Ë‚ï¿½ì›ï¿½.\\r)ï¿½8é‚\\\\ï¿½ï¿½ï¿½|ï¿½\\rt-ï¿½uï¿½Bï¿½ï¿½`ï¿½ï¿½ï¿½\\000ï¿½/Ú¬Î¯=ï¿½y?sYï¿½]-ï¿½ï¿½,ï¿½ï¿½*ï¿½ï¿½ï¿½VDï¿½h5ï¿½ï¿½dï¿½zï¿½qpï¿½\\\\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‰ï¿½>ï¿½^ï¿½ï¿½#k>WÃ¬%ï¿½FhwfÃ¬ï¿½ï¿½xï¿½8ï¿½ï¿½7wkï¿½ï¿½ï¿½ï¿½#\\000ï¿½vÛ«.ï¿½ï¿½lï¿½ï¿½p5ï¿½A&;ï¿½Oï¿½ï¿½ï¿½ï¿½É«%Eï¿½$ï¿½ï¿½ï¿½\\rï¿½{Fï¿½b?tWï¿½)ï¿½ï¿½ï¿½yï¿½v\\\\ï¿½zï¿½>Y6ï¿½ï¿½@ÙŸÓ´ï¿½ï¿½Xï¿½ï¿½ï¿½RÂ“!]qÂ¼ï¿½ï¿½a`	Î…ï¿½ï¿½\\\\nï¿½ï¿½l1ï¿½:ï¿½Vï¿½_ï¿½ï¿½drï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zPï¿½;ï¿½wï¿½ï¿½lï¿½a\\000ï¿½ï¿½ï¿½C$`Gzrï¿½/W(1Î©+ï¿½ï¿½{CDß˜x1ï¿½ï¿½Uï¿½ï¿½**ï¿½ï¿½ï¿½7ï¿½2Jï¿½ï¿½ï¿½4ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½+kï¿½?cï¿½9ï¿½ï¿½~Umï¿½ï¿½ï¿½ï¿½ï¿½N$ï¿½ï¿½\\\\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Å‰Qj\\'ï¿½ï¿½ï¿½(Tï¿½)>ï¿½ï¿½lï¿½y6ï¿½ï¿½ï¿½ï¿½\\000ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>×§ï¿½ï¿½]$ï¿½@9 Yï¿½ï¿½^(ï¿½xÎ	2ï¿½ï¿½z	ï¿½ï¿½sï¿½u*ï¿½W$ï¿½ï¿½)ï¿½ï¿½Ä¬ï¿½ï¿½ï¿½U.F|_xï¿½ï¿½D,ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½g=ï¿½ï¿½Gï¿½ï¿½rï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½Bo{ï¿½ï¿½iï¿½ï¿½^ï¿½E\"(u{Â–rï¿½tj ï¿½7ï¿½ï¿½@yï¿½ï¿½ï¿½ï¿½_N`ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½dï¿½]ï¿½ï¿½ï¿½fF\\\\ï¿½Ú³Uï¿½1ï¿½Iï¿½iï¿½WGï¿½ï¿½cï¿½rï¿½ï¿½Ê›ï¿½\\'ï¿½ï¿½zï¿½\"ï¿½yï¿½ï¿½ï¿½\\000Í ) ï¿½ï¿½ï¿½ï¿½Jï¿½Cï¿½#vï¿½{ï¿½M__Vï¿½;Wï¿½Z\\'ï¿½rÛ¤6{ï¿½ï¿½É‘ï¿½ï¿½ï¿½ï¿½Rï¿½Ä´9L,ï¿½ï¿½ï¿½ï¿½5]ï¿½!ï¿½8%@',11247 if\"ï¿½\"~=\"\\xE4\"then local a=assert(fs.open(shell.getRunningProgram(),\"rb\"))local b=a.readAll()a.close()return assert(load(b,\"@\"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error(\"File corrupted (expected \"..size..\", got \"..#disk..\")\")end;local c=require\"cc.expect\"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),\"\"repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,\"invalid chunk\")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error(\"invalid chunk\")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch(\"[^/]+\")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)==\"table\"and\"\"or O elseif type(O)~=\"table\"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match(\"^\"..aj:gsub(\"([%%%.])\",\"%%%1\"):gsub(\"%*\",\"%.%*\")..\"$\")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or\"\"if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)==\"string\"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak..\"/\"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if type(ad)~=\"table\"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch(\"[^/]+\")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)return type(ad)==\"table\"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,\"string\")if ac(disk,ae)~=nil then return\"mem\"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)==\"table\"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,\"string\")c(2,ao,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao==\"r\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local ap=ad;ad=\"\"for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and\"?\"or string.char(a7))end;ad=ad:gsub(\"\\r\\n\",\"\\n\")local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;c(1,au,\"number\",\"nil\")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end}elseif ao==\"w\"or ao==\"a\"then return nil,\"Permission denied\"elseif ao==\"rb\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,\"number\",\"nil\")if aq then error(\"file is already closed\",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end,seek=function(av,aw)if aq then error(\"file is already closed\",2)end;c(1,av,\"string\",\"nil\")c(2,aw,\"number\",\"nil\")av=av or\"cur\"aw=aw or 0;if av==\"set\"then A=aw+1 elseif av==\"cur\"then A=A+aw elseif av==\"end\"then A=#ad-aw else error(\"bad argument #1 (invalid option \"..av..\")\",2)end;return A end}elseif ao==\"wb\"or ao==\"ab\"then return nil,\"Permission denied\"else return nil,\"Invalid mode\"end end,find=function(ax)c(1,ax,\"string\")local ag={}for M in ax:gmatch(\"[^/]+\")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)==\"table\"and 0 or#ad,isDir=type(ad)==\"table\",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,\"/init.lua\")_G.fs=fs;if not ay then printError(az)end\
"local b='Files'local c=' Manager your files!'term.setTextColor(colors.black)term.setBackgroundColor(colors.white)term.clear()local function d(e,g,h,i)local j,k=term.getSize()local l=math.floor((j-#e)/2)+1;for m,n in pairs(g)do term.setTextColor(n.color)term.setBackgroundColor(i)term.setCursorPos(l,h)term.write(n.text)l=l+#n.text end end;d("App installer",{{text="App installer",color=colors.gray}},2,colors.white)term.setCursorPos(1,3)term.write("-----------------------------------")term.setCursorPos(2,5)term.write("Name: ")print("")print(b)term.setCursorPos(2,8)term.write("Description: ")print("")print(c)print(" ")print(" ")print(" ")print("Enter to setup, BACK to cancel...")while true do local o,p,q=os.pullEvent("key")if p~=258 and p==keys.enter then local r=b;f=fs.open("appData/"..r.."/app","wb")f.write(a)f.close()f=fs.open("appData/"..r.."/data","w")f.write(textutils.serialise({b,r}))f.close()print("Done!")break elseif p~=258 then term.clear()break end end
-- End of File: userData/Files.app

-- File: userData/Settings.app
 local app = "local disk,size='ØßB«†Š(¢\\n(¢Ùw€Åg•@mˆd ‡Ç¼M	8ôÚ@˜¿a_ÎÕõq¯(O<ŞÍÊJ©ñ†@tÍ¦ÍÀĞ†!&¬1m†A°F³°¹½\\rn¨§ÒÃ3º˜qO-7*—¿vtGØUqÿñI˜š½ßYuÀGîxKÈQu\\r·>kñ s_¾Û`0ÏR¯^Y –àvLá‡eÿÚÀc—ÃÌ\\'ˆ>×Oºşf×KßÑøÇ€D2G¹ªôBƒ4:ªxŠÎBÕ\\\\\\\\~y~XËeéc¤›Éñ™#L†–#U¼M®Æ¶[êÜŸ¸@‡…#¾!Æ[I/éÒyÓ8ˆ§b_õZS ÃÏB*¤Jag{ó&nòi\\r…‚ú6¬X²/3¼4JÀÊÿ4·\\réä]°>›s­¬‚zBäÉc&s”!ËÎ^çgá”£kV±cÊx–Ï¼±-ZüƒÊ6}yy×$W+*¨¹ƒ£¨­>ÊµğÈï³÷_$ßJ ©–1«ŞÍFÂ@Š3Şæ&|ZÊêF.èÓ4Ü\\'V.±¼zä¡S§ÔÃ?ºóXÏßÆmƒÙ1ÔĞ‚“7‰°æ–ç¥]6Ie(Û—®Êd‘9ƒ>d¹¡”Sõ#¯Bo\\r®0Dœ†`»Ç‹å!ypFœĞíBø6šV`¡dAà!)_GlOöÛ¼wìÎàû%æÌRşc9“º€á b t\\000=“’§UYÿ‡´â­\"†ôoæ’\"›$“}âÂ4†*àİë—x=%^”MJ¥÷Ö¯¾í³Ô>&….ìˆlO’Ğ±™;ß(ZI½È—%”›’‘Ym\\\\\\nå#©³·ÒÂ{yÑ’µ›\\000XN¸„ Ìù‹Õ›³W?%&îÊ#T¸TivÒkz‰ÀOmzõ HØVi]œ‰í4»»œIÛ\"jR—LGÙN\\ruòQ™Ô7ıQ$3Öq\\'aÕì,F6óÅ¾5E;m‘Á‹·P|ÜíåS,Á:ù¯Ûİ–WUuÄ÷Äèï¸³hó2›m\\n»ÈÁÈpÒæõ\\\\V÷}W¼˜¿)yÃ¦ïÀz®á¸û¸†0j’Un!@ºs)Of†¦ôO‚k’SSNÃ‚=n°¡\\n)^ˆzO.!k;@«ÃŞÚ˜Ç®tØéœ¸x¡¿qÀ*öyoy/¿Çÿôÿa¤¶>éÒ	„\\\\%ÿz%%:yw]˜CfÈm¾à6×ÃbŒocğgŸÒkÈ*ª@#€Y®ŒÆ­¡3µ!bo7ƒø—öAò•D…ÕPv|´±}óAÖÈÙB›ğ›ŠìÈx¹,ŒàëqÒãaÚ°	Ş:X\"+‚ïè^™DšSj¤Ú:K~›õ‹à¼™Š‡û!M“ø´‹D/\\000áæê¥ğ\\000Å\\000ÚùÂ;\"İûÖ?\\\\xâSpÕHOE{Ò_‡.ú°»~K†]Ú]S•ªNÓ\\n‹¶¼Ø¾ ¹©5İ™E+f[\\'ßaŠ’Â3 Òq‡Ç—:P„ŠÈÙLW‚ç¹FÆ¡nwm-©•Â‚„œŸÅ”/]£şâ}M\\'½ö´&­ÒØˆüÒV(YwàoZŒájU1O¦qnªÔ(ngF\\r¶¿+6hrCËµÖ¿í»“\\\\Vø9—Ğû\\nMöó‹ygÓĞã9Çôÿ-EªŞ)„Û¹FÎ÷´¬×©ÁµÁİé`Û²hè¼z®55aÄ]öÊğV?€ Öí­ß>;ÀÔåøé[¾Û.@²³;é„Qøõ‘]NĞDP­Jòœ²!ã>îÂÕº	ºh‰P#[“Ü û³‡K3ÿ’ù°»qûŠpÅ…J–ï˜®KbKşG.`¢“Ş-5Š[{h*²¦ÜMÇÃª\\rÉŸ‰VÀş35ïHşÛ]ìV±ĞÇCƒhçêÇË«2ÂA»C-¿uú\\'Àè‚‹ı’İºÂÄ°ÀâeÑufÅŞ•l÷™*”:2áÕ¨H_ÁD‘ß‰\\0002×y ¾òK’†dGÙç¥°A\\rØB8?’\\000B+ ü>	Çİ|ÈzÔÔ~ìÜZÀ€£Óù×2¨o„éQb²1]ƒ ¯ygN~ó<‚Où\\\\›­e[oıÉı’^Ö,vµ{¼jCRsqK}˜ßŞNï´™2yŒq²‡ûÉR6L#¬T’ìc\\n2TĞ¥Ùßl²=;0pj¬Ùæ¿¯Ê´ÖÔ_Õ[8ÒÕÛÆk·}9“N²ÃXåáEÏ+ö—ğç–Ù‰e”‡¿©ÃØï\\'%ëöÌÓµæ™Å2lm;œgİìU—%Ë ŠgW*/5àbëOáDÍÙ]«öıİ9C˜HÿıkÄ…3/	&]8†5°ÊCi$ZÚ ¢†ÜÌI{X±`ğ^EØÎ‡bo¸PÅî\":Ä˜:„QŠBE¸w—0[&«sr6ğML	6ôºå3ñ1Š×/%s{í€öd­œ^3ïb\\r|^ŠäÌ*)~H¬<“ô¹ÛÓ¯4òÉuM‘Ô(Şãê;Éµ%\\nİŸŞf VxL]Y¨œŒğ#ò@ğï&e*}(q²Gª¼FÁSfua€³Ù»M°>¡ögì£C\\000u¼ƒN½ U•ÏN‡áÀ¾`ù^¡îı¥™Dñ†~ÏPŸ±Ñ|ã+¼Îà„x“¶ŒÜ—¦«úÀ;í:8İçÙòúŞ<4«ªñ¼:éè„°‡\\rØõ÷„}	Ûüù@õú’›\\\\î9|›iv’Ú¢à‰f°¸RDµ:°Ï¾ãF™	6q5€–À\\000™†Ä~v¿È®7·Ë(ÿ+`B)åË#Á2L«=é5M3¶l4Ú‹HÎyÔ&3C!?şÛâêbİéßu¹»¼`Ì»¹)*.¹Í²Paí65%`O›9	•n`µp0ØjSÕö»„R\\rrÂÑMêÃodiRóıİúº°B½*&§…‰2¬½?9:¶¢|t<·u&±*ğ>—kå¯•å_rŞÊŸÇ]\"²ı›%,·ìé¹!(¥†Níéøl©\\'oğ6®Ü¨ÎÅeàL06|Ã½œñÙÊnò‚Õ7¶‡ŞÀäàüH.ìW´îyÚ2\\nŸÓúB/ÜB8Ã¹Åè”hİÃªÈÇ8wQÜHnÂÆ!¸ùÔFòt±å¶é­Å³´kå®4şˆöV	É}E¿-FtÅ@†o\"•\\000õqt1åOÑücƒ‰wgÛĞD?:¦\\\\|äõT:?Ÿ·w¶:—ÀÒ·v§º´¦Ë\\r¶`dµD[C@YÂcúˆ€{ò¦ÍIÎëb,#mÜêEX\\000‚Y;£‘”·{#ªÇJÿÓ8Qe¼UEÌRÕƒ¨?ÏDúf9züo­ìNŒ˜5VÚÀja`”Ëó_0M¸H8³¯´®/‘/‘:Íf£‰õòÙƒn: s¥öÏCs´pKíş¸òza½òÇ‡Hä©Â»÷@ğtF#±–˜4ĞÌì¸g²¸c£û¾.7S¯G¡h4gñHTMŸÛ)}oCùƒÔH`¡!y¿[ı5vºiµnÃid–)?ŠE°„+QFe)Ø„³Ka¬èU=”Ø»“úµ¼áÄº,3Æ´²ªM7/«o¨ÂùNe?xåÿ—‹Ği‰ß{®±OÌ~‡šÉşöÛŠğ\\'b»¥ç;tt¥õ0Ó¹vşûQåò·Õ¶.¶ÿ°¬:\\nî\\000²ŒõeWÊ@@x—_˜Ù@\"3µ·ŒéÄ¬ËÜÀ×Påñ}ØÌ¦iµOşÖím1ßÊCg™™°$B2Ïò(ö2z†ê}•‘(‚îê‹G±\\\\az7(UdøÆb¶XpJsNt¹ßË3·#çÄq˜HÒáûZ¾«æOÕ)`LŸo!ù[p75)ñ½9vLVÌa{Û_r-ÖE\\näj-õ7[ÉÕ0S8õ¾§p]ëÿ”üZÜíÆ3j¨Fì¤åSjK!ƒ‚øN-h0¦°H„“EŒğ‹Xcø„]åú­—_IÁMëK¨è ;Ó w¯}•5ÒÑ‘‰šqx^ŞºÁJç€oN}¸™Úœ“Õ§¬‡‹ké¿ê>a¸Ş•RÒ_•ïUx±ş ö¯´¯\\r`šGò>x•|«½¸‘¼kÃHøŠ»<[Ç04 U›s–Ò÷n¶G÷©JV‡·MßíT\\'˜Š¬CF´”eKÌ÷’íÇJõVıN³Z•]Å˜ÂW Józ&ø­¸L[ÍÙÇrõŒ ·‰\"¢_ÜİZ7=Öõ£7rø¸1Z5ƒz”c8…²óäØdeÆ4Içü˜-ì0Úï¥£Äa\\'’K.ªKv|ö(8úë”;õºfœ\\rM¡±òª›s~Î§z¹MÃîiÿÀ*áöı!­bÖ ®}1‚Z”€',3367 if\"ä\"~=\"\\xE4\"then local a=assert(fs.open(shell.getRunningProgram(),\"rb\"))local b=a.readAll()a.close()return assert(load(b,\"@\"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error(\"File corrupted (expected \"..size..\", got \"..#disk..\")\")end;local c=require\"cc.expect\"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),\"\"repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,\"invalid chunk\")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error(\"invalid chunk\")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch(\"[^/]+\")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)==\"table\"and\"\"or O elseif type(O)~=\"table\"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match(\"^\"..aj:gsub(\"([%%%.])\",\"%%%1\"):gsub(\"%*\",\"%.%*\")..\"$\")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or\"\"if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)==\"string\"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak..\"/\"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if type(ad)~=\"table\"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch(\"[^/]+\")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)return type(ad)==\"table\"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,\"string\")if ac(disk,ae)~=nil then return\"mem\"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)==\"table\"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,\"string\")c(2,ao,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao==\"r\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local ap=ad;ad=\"\"for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and\"?\"or string.char(a7))end;ad=ad:gsub(\"\\r\\n\",\"\\n\")local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;c(1,au,\"number\",\"nil\")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end}elseif ao==\"w\"or ao==\"a\"then return nil,\"Permission denied\"elseif ao==\"rb\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,\"number\",\"nil\")if aq then error(\"file is already closed\",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end,seek=function(av,aw)if aq then error(\"file is already closed\",2)end;c(1,av,\"string\",\"nil\")c(2,aw,\"number\",\"nil\")av=av or\"cur\"aw=aw or 0;if av==\"set\"then A=aw+1 elseif av==\"cur\"then A=A+aw elseif av==\"end\"then A=#ad-aw else error(\"bad argument #1 (invalid option \"..av..\")\",2)end;return A end}elseif ao==\"wb\"or ao==\"ab\"then return nil,\"Permission denied\"else return nil,\"Invalid mode\"end end,find=function(ax)c(1,ax,\"string\")local ag={}for M in ax:gmatch(\"[^/]+\")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)==\"table\"and 0 or#ad,isDir=type(ad)==\"table\",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,\"/init.lua\")_G.fs=fs;if not ay then printError(az)end\
" local name = 'Settings' local desc = ' Manage your device' local ver = 'v0.4' local dev='timuzkas' term.setTextColor(colors.black)term.setBackgroundColor(colors.white)term.clear()local function a(b,c,d,e)local g,h=term.getSize()local i=math.floor((g-#b)/2)+1;for j,k in pairs(c)do term.setTextColor(k.color)term.setBackgroundColor(e)term.setCursorPos(i,d)term.write(k.text)i=i+#k.text end end;a("App installer",{{text="App installer",color=colors.gray}},2,colors.white)term.setCursorPos(1,3)term.write("-----------------------------------")term.setCursorPos(2,5)term.write("Name: ")print("")print("  "..name.." "..ver)term.setCursorPos(2,8)term.write("Description: ")print("")print(desc)term.setCursorPos(2,10)term.write("Developer: ")print("")print("  "..dev)print(" ")print(" ")print(" ")print("Enter to setup, BACK to cancel...")while true do local l,m,n=os.pullEvent("key")if m~= 258 and m==keys.enter then local o=name;f=fs.open("appData/"..o.."/app","wb")f.write(app)f.close()f=fs.open("appData/"..o.."/data","w")f.write(textutils.serialise({name,o,dev,ver}))f.close()print("Done!") break elseif m~= 258 then term.clear() break end end
-- End of File: userData/Settings.app

-- File: userData/StackBank.app
 local app = "local disk,size='Øç6â¦š(¢\\n;‹#¨,‰İ4µg´ıU&5\\000Ÿ¹†ß¿`\\'^\\000ßí¾èdÓ–ªÀ`\\nĞĞİãÍk¼ÉíÙqÀËaöòbM¬¨ÜÉ\\000}Uê¡•NŒz‘ØÇ4läå@-‚´iv=¦ S»Læd±°âXÖNìê[dSØOÉ¡Cìg¦¿ n~­ªIßáŸK\\\\RnÓ\\rèô\\000ƒÖ¤k	{¦ø¢ññÊ%„óu^WUyhL	ßA)<õå¸sâI9ƒ«¨™Ù™[\\r èR5g`¼‚)ë\\\\øqÊàúŒobrìúòéÎ\\n˜ÄvVªô„ÌIßFN\\'ñ\\'@Í¢ÁW 	 Ãø°v6=?—6œñ²œAà!¤ıFqU«ÙJ‚„@Ì?N˜ú’¹ÜWÍ-	ºß‰. JÈ¸¯òç\\r/›¥¡Ø‚ä’¤q~‚,„e5!Ú˜¹2\"Ræ\"áFAƒs	hX97_‹	Ø9¾É5kâ™MH±™1y æ;bô‚ÚüwãJÿËTM!t¶Ó^Œô4JkJy&‰ÉNÈ˜	|^Rp\\\\¯D3júZ©\\000Ü‹\\\\o\"\\n Ş*MÃ\\r‹(t¬t8z46â<Î_[;¯‰ˆ§P);…&ÜÓ…¨\\'£%°$Nşr+a(ŒÔÓWd`DqÌÊÌ¶ï«àNB<yĞwìsTfÃïİ3¿mcİöh–ßÔÍI\\',-“¡¥(ìÚvF\\\\G‰\\\\·–qXD<ƒÄ\\'!\\'ºzïµP™Ñ¸<ÖNşÉÉSaÇÀBùYL†&4sÄí²jq¨Óàù~M÷Iì#¬º¥\\\\ç¨æ2ËÅÙìGÒšÊpãí¥ã«J¸î˜ îh,ø’QÙ„d¯³4.Ä,Æ·S”\"ƒTU³£6®öQbÔİ¹¹tûŞŠÒ\\\\şîºö „ˆp\\rY˜ÇèÜEş\\'+ì›Û9A{˜¿†ãî>Ì6|&‘Ö–sÃ—\\na8tz8ëÖuKÀ\\\\Ÿ·IJf#HÉ(…W@;¹¤ñÈÇ!\\000Ì†€$Çl.ahõ‘‚¿q‡I¢İd$D:/—b`Í‰BÒçÔ™’ğNU”ü uê¡^ånu\\n¸í7ERóó0…›³ö¡z…5Şƒ§ìO|:É‚AF¥z²ú3x%&SCKK)¤ßÇáÈ¥ºNlÒÀMo6ÒpbGåG2º@|26¤ê}5ß½xøšÀ,Ödy6ª³³ÃÅE/1”oÜÆ{Øl€yyªğü\"\\nÎ™ed´³ØÂ#”ëî™Õ<}eµâfÄÛ×©!xûâñ}.ànàKüÍ±„ùQIs#Ë‹­=ê\\n+ìX¿XcÉüaÀØê,8İ®Š$RœVk\\000ƒôòµü¢	Ÿ¼z’÷)-W÷\\nŠNowÁ7 ,qN®qå¾½4È¦g˜hØ¤;b¼Øğ¼ãôú6Éû2ë€Ò‰#_7O}gÚğ‡‡Oc0wiq5cµZ®¶O¦ôÎ`—Æy?Zâà¡¢ÖY{bªà¸wœW½¸—ÀÌJ9	€‰s¡„\\000 ä¨F“F¥õË®™:Iï/\\000ğµ©ƒñ±ĞÉ^™‹ç5å§¦\\000HıkGKÜŸ­µiäyÔÍf–6’“®­%Mñ\\rùMŞî+¿3­ø\"§´\\\\—Uõò³@r6t&ÀOŠN¢»)Í%$%”ü•¼U-&aşìg‘L`8¢‰ˆt#õ^\\r$#Æ\\\\©¶›X¶ˆ2s×U*ñ*ÀòA»AYWS¦‘­¹‘Õ@W3X{Ÿ<õo¥¤ÇÀeÿ`Æ~i[ñòğ«Z¹°Ò5O°l)å)ºéÛ$ÅşI\\000/ô+Hõ—§éƒ»mÇ0l-qœ t¯Tp…˜	ç@Zûª:®ÁRÃ¢Tº´ö¬öÉê›ÈI…lŞ¢ğ†sÛEâR»úÆën¼8É9*\\000ö™¼L*Åy®ü£²n âmµ(¾İµÄ—äÏûT„´Œœâvl_­R2ÿÁü\\0003¡TxsÍu‹ú·{P!&ï‡ËpOhQK#×ÎPóãhãÀdU•*®ìóeà®Ì»Á‡ÕÖ\\n¤/EÕq÷\\ræhóz4•j‡Ú*ˆâg£ğE¦\\râ\\\\Ï\"f8>-{	£BïĞ%¦£<şı§ÄC½nRk?lâBÿ¹ÊfP|1W£ƒ}{¹täZîD\"5\\000æ…³ÓÇ@PÛÀ1Œ®ŠåÙÄ4œÖpód/ØèÚM•ÄçIÀR–…\\000DJ¹¯[ æ¹åb*‘\\r½÷AIåÑXvX5şu}yX=²ºVì³1¤Yò§üí#œÂ.Y|{~ï;\\rk7q¨ÁÇÇÅuoi„¿¤Â*;*Š1éÓ{¶ÁìVNjSƒ“¨¼½wŒOe¡g®¯”Z÷¸ ïõhMi+äÇæ S¶0\\000Š›7– ô’dôenaK¯ÿçˆI]‚ÃÄS^i@vÈ²M¯›Û«<\\\\@ÁR‘8-û7v^^ºtËĞo\\000×&É½3=‚v¤mZ·AG)|¦ÌÖõ…ô\\'$‹@oÇìõÅq\\000¶:‘ø.pWùOyÖ\\\\#·ÛÉİÛÂpŠ\"al°6ƒ^Ôê_ná-&î‹ ÉÄÂœÁğê|J™!§	`~0Å£ÄçEÉÜQÔ]‰™g5üNé‚œò7)o–Lz±öëƒØÌ[/æ»›3•‹®Å7 Æ’ªÑQ\\r…Œ{g,´É\\\\_İ-R§½[Œ+Vp]ö_oÉÓ¿Y&¢Ydi,²4YË\\\\Ì.W9˜ÑŞÖ…~ô4]ıÔ+ÍÔYŞÜÉ´®Àİ{{ò¶üîÜçÌÌNÑNs_Í8›¨Ä‘µge&øutsSÇİ÷`ßmWØAşüP{Aè¤¡!õDwúælsÆë~ÿÂì$¡~{\\000‹²_\\\\.ô“–©›˜ ÚíYîà2¾ßdÆ©óò4z·uÙ#Ì£ì¥v¸zí†\"½ˆs§IÆ-êAB¹ˆë\\'Lcf|¾9^“{­Õ¬(ÜüqÀ ?ëxDçnS¦Aªİ&—¢¼òüÆIPéåMÄEÈr#PIQ2ˆuí±èL â@ó‚f5d›cú÷5IwL`šB²îLõŠ¸ÛĞ~ú…$éªoT¶S‡OŞ÷ÁèÔÂë\\nÑWÈù¿\\r‰¸(Ÿ	\"ÂÖ‘h²ÛØ£¢52+3]#Ÿ qas¤üHÁ‡¼®§Şâ¯u=ŠÎ†-}º¨&mjPüûèıA¶]wU¶¥—\"ù‡İò¥y2¥&`˜a€šU›O²?% a§µ(56!1Æp®ZÑø„#ÓãİH*B™R¥½v³İÕõ§˜è]e±?¯Œ7À=b”É”ŠşÊM `ÙZûp\\\\¹3tÒ¹ÎıE^¹ÏûKà=-RP`S5(¾EÙ!IˆgNleqßÓ¹‡ZnQ/Ä.·\\'À½ÖøÓÚUYÏta­Õˆ×¡ÑÉ°Š´ƒ¦Èu‚(‘ ó(š‚ÓÄJoP«9˜´Ê=dë=õjºŞÙ3F¡´ÇJ\"|yyğSÆÈ‹ÊŞ£œl‰{o`n@îµÆ«,‹ÖÌôÙMO¤à %ı\\\\kJiLíÆv×ìnDFñ¢ÿ2ùÓdxIİïî:å¥3 ¨W½eÓ÷ìØßáe‚‘p~VhB%ßÍö__ßÂg*P`uGÄĞôX„!ã“+S@â´\"¨É@K^HïC¶è ç<ïÿ¦Ñx]éŠ˜K¹ÆÔ@áå^=âl-¹O–†¤ºIÑŒ¡~pË3›iñv«­ài´r¿rÒû©íwş5É×e(8sàê\\nBĞH™Aë\\'ŞŒ‚¶Ã3‘6\\000„QXKÎÎºxÚYqXP!hq@(ôƒ4ÈãL³€Ìƒ²=x+ÓŒiÇjÁ¾Ë˜ûÃHf*ÇlıkÿÓôİğ8‚¨¡Œº¤…±l,Êb$‡Ä\"u@-²9>¤d‹e\\rIq–ø¢5¬ê©‰¦DÕÆTúÅQëĞå4$Ë½ïŒF†\\rÀğ–Äè#.Ø\\r×OPv«v©2ğ0õrŠëƒÏ,IZ!#=ÔKŠÇ ˆ´¹Ôã¬¹H„-ŸÈ/_½6@¢9¦#ª¡nTÿ¬F7’åÂıó(àÅ¹±q¢Ø…¦ÚsÆÕ4·ÿŒôû_o—Uæ\"â®·÷eSîK\\000Ër­kiã+/8Gì©5õmÌ¼´^31bŠ–6	´òw7šOê%ˆ™åJı²˜o1Ş|¨Š†XNbí9©óş‰È9u]\\n§Ôû½†-Pdó4TŠ\\\\Öçû˜ cS2†€¨ œ²}!ÈR)¶eÎĞ‰ß•°d€ræÏç™Ìƒbå\\rÓÜÊ&‡ˆÔ†x¼M(`Óğíû†¾áŠq‰ƒ‚÷Mw$Ì‡“ºÈï_ª}ò\\r…Í6Ğ«tªù¸öò\\rÚOCÂe|e6¿¸9{™GN}9§³5š>cŒŞÉğ˜›ËhL„câU¡?|¯÷Ç&r>ãƒŞOzngØ)7’\"”	Ğ„*ìí¸K\\n¦ÈòU~»P†…H<Ìwgè–4l¡ĞÖ/“gWÌŠ$·ÀÎî ·ÿm\\\\šœŸIĞèùhzÚTg\"yáô?Å93,œ¥û™Ï³×&,ğäÇYÎ®l1£Ÿ5\\n5³!#[œÊ1Ègtz1Û‰Ç¥b²;¾Ê±I¼¹ÄŸ äºÄÄó?Õfze/ä)v?¥²˜ÿ~=“2PâYÄDƒc˜Û½n\\'´İq^!	1[b—>3µ³§Õ^}ÖÎ¸V½ü1ÿa±€ju§ÈS¼†äRş¤]EÈ©Û\\nZ3ø1*}DªĞÅN}\\'`€>pì,êØ©¨´rp³¯E@WS`/ÙT¹hòvc‚èbé£ëÄÜÆş„-Õ˜?¤Ú§<¾åÍ¤ÖâğÖd<ºèÜk‹·z©µ:§€¸òêÓaTµ!!^‚øTÚæÓå¶08ÕzñÓknU½÷–‚ÔcNúw}kcšïó¿£X¶Ì;o!Ûn¥=Êù€ØlDœ×©x|‡F¡‚x’?èŞùÖ”3“Îrt¤‘*<ı.»ˆıC¡ú‡âÕ…x¯‚­#0s_(Ó ÍŞ Øy\\\\1øxJmßbo7Gö+)“2¾{ŞÆïÛ[-Ò%	—~x–®¢:·ê£‘9£g°ºÒ®s\\'¢ôE<}V;€‚ú«¡ï|rï€ƒümåèT•*V¿|»D¶Ê¦aÇwVS|ãÓutn·ì|¦Dl‚º”=F?¢2†´[V‚ÂçÏk])dûèC$*Ö¤«ªwI–Ïvf¢¦Ï;©*˜¯Ë+BL#óNÜí„ÄYÏK±úôL,Ì3IA8€«P „$¹£ß]ô‚ğã·§õ¼¾t]ù¼¯kŒÇXq Ïµ~¶bî¸Ğõ²9ãÔ[6\"S¤dá»¯ÕÀ•n¦Z¸UŒı‘2˜ÉÎ&VĞWÊŸûõÈÿ<Aa\\rışæâĞ/Û±UÍoıBU‘*A‡ûÌ«Ä¹ßrIY5Ç¹2(aäØ·3¹‹÷î›ï§§fóû—	=Ş&¶ï¯ï­ÁÖC˜1œ$,\\r>»\\000pFøª;¢<4¬Ÿàh\\000nÿ ´¿ñ0ÖÏ’â^êÎµ5B†|#¤/	ƒîºi9m,ï=«‰Ò¬„•_;2†Á¨—nÍ£¦LMXfAfŒR¿[Î§²3àû„ˆ&™)H•†ó©-XBTzÑ“6ÃÖZõÅ,’íåñj‹[ ÊİRÓÎµC¦ĞÈÒ3şšZupÍÆ+è¶ƒä—İENªvL;5†q“*SøX”Ó¡Ò‚ÓŠ\\\\\\nSÌ\\000í-ò k%îs½PQ\\'‡ï&¶oõÏ°í^\"µ~\\000ã°H™$N\"¾,|3é;ovåÚ3ø™­´Fp÷)PHn‹ˆÇ&…Ì¶ÿÂÎÊøh-a-¡Üag²ÂG¾Ó€È-ßF±~QV5Ëğ3Ÿ²ë2üŒrÍ².U\\000xÓ/r(øc*>?áŸ¢ë\\'2òæê‰Â“¾&E.·ûu|hRˆ&_@ı	oXDG÷Âµqôş<×¢½±pPkC	1|÷Kl:M³ñï!´dŞ4£Ölû:²Ü\\'©î/Ï²ùüœ¾s¬_§ìè±” ŞèÄc	ÄĞÍx­ıpÕGŸ\\000uîA˜(ğyV´«—n“3^\\000—¾I\"‡ê9q#c’k’Üğ?µ…aœã½ŒEšƒ¨OÌwƒ|óŸkv¾H ZtÅ·ı¯,mü¡˜·Ò1É¥º€\\'C[?ÜeM€Bá„RÀáü?T2j4´4ùZÑb Ä¨ºı^Háá¨2¬GD¥…ÂÎ¼¡Ø“ÙF©°äaqğ«@ P ?ï¦è¶ìWØ[zr©‚Œef¤Ó#N²Xˆñ—õÛäÔÇÄ8ßíZÄå›v»zÜ¹åÂmğËC¡üàŸ–Ñ¹ÊS|Pqà!9~r N²™æÉ(£³‹BúáFfƒ?;şJLUp¤è%éew½áJjeÅêÍ‚9]¸ÏˆÊª­«´–7gQØ)©p¹NY[ºæÃ&’WÎ0‘5Õ·ğÁÖ\\rõúæ‘9A¶Ïe_=ÔÁo²éeK!¦á€A´_mg?ùë÷i¤t<Ç^5·¦M)¼TR4Å-·Ç˜„XüIY ;íÛ°&¿fnßX|\\nœU‹ÿ\\000NÄûéÊè®½b”Å¹•t¹6€	â 5ÛŸ\\\\Vv\\\\\\\\Çî~_ êÚ5ú¬ä¦êÙ¨´ßY\\'»AyMnÂ–ÃqÇn @z@%•8DœMs©âÚ©0lªQû±k¨ÛO™â£ëı#”¯F(ğŒ™‘x<¡›FfooÔ%.ÉJô0š’`¶‰ƒáâÈB8ËõO.zªR/ZŸ¼ÅÅÚn¥oÏNJî4»5òJûİØ¨tB«eÄ°ÔfÆ\"{–Aêğ ¾\\\\uâÿ6ì	~óÊ‘m…Î\\\\À–røá‘˜3İštî‘ÙS6²(×¬XZ–¬Ø¢ú4stıŸ]şoB‚€?èAZõfâf`Æ^W°T2×D¯¤… #\\'m…^L•|†_Î—O#¿(ÏT^¥n*%øÆL7í;íj²Ó%ÓLjó>Û3Ô… =2‘’®­£É|—£˜«Ş¼µ^oz{ÚÏÊ­Jô	Ll®[|Îõûk},@.ôËÒ¹õ÷d“Î—™èŠÚWÇŠÕ?º\\rw])v’É¸)[˜¬˜‚OT#°†âÂ‚zs,|ÃÕ+°#:~O§a¼·\\'VÒr.%áÉælµ`?ÍlœËËÑráõÚôçÿ~Ëm[êCF¾O.ïM£<û÷mŸU= ²yàê3ıìP;ï/Ö» ä[(uÄÍŠ\\000vàs.uÀ;Ë5“t×yeåKê“§9âîS–©¸ ò¶Ø4wò»>T¿ÆO°Í(¾;Q†ë7è 1Aé·6¬“PÆè>M×atÄÀ\\\\¯ß7\\rKÏ6S§Xîøï%âšÇXøñ›aM7AUñ¼Ê·Ğá~\\000€¹bÅ<\\000å«\"ö#f±µfbA”,aM\\r¹”u|¸p˜ã,ë\\'™ÖoZ²ÿ{lbĞa&«•x3ky2yZn#cŞ[ $›ÉI÷ú®½9±À\"İÍÃØâÎ\\000{gsE(z#j¤ë²›«\\000PùÅ­Ïê¨Š”vzDÀ\\rcş„­¡/ò³…ùu§ôH%_gí,OXºğÔ9ÙÉi¡SÛsÄ\\nÈ¡®\\'gé2fÛ¯¬Æ¯4mkæâ!-d§ğÌQS&EsgvÃ,¡oq(_²,é\"ÜtİUÌsªFu—[œ’È@!n’Æüá¸¨Ru¼»4®ãM*&I\\r	£‹F½åK†½¥PF|½@ğ¦—-?)+…WÊï3\\nĞôÓKêaéÎ»æ¥4Yûø÷Óÿ	ıïì;ƒv6)@3¢	3C5—%I“°D‘É%‚D‘\\\\×Õ¿âC™¯dŞ‘Ü¤û”ö<ˆ¼ĞÚ?ŠóäWÅL«ÌxJ’äÂw›ïf®öˆ*ÍæÇ¥LŞöñ²¢ğæ²Ëç²Û¦®Y(ÒéÁü:G6®Æ4Ã\\nS5´·ÃÏÛ\\n:iMoB¬R«µëeö›0ÂH³˜EE±ó~ñ’z…öGnÃåø•Øyg*Ûø@íŒ?,ƒ€pjrY¤#\\nÄÛ‡«Ÿd_™{Ü¦±¸ije”[§Œ²)Ó#Èæ­<kÃ6õL;=²Úewí*]Íá„ÚªG¼Ê±Î¶$ÔŞòˆX0àólîmàá#ÆÁÿM´0‚ê;>6qº¸Fß76¶ÿûıOƒê°`’‰ÎUª m“Ç®û	ğÂÃ7Å‡¤ã°Á[’B†ÌŠ\\\\ñˆ‡HwDÚNC›¶¨„‡D?…@À™q“®#,TW4síµL;¸›ENET˜2pğ4é	^;Ê×¾fÅr«&K6’¡e|LËøï_!F¹Àˆàˆl=Ât(Òë1hØÊáz¥™óöaªÃ%2°–íäÚS”GIl”Ê0Ø¨êÜ„Œ¹à°‰üĞ)æUOZ]2€º849á5D¯(„c}h‰OdLöŸ &±l­ç‡6s¶!nn\"®œi«ÕCÜãG\\n‰CDsÓZºÍ(Y(fr“¼>œ:8Ä Y¯†PÉ’ÍıtŠÒíó¤PHáÌ|;z‡×EáËaÁlaôfÎıÄ”râ§eÅ¿Q›Õw…<Šx’Ñ‹t¬ûƒl³Üëâ?ëè¾FÑ<^<¤åÉ\\'ç#ç/‚\\\\\\nåªØ¯¥&ÿRvê˜r•ş¼İI\"a„½*¾½(ºPT;²YçÏÕ^“ç\\'ãë…³Ë<ffı6£Ô,…?9*Ãd‹.xšè1¼›ã\\000Û`',6818 if\"ä\"~=\"\\xE4\"then local a=assert(fs.open(shell.getRunningProgram(),\"rb\"))local b=a.readAll()a.close()return assert(load(b,\"@\"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error(\"File corrupted (expected \"..size..\", got \"..#disk..\")\")end;local c=require\"cc.expect\"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),\"\"repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,\"invalid chunk\")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error(\"invalid chunk\")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch(\"[^/]+\")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)==\"table\"and\"\"or O elseif type(O)~=\"table\"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match(\"^\"..aj:gsub(\"([%%%.])\",\"%%%1\"):gsub(\"%*\",\"%.%*\")..\"$\")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or\"\"if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)==\"string\"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak..\"/\"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if type(ad)~=\"table\"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch(\"[^/]+\")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)return type(ad)==\"table\"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,\"string\")if ac(disk,ae)~=nil then return\"mem\"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)==\"table\"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,\"string\")c(2,ao,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao==\"r\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local ap=ad;ad=\"\"for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and\"?\"or string.char(a7))end;ad=ad:gsub(\"\\r\\n\",\"\\n\")local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;c(1,au,\"number\",\"nil\")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end}elseif ao==\"w\"or ao==\"a\"then return nil,\"Permission denied\"elseif ao==\"rb\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,\"number\",\"nil\")if aq then error(\"file is already closed\",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end,seek=function(av,aw)if aq then error(\"file is already closed\",2)end;c(1,av,\"string\",\"nil\")c(2,aw,\"number\",\"nil\")av=av or\"cur\"aw=aw or 0;if av==\"set\"then A=aw+1 elseif av==\"cur\"then A=A+aw elseif av==\"end\"then A=#ad-aw else error(\"bad argument #1 (invalid option \"..av..\")\",2)end;return A end}elseif ao==\"wb\"or ao==\"ab\"then return nil,\"Permission denied\"else return nil,\"Invalid mode\"end end,find=function(ax)c(1,ax,\"string\")local ag={}for M in ax:gmatch(\"[^/]+\")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)==\"table\"and 0 or#ad,isDir=type(ad)==\"table\",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,\"/init.lua\")_G.fs=fs;if not ay then printError(az)end\
" local name = 'StackBank' local desc = ' Banking app for Stack' local ver = 'v0.4' local dev='timuzkas' term.setTextColor(colors.black)term.setBackgroundColor(colors.white)term.clear()local function a(b,c,d,e)local g,h=term.getSize()local i=math.floor((g-#b)/2)+1;for j,k in pairs(c)do term.setTextColor(k.color)term.setBackgroundColor(e)term.setCursorPos(i,d)term.write(k.text)i=i+#k.text end end;a("App installer",{{text="App installer",color=colors.gray}},2,colors.white)term.setCursorPos(1,3)term.write("-----------------------------------")term.setCursorPos(2,5)term.write("Name: ")print("")print("  "..name.." "..ver)term.setCursorPos(2,8)term.write("Description: ")print("")print(desc)term.setCursorPos(2,10)term.write("Developer: ")print("")print("  "..dev)print(" ")print(" ")print(" ")print("Enter to setup, BACK to cancel...")while true do local l,m,n=os.pullEvent("key")if m~= 258 and m==keys.enter then local o=name;f=fs.open("appData/"..o.."/app","wb")f.write(app)f.close()f=fs.open("appData/"..o.."/data","w")f.write(textutils.serialise({name,o,dev,ver}))f.close()print("Done!") break elseif m~= 258 then term.clear() break end end
-- End of File: userData/StackBank.app

-- File: userData/bank.app
 local app = "local disk,size='Øç4ã¦š(¢\\n;_ÁëG«Sfóú¾ä®%úªOÛ\\'±o|~À@Ìa±RCm94Å%©¼\\000|øV††ïAF5ó‡P„pÇgœ©g#Uz¨I@&€,!‹Øğ¨QØ)^ÄBBê\\000wƒ‹aÊQ&s½pa+ÊE©ƒ‰=ŒÓhúÅš5•Ù«#«Ïõ+˜âÀä¤šQÙÏY›•ÛoB$HãÈ;nÛ{|¬¡F`rxNš5¥Ó\\000mñ×rÏ,ˆøwòŠ´75pK¡Äö=@äÍ=fòÁ³—!D·Z`i&“¾ŸZ|\\\\ñ¨EÈ$rQ9Ì+£ĞºP8°ª2/„X¥úÚš”ıÂ%……P‘ª—JˆÔDŸæµq|AGóĞW\"J@\\0005ÁN%0¶ITKI!œn&ÖùÂlUúG Õ‡øŠMğ±ÓÛ7Ìí<á0A±9¤yÜn‚ Lu*õÌÒ¡Á±M96b†F%™ËÑ(’¯c%UQËÙé	ÏÁge{ĞÉ2:h:po‹º¦sâ3¯Ò¹ĞVÔêµ‡„Yô3Àó\\nâ+Ç©R;°Æİy½6ë´1ÏH·ªA,Õñ‡KÁR¬æ¼=†PeOU\\rÄT‰x’†›ôXXæH´ùèb!û°V0³óğò\\\\ÍUx¼%ÂÍpWŠÔIoXxF©Œ¯ÎÌ§ÎŒ³*Ø.Gßñ%¿â»ÀÄ<°™Ä¾z¡×Ô^qô¬ñô¬a	SI!M¶m6İ>ò·ÇÑë™¡Ë…†æå6\\\\Ğ4ıÂœ–lç‘tºğ.ÀÑ.÷%VÜ»ñ|IˆJ¬< A¡}p&¡]Ë‚Åù¨_@º7Nz¢daaÌq±vükãÅBòeîO+Ì—3ıbbÉ|:ö{qD`?0\"cz‰OiltgíÃ2ğ>cŸª@¢ÎŞ³Ìöÿ27RºX	›7æ—ç.2so–9¢ jFª­Í8ëœ ¹æf‡(\\000TÿUèÀ¯;€(¶Î“iÊ‹ÂıÃ±“+œékdg<‚Ù¦T©Îÿ«*¨VL…Ğg(1µó^½fô}°ÌDñ°@›dâL‹çÀõåÙ?\\nhÏµ­lIì`ÿäòæ§ÎÉ[¿çCº§?¤±º>ı$$’2zÎRÑĞºÛî@Æ´@ÈĞu	f°^‚ºc$ğv™a‚¥\\000\\r÷ªÆËÃ4I`ïód.Ğ¡\\noÄF¦ëÅUŸĞy„S,šß´!1œ´Ka5¢öø’¢˜ª§àê¬7_ŒKÿÎÔÓÀavãÔ#D¥V© ]‡PnMûT¼:]©—ùÎ%á±ó Á Ä* !QR`JEs´yóô)‰†ç õÓÒØ{@)ÙL7Cå_M5bKClHôaf‘ÔæÇ|\\000ñk	¤QÇ‘ÎÁ!~7RªøÈÜaÛ­5TeÊàP1é–\\'J8´õ™à’ÄfÕ\\\\\"mü‚İs}GÉ¯ù4è0X6Î*?ÍB?.4cûW½K²Á¤Ä7Çğ&ıŠ×Ñu{‹¹{˜;éØ±ÚÜ œ6ürPË½åÒ~Èò÷éÏ}ĞÚM·ŒfFÏóÎZÆ9™£¶PpÚ‚TÈ<Ê’¨ÙÕ ´\\\\ˆ\\000O×‘\"6V…œ‚r’ìùÂ0M™)9Úr”Ğ\\000Uë¾pÈ¡¯¨D§84LXrÅ­U	R#ŒÙj4ÁæúÎDdı<ŞÂ|»ÉOƒ“O°gŞ0Ïd1:x_&(…ğ·Ê\\'.YÛê–y*„˜oŠFLCAF8Y_‰åqs\\\\üÕÜ\"ÓP%¨î«ú¯\\000Ø²„d]Á¶ ƒBİ,`(E€}ĞÒËF’³]ˆg`0îÔÂ¹ì¬Âô4äÎ@Úù‡· Üd,m(‰³—bj ‹¤·=ARè2R%Ÿ›á‹Ä\\000v.\\r¾z/CÓğxÖe~¹ µ˜ñ«½¹ıze)Î¬%÷Òuà\\000„~xô/ö8 °Hx¹İ\\000ÃşcnÍv	§Æpù¡–E@É—í-yË€Ãyf €Ê‹3PùÏFæÀ…ºúÑóed7®Ôe_rãˆi	‚†|¥s×óÎ,›+Ín¯ãq …R‹’¹àB®	cºFP‹´=\\ndş´D%µm=€ïœzí-NkÂğìD8lp€VÚE5mˆ\\r ècæp9´@›7Ç’—3O¦4f…ùÁ‘ç©væJ]ÖZÊR°uöåwÉáğµo¬Êr_Ô÷ÕBŞr%k„K®‚¨—jk0;=‹öš`¼­’7ÜVí¬F/„šQy9qÌ«!çGLXı”	=-ŒÀóYÀ_Wç;àĞˆ\\000Ì[.Î†¹m÷ÃJ:ª­\" ¨æè ~\"WRÀà—†ÄX	«¡›ĞÖ«ybş\\000R‰küå.w[yJÑÊ‚^WÁğ\"#ä7:1,U”Ø-QÜêàƒ†ğÕğê³€’’ˆÉÎ[=™?´)ºGXA_8ôIål^êµáÔŞÆî»{s{c7bÑQé/2¹FE#øç;¨G*g>‚E…‘»ošE’¨$_šIH+ÛÍÎ6’¬¯\\\\ñË ‚å ÔSçãcÑÓ§¾ÑiÃ¿¡0/”B¤25\\n\\000l\\000”\\nŒÚb+¹gîJ9Ë¼ªìôı-hÇ(Á!+Xc‘z2%‘ºE»¥QÇjfZÅö«FÚÕ«D~È~ŒÇ0¡APåØ â{›¹sY4c,D±’±”¹QTNßCyüÅşcR¯•åïìå™U1@ú\\\\!ÆI!¶ğÂC_­AÑ?A~háúb|Œ?§àÍz	»%Œlª¥Mö6Ÿ¹2ø«sòï*x…oùso<r{¦Q‹Â]K%ušŠÑ€4ÿo\\000(­WÑ°®V¬§Áo|ÉâI)y„®ø,x¢•\\rPÒw­ˆ(6ˆÏò+à%ÅÏ\\\\.IØÀÆs5áT:g¾¿ê‘ØÀ~V‡aŸu\\'!—a!uÕjå\\rl¦Ø?Å,÷ËwµfxN×öcšßCTñ&õùàé3òq™Ùõq´®O·Š¬?Şµ¿òıkŠN‡JĞT GvG#´µ\\'Ökx\\rZß²ƒ¾åÂê“ß9ò¼§Sty@Ãó¹-éıŸCŒ>Å2#¶Øn}İ*9Š#÷6cüİùº2.·ø£•ı;‘¡¹MrÌÓ³û¼“ºk	–¸cúnÌÛ™¿\\'Ë-¾ky‚OÄ»	‡ü¾¦Å3|Ş^KRÌ«ã)Â;,†bJX¸~qÜµ“Îë]]–ñ¶±#„áà“\\nVTŞ-âÆ²y²j™c¸\\\\@$œáIõXã>[nG:nwCÒ‡G6¤şºŒİbÂ‡yqº.ªIÍè3\\000NòÃŸÏ(ïãê×ÄLc--Ç­±j*¹9MCœQª¾;„H…ÎÎP¤IhwVY™ÚrùˆM9)g¨3jĞÈXÈÛeÚ¤‚ı÷`”}Œ‹à:w—Hµ~\\\\ÓÑ_ÃÓ%Ğ-Å({ëUÍÑä?³ì(NÒ=æ¢iR>%Já4xT-/õüª3ôê9Ška=H|×ÔwûÅlÓ˜¡÷›è…êN»\"kÄ¹ê	ÑÌxÑ?ÿ“=Íïğ; HšTPè~­I]„‰?Xgú•ºC?ÊCš­¯}dŞ±İ¤ûšö<(¼ÜÚ?ªóâwÄ¦U&<ˆĞ®Ìo¹Š¼Ø¤İ}³“3ûÛÜÊˆÛšÏ`°;nÙ€ad°U÷{Ïbä/Ô/¨Ú\\\\©†óÙKÜ÷ÃÄÛé:o\\n8Ş‚eX&İP[Ô¹dãŠ–‹ˆÎ±ó&KôOÖóuÓlù5!…§K\\\\ /¦tAŞ`jeœÒ|…bğX^àÉgÜ¦]ÆSœNIjÒÔY•Œ5û¦Î‘Îb^¨ÛÊI0d{šm¢ş‹ÈT·IÃÇÓÃî²§s…]‰q7³ ±ÿã ÌX®şT«k­É¬<æ4™«ş»K¡Û6ìtqÔ«ûÊ‡œm[ èª/›„9ö½ÈyÅÌ>…všïñšşxi`=üæ}¸8·êĞşo7üUi‹Ê|VnN²¬É#ñ˜M”èÍÏ¹ûÈ=,CÊtyO<û+¹ùÂ¨Â‚Ìş<Æ:qÆ0°ŠÌ¥†\\000Æ\\nø¡æ°1p±›Ã×å¹·ÃqçÙERÈ¨í2!ræ_†½Àn sÓYBV¡Û’øüŞÑrjã?s$7(«æıkDBDõöå\"^ÉRŒ8~Ğ )`‘„cğû×ä°V–¿µ[I	ã²9\"È.Ñíƒò4]µ‚¢¹t+>f@òFÏ!²àØ/•8Acy –ßEİ‡ñ”×üÙ6¬§Â„n`a_JÏzÚ½@äøé,ZØ©Uz“\\'[kë=Üq2>÷òu´y”‰qLåbœaqf|„!ÚáÇ$\\n€ŠƒnĞ¾¥‘Çìp0 TĞe9J\\000\\r¨7\\rÙıáM£{?üyM½Át•~m‚‰¾æÆ€š{½{5˜</[z!EºìÄêLHÈ£8èá¸ÒRgˆ$//i4)+XXÈBöY/YÑRy\\'ÑĞ› İÚ/À©ÿX†8-KÑ$I§â\\000ı¡âºi i^@ƒà×n›‘M„ğ¢\\'º„šeWŒ(’Ó‰¬NÃOSÀÀNÑ®Ã¨9J(··<ZË[ª‘Ær=WÈ¸ís·d&iøoåQæïåõğ€á“àsWÀ.nHÃ#ı9¢¼TİÄj¶×&l×.çÜĞ¦JËŠ	f¶ò±Òn°Láy·†›n4Ş-v¥ò±ù˜ë‘à§óÄ%¥l‹rG8Á¨Ì9¹.}(BV«€º„dzrfáÚ§ÙC·}*®n<.¦ƒ	\\000º=x3N3§Dq>ó€#*ˆS‚•}UcÀ.èÿ©7ÿRkÚ½ßõhö‘ˆúâtg³=«Ö8Ø*TÉÒâå·¼İtÌ+»A<*eÙÑëVNûüïà»_Ú7~:l©}‘£_Î7í…‰T¤­)ËJÍUf÷ÀPKv„óØ\\'û±¢æ¨—j3äè‰n`G*r\\'‘Ø~µ  ¼oi46ÁşÅ+ÿJ²çœ‹?Î]KÏÁÌµö«8ç1ÌíA£_Alsw!Ú	>âÓ1–yğPUƒK,ˆ W`Ø@ˆø®MË#eX<ÃeÅææô×Lél5˜º¨uÅ/iµ¦4r•pßìR«=\\000F2nÉceäİ@õ§à°›Š`’š\\'©ÜİYx@ŞÏæ{_ãõ	å¥@¸\"OğX€Ç°çëÕUïä¯S¿mÓ‡àğüVm8Æ’xrÿ\")ª¸Ï°	d˜èbBÇ•wíÆ	ºq•áR”8“…u2³÷E[ï\\\\”B”ï¨³lÒù×g\\n9Yán·\"tĞLLéd\"±<Ëº²wSœx÷x“.ÿ­špÉz? :³ƒtB>Nø!:zcnÃ]ä•ıº^£İÉ_H¾_à4ô†áÍç!X™Ô¿ÎL²gÀÆcP9É©8WÀ¨¹¾E€^ZÈ77µ^öÅl91‡„’ÇX\\r(£\\n_¯óõtŒ€Ÿ£=%V,SRM…´5ÿ/ê\\r>{Z9lÄÍıÂÕqÅö¥^,“p)‘†*Ë¶Aâò3Ÿ\\000+Ö\\000£¶„`›1,’¶y=·ÈP2r†NF\\'#.Iğßúù¯æA1$M¹9i›$)Ü	>ÆørŒğ)íÌ¡~s¸CÆ´ãşì¹ùé¦_$ôı}1Õ…œ­AO¾4)5\\n¸—€˜ÏÉgÈªæ©º`Iì9…‚=°â³œ‘G³kœP+¹	>òKçØØWk¾âÎ$¡ĞÛƒCd\\'†)‰ZÍˆ8ÂÈ6wÔe+aP÷QÅ³PŠÒ˜táóTB®üúh+®Ò+71Çm¹X Ü“2F-a)‰\\\\ÄªÃùÑ—®÷‰§K.`cÓ‘k2Ş`ÑÚ Oˆ3‘Èğ2¸¨\\'Rş:5ÖÒ3	¡Æ×2rÛgÂ¾¼á«¨±&\\nı€/ªMF`¸¦\\'_7Eİ¨\\rƒôv\\'¬.–D¦Œ±\\'ƒL¯ûDS]Íıh+Ã„O…•8-@ã:øI\\\\*ÕµÎÿµ_UáKó¹7mH*ÎÏ’z‘+ŠËÇz–şl.øg E¹é,4=O`Ù\\000á)…uf‘ƒ°5Ö§T¿i”ßxNÔô?H§ÖKŞœ¯›ºŠğì¼²ôUµ¦ƒô£ÌÚ–RèÄ‹ïkW×Hu½}ÚŸI›øñ8«\\nç¸«(ùçXywc´j&k|‘X(ùØFÌ\\']ÅƒZqY÷÷vï#¦M‹b€:ÚĞ—~yà‘,c0p9Bƒ®€KèuÉvëf?QÔ`ÇgÇ2=ÚÃ CeÀŠ˜O‹íˆùRÿ%[»ñ¡×$‚’Õ¸ÙHT‰p2˜ n<FĞ@\\\\Á±\\000¢l™®şzÙû‘l?à³fP3ìòèxñu–G€¹¸®ÉQM5Şé¤i¶& >0†G¿ÎÔÔóÒ.>€÷8Ï|ûV˜3:{î§]Aò=ho²Ó(‚ìIÊ:Gûê5W¹qÜiÓ$=|Æk;qùÑZÓnËïCğğ+5ˆ¸äLÛtaÕˆ™ë¨Ü:ä7EÆˆ¥sRacJš]Pde×˜öúX `céİ…%ÓoD.ÍtÒƒÜáâ½‡£=˜&5¢\\nZ=&\\\\Åy|™Wë\"H’`¿ëÿgÁ«heÚbáwNy?—dãg	C|xj¤sú–äÈ>ö]—„7Š j\\000A„t2—ƒĞ”ú3¦I>­9ú†¦ÙßšãÃºLâÒ¨<à~ÁbÎÃW…U	=ŞÌÆlfoÆ¼y\\nÂÎuª»+Ü‰w\\000’n‰¨†®`Sv‚J¬¾|³…3Lè+Õ•œÅ]7Ôrû3~İjØµ<6ŸF›C#Y°¼Œ\"ƒRÅÃbz%:¡ó¸Šš¸;»”•ì†e‚âX«@»ï‰Ü1Ëè(xÓ¢ŒF˜š{iQSˆJ5X3:ˆÜÌxü•ò/í=Ó	¬‚r*Fá:}\\r‹”4ìÆşhjÑz±#Ïù­k«›ª’ƒxî<bìJï~«ánVÃ6aÇNß€b¬;>zåFºšîÙÙIQçüÌZ.¥/*ïåŞBî¼8{÷*±Š¬Eq£\\\\Hë2>MW–®õ‘\\nÆ¾ô5¾\"w‹q¾2¦¶šãjò @Æ&”(}ÀHüG½?Â0÷\\n›ö)a â„PÖª\"`#Aœ\"=ÃÚ°p¢|Ç9€tÏkÃø{Q³ç—f‘\\\\yM/{ÜÏ£ï…¥×ìŞ²½PœÖ.Áı}*ÊMÅşK¢ˆ¼H„DwösÀçÁ?Ú‡ ¤ëøuÔ?ßË»K‘®Ë``GÚ¢˜ÄèG¢PPÍkKºÑR‘GîãÉ[,¯	š÷%¢°KÅüU|VDH+İ»ÿB¹Éw\\rğêeD\\000‡\\000âÎƒª„êÎW†Eôõ¦ÄiŞ&2;Ö4ğâ Sljûû©4:ÛDgÅÛ±eÒ¿ÏqüE0³èUŠNj\\r{Ç\\'´¥4ºÔÂº+ÄôÒI%I† KwÃ§7>»í¹	ñâ»¾Y:”ïÒØXGÊh‹·C£¹VÃR\\n!\\rĞÕÈ•bÅ¾A°Zl—§¨„˜ÉeÍñÄxÉ¿¾äÏ@s|Í3†o„ yZó·Æ=MÖÜ51B0RzE\\000;¹ºÖZ¬/@gªP€}:…Sé^Qngı±5k‘–ŠÆeÔÕO Î;Ú@¿JI@±P\"¤°¤ch±±wipŠ~<èWÿeÙËÍn_Œ{Á©ÁƒP0j£ûE¬?”éÉ»©‚à±WÑzdªÇ~/wËX„§§ıviè/Øù¼zöìà¬*`÷ïòñø\\nˆjk@÷„ÚEÜcpß`_mó.Ù¢€T7n9	¹fM®¡ƒºˆ‡$Õ4\\r‘d×ÈP[°	7ˆ`/_dÍ—K¤¿‚Í÷@ä%ë£º?€7–Üá7JGùĞİüàÿòĞÒ¾qÅƒ)6:¯û¬Z»ıaôÆÌ6³˜“Ä¸a†è±·ºù\\'ÖDÀİJ®Ş2£ztÖÌ˜zôÄé(Û\\\\Â@)R8\\'¤_\\reMÊ™—Ú¢#aÕ-=‰µÌ¯ŠkŸÍáÈ@I{{Œß 4Áç<#Š¬küjwÑêjNÓĞF_’­v`à<¯eHi¤jTGÃğ}¤£“°Hå,¹Ü?“ş¿\\nlÆzóM‡ğ©B=¨\\ré¼dRàÈò(Í…sm€ø1Œ*JçøªrŒM©~7ôä¸_&×{a®ãD7ÈånU@{AµHs7•(#ÔT°Z®fXÒ	G­÷¥Ë a;v§}Y¤¤£ô‰“Ä¯`ë®‡E¥%ËßÌ%\\';®}&2‡eÊ±Ò}q;ï˜}ı*>e“š*´sq¬a6_ˆ½U³”D8ÕÊ³l¦Âòä¬Zœ|ù¡‘ò>¬íZó.»H_‚ÜğdL²`Âğèë¯†¡aQÍö\"ı|q$L­\"Õ‡V¿KÊ7”W˜E¡éQ‹qÓ$\"Ä}ÉÒa›2‚ùå×ÒfXo„´¢÷••ğ—bï.9`ÙAisdk>„&×—˜×f Üòñ­éè9·™7H¡Ã”	 ƒ‡.^vY%›Mè‘Ùch	­ÛUzåS³Iõ÷&PâjõÉ³c‚EN*àbóPÆ´fv×±†!ìõX€òÄŞ²¸S‚ªÆª;yœ“=yú`æÏùj;I6x®Ã‡ï¦¦&À.€€X…3µÎ­mïsÇ;¿¥ç-w\\'}ªpÎáát!y†©ãéÖ)˜´ú ÑÒÛIÛˆïÁ±D9-@»1•ëüú^¤wïoJ…1½Cö\\000l\\000Î@',6793 if\"ä\"~=\"\\xE4\"then local a=assert(fs.open(shell.getRunningProgram(),\"rb\"))local b=a.readAll()a.close()return assert(load(b,\"@\"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error(\"File corrupted (expected \"..size..\", got \"..#disk..\")\")end;local c=require\"cc.expect\"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),\"\"repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,\"invalid chunk\")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error(\"invalid chunk\")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch(\"[^/]+\")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)==\"table\"and\"\"or O elseif type(O)~=\"table\"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match(\"^\"..aj:gsub(\"([%%%.])\",\"%%%1\"):gsub(\"%*\",\"%.%*\")..\"$\")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or\"\"if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)==\"string\"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak..\"/\"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if type(ad)~=\"table\"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch(\"[^/]+\")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)return type(ad)==\"table\"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,\"string\")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,\"string\")if ac(disk,ae)~=nil then return\"mem\"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)==\"table\"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,\"string\")c(2,ao,\"string\")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao==\"r\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local ap=ad;ad=\"\"for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and\"?\"or string.char(a7))end;ad=ad:gsub(\"\\r\\n\",\"\\n\")local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;c(1,au,\"number\",\"nil\")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end}elseif ao==\"w\"or ao==\"a\"then return nil,\"Permission denied\"elseif ao==\"rb\"then if type(ad)~=\"string\"then return nil,\"Is a directory\"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error(\"file is already closed\",2)end;if A>#ad then return end;local x,as=ad:match(ar and\"([^\\n]*\\n?)()\"or\"([^\\n]*)\\n?()\",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error(\"file is already closed\",2)end;if#ad==0 and A==1 then A=2;return\"\"end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,\"number\",\"nil\")if aq then error(\"file is already closed\",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error(\"file is already closed\",2)end;aq=true end,seek=function(av,aw)if aq then error(\"file is already closed\",2)end;c(1,av,\"string\",\"nil\")c(2,aw,\"number\",\"nil\")av=av or\"cur\"aw=aw or 0;if av==\"set\"then A=aw+1 elseif av==\"cur\"then A=A+aw elseif av==\"end\"then A=#ad-aw else error(\"bad argument #1 (invalid option \"..av..\")\",2)end;return A end}elseif ao==\"wb\"or ao==\"ab\"then return nil,\"Permission denied\"else return nil,\"Invalid mode\"end end,find=function(ax)c(1,ax,\"string\")local ag={}for M in ax:gmatch(\"[^/]+\")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,\"string\")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)==\"table\"and 0 or#ad,isDir=type(ad)==\"table\",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,\"/init.lua\")_G.fs=fs;if not ay then printError(az)end\
" local name = 'bank' local desc = 'Banking_App' term.setTextColor(colors.black)term.setBackgroundColor(colors.white)term.clear()local function a(b,c,d,e)local g,h=term.getSize()local i=math.floor((g-#b)/2)+1;for j,k in pairs(c)do term.setTextColor(k.color)term.setBackgroundColor(e)term.setCursorPos(i,d)term.write(k.text)i=i+#k.text end end;a("App installer",{{text="App installer",color=colors.gray}},2,colors.white)term.setCursorPos(1,3)term.write("-----------------------------------")term.setCursorPos(2,5)term.write("Name: ")print("")print(name)term.setCursorPos(2,8)term.write("Description: ")print("")print(desc)print(" ")print(" ")print(" ")print("Enter to setup, BACK to cancel...")local l,m,n=os.pullEvent("key")if m==keys.enter then local o=name;f=fs.open("appData/"..o.."/app","wb")f.write(app)f.close()f=fs.open("appData/"..o.."/data","w")f.write(textutils.serialise({name,o}))f.close()print("Done!")else term.clear()end
-- End of File: userData/bank.app

-- File: userData/test
print("hi")

-- End of File: userData/test

